<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discovery Verification System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: white;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        header {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
            padding: 40px 50px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        h2 {
            color: #f9a825;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #f9a825;
        }

        textarea:disabled {
            background: #f5f5f5;
            color: #666;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }


        button {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(249, 168, 37, 0.4);
        }

        button:active {
            transform: translateY(0);
        }


        /* Engagement Metadata */
        .engagement-metadata {
            padding: 30px 50px;
            background: #f8f9fa;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            padding-bottom: 10px;
            border-bottom: 2px solid #ddd;
            margin-bottom: 5px;
        }

        .mode-badge {
            font-weight: 700;
            font-size: 1.1em;
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .mode-badge.edit-mode {
            background: #4caf50;
            color: white;
        }

        .mode-badge.view-mode {
            background: #2196f3;
            color: white;
        }

        .btn-mode-toggle {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #ddd;
            font-family: inherit;
            font-size: 0.95em;
            background: white;
            color: #666;
        }

        .btn-mode-toggle:hover {
            border-color: #f9a825;
            color: #f9a825;
            transform: translateY(-2px);
        }

        .engagement-metadata input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
        }

        .engagement-metadata input:focus {
            outline: none;
            border-color: #f9a825;
        }

        .engagement-metadata input:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .auto-save-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #e8f5e9;
            border: 1px solid #4caf50;
            border-radius: 6px;
            color: #2e7d32;
            font-size: 14px;
            font-weight: 500;
            animation: fadeIn 0.3s ease-in;
        }

        .auto-save-indicator.saving {
            background: #fff3e0;
            border-color: #ff9800;
            color: #e65100;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .metadata-actions {
            display: flex;
            gap: 10px;
        }

        .btn-primary, .btn-secondary {
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-family: inherit;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(249, 168, 37, 0.4);
        }

        .btn-secondary {
            background: white;
            border: 2px solid #ddd;
            color: #666;
        }

        .btn-secondary:hover {
            border-color: #f9a825;
            color: #f9a825;
            transform: translateY(-2px);
        }

        /* Dashboard */
        .dashboard-section {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            padding: 30px;
            color: white;
        }

        .coverage-overview {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 40px;
            max-width: 100%;
            padding: 0 30px;
            align-items: center;
        }

        .overall-stats {
            display: flex;
            gap: 25px;
            align-items: center;
        }

        .stat-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 4px solid white;
        }

        .stat-content {
            text-align: center;
        }

        .percentage {
            display: block;
            font-size: 2em;
            font-weight: 700;
            line-height: 1;
        }

        .label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-top: 5px;
            display: block;
        }

        .stat-details {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
        }

        .stat-row .icon {
            font-size: 1.3em;
        }

        .phase-breakdown {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .phase-bar {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .phase-label {
            min-width: 220px;
            font-weight: 500;
            font-size: 0.95em;
        }

        .progress-bar {
            flex: 1;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: white;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .phase-count {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
        }

        /* Tab Navigation */
        .tabs-navigation {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #ddd;
            background: #f8f9fa;
            padding: 0 30px;
            overflow-x: auto;
        }

        .tab-btn {
            background: transparent;
            border: none;
            padding: 15px 20px;
            color: #666;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
            width: auto;
            font-size: 14px;
        }

        .tab-btn:hover {
            background: rgba(249, 168, 37, 0.1);
            color: #f9a825;
            transform: none;
            box-shadow: none;
        }

        .tab-btn.active {
            color: #f9a825;
            border-bottom-color: #f9a825;
            background: white;
        }

        .tab-badge {
            display: inline-block;
            background: #ddd;
            color: #666;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 8px;
            font-weight: 600;
        }

        .tab-badge.complete {
            background: #4caf50;
            color: white;
        }

        /* Phase Color Coding */
        .tab-btn[data-phase="1"].active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
        }

        .tab-btn[data-phase="2"].active {
            border-bottom-color: #10b981;
            color: #10b981;
        }

        .tab-btn[data-phase="3"].active {
            border-bottom-color: #8b5cf6;
            color: #8b5cf6;
        }

        .tab-btn[data-phase="4"].active {
            border-bottom-color: #f59e0b;
            color: #f59e0b;
        }

        .tab-btn[data-phase="5"].active {
            border-bottom-color: #ef4444;
            color: #ef4444;
        }

        /* Tab Panels */
        .tabs-content {
            padding: 0;
        }

        .tab-panel {
            display: none;
            padding: 40px 50px;
        }

        .tab-panel.active {
            display: block;
        }

        /* Question Cards */
        .question-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .question-card:hover {
            border-color: #f9a825;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .question-card[data-status="answered"] {
            border-left: 5px solid #4caf50;
        }

        .question-card[data-status="open"] {
            border-left: 5px solid #ff9800;
        }

        .question-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .question-number {
            background: #f9a825;
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 0.9em;
            min-width: 50px;
            text-align: center;
        }

        /* Phase-specific question number colors */
        .question-card[data-phase="1"] .question-number {
            background: #3b82f6;
        }

        .question-card[data-phase="2"] .question-number {
            background: #10b981;
        }

        .question-card[data-phase="3"] .question-number {
            background: #8b5cf6;
        }

        .question-card[data-phase="4"] .question-number {
            background: #f59e0b;
        }

        .question-card[data-phase="5"] .question-number {
            background: #ef4444;
        }

        .question-text {
            flex: 1;
            margin: 0;
            font-size: 1.1em;
            color: #333;
            font-weight: 600;
        }

        .status-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
        }

        .status-badge.answered {
            background: #4caf50;
            color: white;
        }

        .status-badge.open {
            background: #ff9800;
            color: white;
        }

        /* Discovery Methods Selector */
        .methods-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .method-tag {
            background: #f0f0f0;
            border: 2px solid #ddd;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            width: auto;
            font-family: inherit;
        }

        .method-tag:hover {
            background: #fff;
            border-color: #f9a825;
            transform: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .method-tag.active {
            background: #f9a825;
            border-color: #f9a825;
            color: white;
        }

        .method-tag:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #f5f5f5;
            color: #333;
        }

        .method-tag:disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: #ddd;
            background: #f5f5f5;
        }

        .method-tag.active:disabled {
            background: #f9a825;
            color: #333;
        }

        /* Smart Suggestion Banner */
        .suggestion-banner {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border-left: 4px solid #ffa726;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            animation: slideIn 0.3s ease-out;
        }

        .suggestion-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: #e65100;
        }

        .suggestion-icon {
            font-size: 20px;
        }

        .suggestion-list {
            margin: 0;
            padding-left: 25px;
            list-style-type: none;
        }

        .suggestion-list li {
            margin: 6px 0;
        }

        .suggestion-list li::before {
            content: "→ ";
            color: #ffa726;
            font-weight: bold;
            margin-right: 8px;
        }

        .suggestion-link {
            color: #1976d2;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .suggestion-link:hover {
            color: #0d47a1;
            text-decoration: underline;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes highlight {
            0%, 100% {
                background: white;
            }
            50% {
                background: #fff9c4;
            }
        }

        /* Progress Ring */
        .progress-ring {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Technique Filters */
        .technique-filters {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-label {
            font-weight: 600;
            color: #666;
            font-size: 14px;
            min-width: 70px;
        }

        .filter-btn {
            background: white;
            border: 2px solid #ddd;
            padding: 6px 14px;
            border-radius: 18px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }

        .filter-btn:hover {
            border-color: #ff6b35;
            color: #ff6b35;
        }

        .filter-btn.active {
            background: #ff6b35;
            border-color: #ff6b35;
            color: white;
        }

        .technique-card[data-filtered="true"] {
            display: none;
        }

        /* Info Tooltip */
        .info-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 6px;
        }

        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 50%;
            font-size: 12px;
            cursor: help;
            font-weight: bold;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            left: 0;
            top: 25px;
            background: #333;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            white-space: normal;
            min-width: 300px;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: opacity 0.3s, visibility 0.3s;
            font-weight: normal;
        }

        .tooltip-content::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 10px;
            border: 6px solid transparent;
            border-bottom-color: #333;
        }

        .info-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        /* Method Presets */
        .method-presets {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed #ddd;
            flex-wrap: wrap;
        }

        .preset-label {
            font-size: 0.85em;
            color: #666;
            font-weight: 500;
        }

        .preset-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        .question-body {
            margin-top: 20px;
        }

        .question-footer {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .last-updated {
            font-size: 0.85em;
            color: #999;
        }

        .btn-mark-complete {
            background: #4caf50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-mark-complete:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-mark-complete:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #9e9e9e;
        }

        .btn-mark-complete:disabled:hover {
            transform: none;
            background: #9e9e9e;
        }

        /* Empty State Banner */
        .empty-state-banner {
            background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            text-align: left;
        }

        .empty-state-icon {
            font-size: 48px;
            flex-shrink: 0;
        }

        .empty-state-content h4 {
            margin: 0 0 8px 0;
            color: #2d3748;
            font-size: 18px;
            font-weight: 600;
        }

        .empty-state-content p {
            margin: 0;
            color: #718096;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Character Counter */
        .char-counter {
            text-align: right;
            font-size: 12px;
            color: #999;
            margin-top: 4px;
            transition: color 0.2s;
        }

        .char-counter .char-count {
            font-weight: 600;
            color: #666;
        }

        .char-counter.has-content .char-count {
            color: #ff6b35;
        }

        /* Phase Navigation */
        .phase-navigation {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }

        .btn-nav {
            flex: 1;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 600;
            border: 2px solid #ff6b35;
            background: white;
            color: #ff6b35;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-nav:hover:not(:disabled) {
            background: #ff6b35;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .btn-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #ccc;
            color: #999;
        }

        .btn-nav.btn-next {
            background: #ff6b35;
            color: white;
        }

        .btn-nav.btn-next:hover:not(:disabled) {
            background: #e55a2b;
        }

        /* Summary Panel */
        .summary-panel {
            max-width: 100%;
            width: 100%;
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .summary-content {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 30px;
            min-height: 200px;
            width: 100%;
        }

        .summary-section {
            margin-bottom: 30px;
        }

        .summary-section h3 {
            color: #f9a825;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .summary-section h4 {
            color: #333;
            margin-bottom: 10px;
            margin-top: 20px;
        }

        .summary-section ul {
            list-style: none;
            padding: 0;
        }

        .summary-section li {
            padding: 10px;
            background: white;
            border-left: 3px solid #f9a825;
            margin-bottom: 8px;
            border-radius: 4px;
        }

        .gaps-list li {
            border-left-color: #ff9800;
        }

        .coaching-section {
            background: #fffde7;
            border-left: 4px solid #fbc02d;
            padding: 20px;
            margin-top: 30px;
            border-radius: 8px;
        }

        .coaching-section h3 {
            color: #f57f17;
        }

        .technique-source {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            color: #999;
            font-size: 0.9em;
        }

        .methods-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .method-stat {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #eee;
        }

        .method-stat.used {
            border-color: #4caf50;
        }

        .method-icon {
            font-size: 2em;
            display: block;
            margin-bottom: 8px;
        }

        .method-label {
            display: block;
            font-weight: 600;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .method-count {
            display: block;
            font-size: 1.5em;
            font-weight: 700;
            color: #f9a825;
        }

        .phase-insight {
            margin-bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 6px;
        }

        .phase-insight h5 {
            color: #f9a825;
            margin-bottom: 10px;
        }

        .phase-progress {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .phase-progress .progress-bar {
            background: #eee;
        }

        .phase-progress .progress-fill {
            background: #4caf50;
        }

        /* Technique Recommendations */
        .techniques-recommendations {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        .technique-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #eee;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        .technique-card:hover {
            border-color: #f9a825;
            box-shadow: 0 4px 12px rgba(249, 168, 37, 0.15);
        }

        .technique-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            gap: 15px;
            cursor: pointer;
        }

        .technique-header .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            flex-wrap: wrap;
        }

        .technique-header h4 {
            margin: 0;
            color: #333;
            font-size: 1.2em;
        }

        .collapse-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            color: #666;
            transition: transform 0.3s, color 0.2s;
        }

        .collapse-btn:hover {
            color: #ff6b35;
        }

        .technique-card[data-collapsed="true"] .collapse-btn .collapse-icon {
            transform: rotate(-90deg);
            display: inline-block;
        }

        .technique-collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
        }

        .technique-card[data-collapsed="true"] .technique-collapsible-content {
            max-height: 0;
            opacity: 0;
        }

        .technique-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
            text-transform: uppercase;
        }

        /* Discovery Technique Categories */
        .technique-badge.framing-planning {
            background: #e3f2fd;
            color: #1976d2;
        }

        .technique-badge.customer-research {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .technique-badge.ideation {
            background: #fff9c4;
            color: #f57f17;
        }

        .technique-badge.prototyping {
            background: #e8f5e9;
            color: #388e3c;
        }

        .technique-badge.usability-testing {
            background: #fff3e0;
            color: #f57c00;
        }

        .technique-badge.value-testing {
            background: #fce4ec;
            color: #c2185b;
        }

        .technique-badge.quantitative-testing {
            background: #e0f2f1;
            color: #00796b;
        }

        .technique-badge.feasibility-viability-testing {
            background: #fff9c4;
            color: #f57f17;
        }

        .technique-badge.discovery-workflows {
            background: #f1f8e9;
            color: #689f38;
        }

        .technique-badge.metrics-analysis {
            background: #e8eaf6;
            color: #3f51b5;
        }

        /* Coaching Technique Categories */
        .technique-badge.coaching,
        .technique-badge.assessment-planning,
        .technique-badge.coaching-techniques-applied,
        .technique-badge.organizational-coaching,
        .technique-badge.team-objectives-coaching {
            background: #fff3e0;
            color: #e65100;
        }

        /* Score Badge */
        .score-badge {
            background: #4caf50;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 8px;
        }

        .score-badge.coaching {
            background: #ff9800;
        }

        .technique-description {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .technique-match-reasons {
            background: #fffbf0;
            border-left: 4px solid #f9a825;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .technique-match-reasons strong {
            color: #f9a825;
            display: block;
            margin-bottom: 8px;
        }

        .technique-match-reasons ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .technique-match-reasons li {
            padding: 4px 0;
            background: none;
            border: none;
            margin: 0;
            color: #555;
        }

        .technique-meta {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .meta-item {
            margin-bottom: 10px;
        }

        .meta-item:last-child {
            margin-bottom: 0;
        }

        .meta-label {
            font-weight: 600;
            color: #666;
            display: inline-block;
            min-width: 140px;
        }

        .meta-value {
            color: #333;
        }

        .technique-outcomes {
            margin-top: 15px;
        }

        .technique-outcomes strong {
            color: #333;
            display: block;
            margin-bottom: 8px;
        }

        .technique-outcomes ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .technique-outcomes li {
            padding: 4px 0;
            background: none;
            border: none;
            margin: 0;
            color: #555;
        }

        /* Execution Guide Styles */
        .execution-guide {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .execution-steps,
        .execution-variations,
        .execution-pitfalls {
            margin-bottom: 15px;
        }

        .execution-steps:last-child,
        .execution-variations:last-child,
        .execution-pitfalls:last-child {
            margin-bottom: 0;
        }

        .execution-steps h4,
        .execution-variations h4,
        .execution-pitfalls h4 {
            color: #333;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 10px 0;
        }

        .execution-steps ol {
            margin: 0;
            padding-left: 20px;
            list-style-position: outside;
        }

        .execution-steps li {
            padding: 6px 0;
            color: #444;
            line-height: 1.6;
        }

        .execution-variations ul,
        .execution-pitfalls ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .execution-variations li,
        .execution-pitfalls li {
            padding: 4px 0;
            color: #555;
            line-height: 1.5;
        }

        .execution-pitfalls {
            background: #fff3cd;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #ff9800;
        }

        .execution-pitfalls h4 {
            color: #856404;
        }

        .execution-pitfalls li {
            color: #856404;
        }

        .summary-actions {
            margin-top: 30px;
            display: flex;
            gap: 15px;
        }

        /* Urgency Indicators */
        .urgency-indicator {
            font-size: 1.2em;
            margin-right: 8px;
            display: inline-block;
        }

        .urgency-indicator.critical {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Expandable Detail Sections */
        .technique-details-sections {
            margin-top: 15px;
        }

        .detail-section {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .section-toggle {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #fafafa;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #333;
            text-align: left;
            transition: background 0.2s;
        }

        .section-toggle:hover {
            background: #f0f0f0;
        }

        .section-toggle::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s;
        }

        .section-toggle[aria-expanded="false"]::after {
            transform: rotate(-90deg);
        }

        .section-content {
            padding: 15px;
            max-height: 500px;
            transition: max-height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }

        .section-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        /* Score Breakdown */
        .score-breakdown {
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .score-breakdown-table {
            width: 100%;
            border-collapse: collapse;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed #eee;
        }

        .score-row:last-child {
            border-bottom: none;
            font-weight: bold;
            border-top: 2px solid #333;
            margin-top: 5px;
            padding-top: 10px;
        }

        .score-label {
            color: #555;
        }

        .score-value {
            color: #4caf50;
            font-weight: 600;
        }

        .score-value.zero {
            color: #999;
        }

        /* Q&A Attribution */
        .qa-attribution {
            background: #f5f9ff;
            border-left: 3px solid #2196f3;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 0 4px 4px 0;
        }

        .qa-attribution-header {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .qa-item {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e3f2fd;
        }

        .qa-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .qa-question {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .qa-terms {
            font-size: 12px;
            color: #1976d2;
        }

        .qa-points {
            font-size: 11px;
            color: #4caf50;
            font-weight: 600;
        }

        /* Contextual Rationale */
        .contextual-rationale {
            font-style: italic;
            color: #444;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        /* Contextualized Outcomes */
        .contextualized-outcomes ul {
            margin: 0;
            padding-left: 20px;
        }

        .contextualized-outcomes li {
            padding: 4px 0;
            color: #555;
        }

        .contextualized-outcomes li .context-note {
            font-size: 11px;
            color: #1976d2;
            font-style: italic;
        }

        /* Sequencing Info */
        .sequencing-info {
            color: #666;
            line-height: 1.5;
        }

        .sequencing-prerequisites {
            margin-bottom: 10px;
        }

        .sequencing-prerequisite-list {
            list-style: none;
            padding: 0;
            margin: 5px 0 0 0;
        }

        .sequencing-prerequisite-list li {
            padding: 4px 0;
            color: #f57c00;
        }

        .sequencing-prerequisite-list li::before {
            content: '↗ ';
        }

        /* Notifications */
        #notifications {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }

        .notification {
            background: white;
            padding: 15px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            margin-bottom: 10px;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid #4caf50;
        }

        .notification.error {
            border-left: 4px solid #f44336;
        }

        .notification.info {
            border-left: 4px solid #2196f3;
        }

        /* Session Notes Section */
        .session-notes-section {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 0 50px 20px 50px;
            overflow: hidden;
        }

        .session-notes-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .session-notes-header:hover {
            opacity: 0.95;
        }

        .session-notes-header .note-count {
            background: rgba(255,255,255,0.2);
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.85em;
        }

        .session-notes-header .toggle-icon {
            transition: transform 0.3s;
        }

        .session-notes-section.collapsed .session-notes-content {
            display: none;
        }

        .session-notes-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .session-notes-content {
            padding: 20px;
        }

        .session-notes-content textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 10px;
        }

        .session-notes-content textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        #addSessionNoteBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            width: auto;
            margin-bottom: 20px;
        }

        #addSessionNoteBtn:hover {
            opacity: 0.9;
        }

        #sessionNotesList {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .session-note {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.85em;
            color: #666;
        }

        .note-date {
            font-weight: 500;
        }

        .note-delete-btn {
            background: none;
            border: none;
            color: #f44336;
            cursor: pointer;
            padding: 2px 8px;
            font-size: 0.9em;
            width: auto;
        }

        .note-delete-btn:hover {
            background: #ffebee;
            border-radius: 4px;
        }

        .note-content {
            color: #333;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        /* Assumption Toggle Buttons */
        .assumption-toggle {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .assumption-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            color: #666;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s;
            width: auto;
        }

        .assumption-btn:hover {
            border-color: #999;
        }

        .assumption-btn.active {
            border-color: #ff9800;
            background: #fff3e0;
            color: #e65100;
        }

        .assumption-btn.validated.active {
            border-color: #4caf50;
            background: #e8f5e9;
            color: #2e7d32;
        }

        /* Assumption Stats in Summary */
        .assumption-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }

        .assumption-stat {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-radius: 6px;
        }

        .assumption-stat.validated {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .assumption-stat.assumption {
            background: #fff3e0;
            color: #e65100;
        }

        .assumption-stat .stat-number {
            font-size: 1.5em;
            font-weight: 700;
        }

        /* Priority Alerts */
        .priority-section {
            background: #fff8e1;
            border: 2px solid #ffb300;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .priority-alert {
            background: #fff;
            border-left: 4px solid #ff9800;
            padding: 12px 15px;
            margin: 10px 0;
            border-radius: 0 6px 6px 0;
        }

        .priority-alert.high {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .priority-alert.medium {
            border-left-color: #ff9800;
            background: #fff3e0;
        }

        .suggested-questions {
            background: #e3f2fd;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }

        .suggested-questions h5 {
            color: #1565c0;
            margin-bottom: 10px;
        }

        .suggested-questions ul {
            margin: 0;
            padding-left: 20px;
        }

        .suggested-questions li {
            margin: 8px 0;
            color: #1976d2;
        }

        .unlock-badge {
            display: inline-block;
            background: #e8f5e9;
            color: #2e7d32;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 8px;
        }

        /* Action Items */
        .action-items-section {
            margin-top: 30px;
        }

        .action-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s;
        }

        .action-item:hover {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
        }

        .action-item-header {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 12px;
        }

        .action-priority {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .action-priority.high {
            background: #ffebee;
            color: #c62828;
        }

        .action-priority.medium {
            background: #fff3e0;
            color: #e65100;
        }

        .action-priority.low {
            background: #e3f2fd;
            color: #1565c0;
        }

        .action-item h4 {
            margin: 0;
            color: #333;
            flex: 1;
        }

        .action-item p {
            color: #666;
            margin: 0 0 15px 0;
            line-height: 1.5;
        }

        .action-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 0.9em;
            color: #666;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .action-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .action-meta-item strong {
            color: #333;
        }

        .action-related-questions {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .action-related-questions strong {
            color: #666;
        }

        /* Responsive */
        @media (max-width: 968px) {
            .coverage-overview {
                grid-template-columns: 1fr;
                gap: 25px;
            }

            .overall-stats {
                flex-direction: column;
                text-align: center;
            }

            .tabs-navigation {
                padding: 0 15px;
            }

            .tab-btn {
                padding: 12px 15px;
                font-size: 0.85em;
            }

            .tabs-content {
                padding: 15px;
            }

            .engagement-metadata {
                flex-direction: column;
                align-items: stretch;
            }

            .metadata-actions {
                width: 100%;
            }

            .metadata-actions button {
                flex: 1;
            }

            .phase-label {
                min-width: 100px;
                font-size: 0.85em;
            }

            .question-header {
                flex-wrap: wrap;
            }

            .summary-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }

            .technique-header {
                flex-direction: column;
                gap: 10px;
            }

            .technique-badge {
                align-self: flex-start;
            }

            .meta-label {
                min-width: auto;
                display: block;
                margin-bottom: 5px;
            }

            header h1 {
                font-size: 2em;
            }
        }
        /* Comparison View */
        .comparison-view {
            background: white;
            padding: 30px;
            border-radius: 8px;
        }

        .comparison-view h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .comparison-table {
            overflow-x: auto;
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        .comparison-table td:first-child {
            font-weight: 600;
            color: #666;
            min-width: 200px;
        }

        /* Print Styles */
        @media print {
            /* Hide interactive elements */
            .metadata-actions,
            .tabs-navigation,
            .phase-navigation,
            .method-tag,
            .method-presets,
            .preset-btn,
            .btn-mark-complete,
            .collapse-btn,
            .technique-filters,
            .filter-btn,
            .info-tooltip,
            .auto-save-indicator,
            .suggestion-banner,
            button,
            input[type="date"] {
                display: none !important;
            }

            /* Show all content */
            body {
                background: white;
                padding: 0;
                margin: 0;
            }

            .container {
                max-width: 100%;
                box-shadow: none;
                border-radius: 0;
            }

            header {
                background: white;
                color: #333;
                padding: 20px;
                border-bottom: 3px solid #333;
            }

            /* Show only summary tab for printing */
            .tab-panel {
                display: none !important;
            }

            .tab-panel[data-phase="summary"] {
                display: block !important;
                padding: 20px;
            }

            /* Expand all technique cards */
            .technique-card {
                page-break-inside: avoid;
                border: 1px solid #333;
                margin-bottom: 15px;
            }

            .technique-collapsible-content {
                max-height: none !important;
                opacity: 1 !important;
                display: block !important;
            }

            .technique-card[data-filtered="true"] {
                display: block !important;
            }

            /* Remove backgrounds for print */
            .summary-section,
            .coverage-overview,
            .technique-header,
            .empty-state-banner {
                background: white !important;
            }

            /* Make text more readable */
            body, p, li, span {
                color: #000 !important;
            }

            h1, h2, h3, h4, h5 {
                color: #000 !important;
            }

            /* Page breaks */
            .summary-section {
                page-break-inside: avoid;
            }

            h3 {
                page-break-after: avoid;
            }

            /* Show metadata as header */
            .metadata-form {
                display: block;
                margin-bottom: 20px;
                padding: 10px;
                border: 1px solid #333;
            }

            .metadata-form input {
                display: inline-block !important;
                border: none;
                border-bottom: 1px solid #333;
                background: white;
                padding: 2px;
            }

            /* Technique badges */
            .technique-badge,
            .score-badge {
                border: 1px solid #333;
                background: white !important;
                color: #000 !important;
            }

            /* Simplify technique cards for printing */
            .technique-card {
                box-shadow: none;
            }

            .technique-meta {
                border-top: 1px solid #ddd;
                padding-top: 10px;
            }

            /* Footer on each page */
            @page {
                margin: 1.5cm;
                @bottom-right {
                    content: "Page " counter(page);
                }
            }
        }

        /* Version History Panel Styles */
        .version-history-panel {
            padding: 20px;
        }

        .version-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .version-history-header h2 {
            color: #333;
            font-size: 1.5em;
        }

        .version-actions {
            display: flex;
            gap: 10px;
        }

        .client-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .client-selector label {
            font-weight: 600;
            color: #555;
        }

        .client-selector select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }

        .version-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .version-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .version-item:hover {
            border-color: #f9a825;
            box-shadow: 0 2px 8px rgba(249, 168, 37, 0.2);
        }

        .version-item.current {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .version-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .version-number {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .version-timestamp {
            color: #666;
            font-size: 0.9em;
        }

        .version-progress {
            color: #888;
            font-size: 0.85em;
        }

        .version-item-actions {
            display: flex;
            gap: 8px;
        }

        .btn-load-version {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn-load-version:hover {
            background: #1976D2;
        }

        .btn-delete-version {
            padding: 8px 12px;
            background: transparent;
            color: #f44336;
            border: 1px solid #f44336;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-delete-version:hover {
            background: #f44336;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .empty-state p {
            margin-bottom: 20px;
        }

        .storage-info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3e0;
            border-radius: 8px;
            font-size: 0.9em;
            color: #e65100;
        }

        .storage-info.warning {
            background: #ffebee;
            color: #c62828;
        }

        .storage-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }

        .storage-bar-fill {
            height: 100%;
            background: #4caf50;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .storage-bar-fill.warning {
            background: #ff9800;
        }

        .storage-bar-fill.danger {
            background: #f44336;
        }

        /* Save Version Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 450px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .modal-content input:focus {
            outline: none;
            border-color: #f9a825;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-modal-cancel {
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
        }

        .btn-modal-save {
            background: #4caf50;
            border: none;
            color: white;
        }

        .btn-modal-save:hover {
            background: #43a047;
        }

        /* Confirmation Dialog */
        .confirm-dialog {
            text-align: center;
        }

        .confirm-dialog p {
            margin-bottom: 20px;
            color: #666;
        }

        .confirm-dialog .warning-text {
            color: #f44336;
            font-weight: 500;
        }

        /* Tab styling for Version History */
        .tab-btn[data-phase="versions"].active {
            border-bottom-color: #9c27b0;
            color: #9c27b0;
        }

        .tab-btn[data-phase="versions"]:hover {
            background: rgba(156, 39, 176, 0.1);
            color: #9c27b0;
        }

        /* Unsaved changes indicator */
        .unsaved-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #ff9800;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Learning Empowered Advisor</h1>
            <p>Discovery Coaching Assistant</p>
        </header>

        <!-- Engagement Metadata -->
        <div class="engagement-metadata">
            <div id="autoSaveIndicator" class="auto-save-indicator" style="display: none;">
                <span class="save-icon">💾</span>
                <span class="save-text">All changes saved</span>
            </div>
            <input id="clientName" type="text" placeholder="Client Name">
            <input id="engagementDate" type="date" style="max-width: 180px;">
            <div class="metadata-actions">
                <button id="newEngagement" class="btn-secondary">New Engagement</button>
                <button id="importBtn" class="btn-secondary">Import</button>
                <button id="compareBtn" class="btn-secondary">Compare Assessments</button>
                <button id="exportBtn" class="btn-secondary">Export JSON</button>
                <button id="runTestsBtn" class="btn-secondary">Run Tests</button>
            </div>
        </div>

        <!-- Coverage Dashboard -->
        <div class="dashboard-section">
            <div class="coverage-overview">
                <div class="overall-stats">
                    <div class="stat-circle">
                        <div class="stat-content">
                            <span class="percentage">0%</span>
                            <span class="label">Complete</span>
                        </div>
                    </div>
                    <div class="stat-details">
                        <div class="stat-row">
                            <span class="icon">✓</span>
                            <span class="stat-value">0/36</span>
                            <span class="stat-label">Answered</span>
                        </div>
                        <div class="stat-row">
                            <span class="icon">○</span>
                            <span class="open-count">36</span>
                            <span class="stat-label">Open</span>
                        </div>
                    </div>
                </div>

                <div class="phase-breakdown">
                    <div class="phase-bar" data-phase="1">
                        <span class="phase-label">Phase 1: Foundation & Context</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="2">
                        <span class="phase-label">Phase 2: Success & Outcomes</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="3">
                        <span class="phase-label">Phase 3: Structure & Ownership</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="4">
                        <span class="phase-label">Phase 4: Team Dynamics & Constraints</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/8</span>
                    </div>
                    <div class="phase-bar" data-phase="5">
                        <span class="phase-label">Phase 5: Untested Assumptions</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/1</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Navigation -->
        <nav class="tabs-navigation">
            <button class="tab-btn active" data-phase="1">Phase 1: Foundation<span class="tab-badge">0/6</span></button>
            <button class="tab-btn" data-phase="2">Phase 2: Success<span class="tab-badge">0/10</span></button>
            <button class="tab-btn" data-phase="3">Phase 3: Structure<span class="tab-badge">0/6</span></button>
            <button class="tab-btn" data-phase="4">Phase 4: Dynamics<span class="tab-badge">0/13</span></button>
            <button class="tab-btn" data-phase="5">Phase 5: Assumptions<span class="tab-badge">0/1</span></button>
            <button class="tab-btn" data-phase="summary">Summary</button>
            <button class="tab-btn" data-phase="versions">Version History</button>
        </nav>

        <!-- Tab Panels -->
        <div class="tabs-content">
            <div class="tab-panel active" data-phase="1"></div>
            <div class="tab-panel" data-phase="2"></div>
            <div class="tab-panel" data-phase="3"></div>
            <div class="tab-panel" data-phase="4"></div>
            <div class="tab-panel" data-phase="5"></div>
            <div class="tab-panel" data-phase="summary">
                <div class="summary-panel">
                    <div class="summary-header">
                        <h2>Leadership Summary</h2>
                        <button id="generateSummary" class="btn-primary" disabled>Generate Summary</button>
                    </div>
                    <div id="summaryContent" class="summary-content"></div>
                </div>
            </div>
            <div class="tab-panel" data-phase="versions">
                <div class="version-history-panel">
                    <div class="version-history-header">
                        <h2>Version History</h2>
                        <div class="version-actions">
                            <button id="saveVersionBtn" class="btn-primary">Save Version</button>
                        </div>
                    </div>
                    <div class="client-selector">
                        <label for="clientSelect">Select Client:</label>
                        <select id="clientSelect">
                            <option value="">-- Select a client --</option>
                        </select>
                        <button id="deleteClientBtn" class="btn-secondary" style="display: none;">Delete Client</button>
                    </div>
                    <div id="versionListContainer">
                        <div class="empty-state">
                            <div class="empty-state-icon">📁</div>
                            <h3>No Saved Versions</h3>
                            <p>Save your first version to start tracking your discovery progress.</p>
                            <button id="saveFirstVersionBtn" class="btn-primary">Save First Version</button>
                        </div>
                    </div>
                    <div id="storageInfo" class="storage-info" style="display: none;">
                        <strong>Storage Usage:</strong> <span id="storageUsed">0</span> / 5 MB
                        <div class="storage-bar">
                            <div id="storageBarFill" class="storage-bar-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden file input for JSON/Markdown import -->
        <input type="file" id="importInput" accept=".json,.md,application/json,text/markdown,text/x-markdown,text/plain" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
        <input type="file" id="compareInput" accept=".json" multiple style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">

        <!-- Notifications container -->
        <div id="notifications"></div>
    </div>

    <script>
        'use strict';


        // Discovery Questions Data
        const discoveryQuestions = {
            phase1: {
                name: "Foundation & Context",
                questions: [
                    { id: "q1", text: "Why does this product exist?" },
                    { id: "q2", text: "Who actually experiences the problem we are solving?" },
                    { id: "q3", text: "How do we know this problem is worth solving now?" },
                    { id: "q4", text: "What decision are we trying to enable or change?" },
                    { id: "q22", text: "What alternatives do users have today?" },
                    { id: "q23", text: "What's been tried before and why did it fail?" }
                ]
            },
            phase2: {
                name: "Success & Outcomes",
                questions: [
                    { id: "q5", text: "What would good look like three months from now?" },
                    { id: "q6", text: "What success would look like in a (insert time period)?" },
                    { id: "q7", text: "How will we know this worked?" },
                    { id: "q8", text: "The team's relationship with metrics" },
                    { id: "q24", text: "What is the team actually measuring today?" },
                    { id: "q25", text: "Do we have baseline data to compare against?" },
                    { id: "q26", text: "Does the team have the tools/infrastructure to measure outcomes?" },
                    { id: "q27", text: "How long does it take to know if something worked?" },
                    { id: "q28", text: "How do we know our changes caused the outcome vs external factors?" },
                    { id: "q29", text: "Are we tracking leading indicators or only lagging ones?" }
                ]
            },
            phase3: {
                name: "Structure & Ownership",
                questions: [
                    { id: "q9", text: "Where product ownership actually lives today?" },
                    { id: "q10", text: "Role clarity across PO, PMs, and engineers" },
                    { id: "q11", text: "Who decides when priorities collide?" },
                    { id: "q12", text: "How intentional the backlog really is?" },
                    { id: "q30", text: "Are key stakeholders aligned on the vision and priorities?" },
                    { id: "q31", text: "How do decisions and learnings get shared across the org?" },
                    { id: "q37", text: "Are there overlapping features or capabilities across products?" }
                ]
            },
            phase4: {
                name: "Team Dynamics & Constraints",
                questions: [
                    { id: "q13", text: "The team's and leadership's appetite for challenge vs safety" },
                    { id: "q14", text: "How much autonomy the team believes they have?" },
                    { id: "q15", text: "How the team currently defines value" },
                    { id: "q16", text: "Team's past failures or trauma (did a big project fail?)" },
                    { id: "q17", text: "Hidden stakeholders who actually control decisions" },
                    { id: "q18", text: "Budget or resource constraints that nobody talks about" },
                    { id: "q19", text: "Technical debt or system constraints limiting autonomy" },
                    { id: "q20", text: "Geographic or org structure issues (distributed teams, cross functional friction)" },
                    { id: "q32", text: "How often does the team directly interact with customers/users?" },
                    { id: "q33", text: "What external dependencies could block or delay progress?" },
                    { id: "q34", text: "How does the team currently learn and experiment?" },
                    { id: "q35", text: "Does the team have the capabilities needed for this work?" },
                    { id: "q36", text: "Are there hard external deadlines driving this work?" }
                ]
            },
            phase5: {
                name: "Untested Assumptions",
                questions: [
                    { id: "q21", text: "What assumptions are we making that we have not tested?" }
                ]
            }
        };

        // Discovery Methods
        const discoveryMethods = [
            { id: "interview", label: "Interview", icon: "🗣️" },
            { id: "workshop", label: "Workshop", icon: "👥" },
            { id: "observation", label: "Observation", icon: "👀" },
            { id: "document_review", label: "Document Review", icon: "📄" },
            { id: "survey", label: "Survey", icon: "📊" },
            { id: "data_analysis", label: "Data Analysis", icon: "📈" }
        ];

        // Tab Navigator Class
        class TabNavigator {
            constructor() {
                this.activeTab = "1";
                this.setupEventListeners();
                this.initializeFromHash();
            }

            setupEventListeners() {
                document.querySelector('.tabs-navigation').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-btn')) {
                        const phase = e.target.dataset.phase;
                        this.switchTab(phase);
                    }
                });

                // Handle browser back/forward
                window.addEventListener('hashchange', () => {
                    this.initializeFromHash();
                });
            }

            switchTab(phaseId) {
                // Remove active from all
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

                // Add active to selected
                const activeBtn = document.querySelector(`.tab-btn[data-phase="${phaseId}"]`);
                const activePanel = document.querySelector(`.tab-panel[data-phase="${phaseId}"]`);

                if (activeBtn && activePanel) {
                    activeBtn.classList.add('active');
                    activePanel.classList.add('active');
                    this.activeTab = phaseId;
                    window.location.hash = `phase-${phaseId}`;
                }
            }

            initializeFromHash() {
                if (window.location.hash) {
                    const phase = window.location.hash.replace('#phase-', '');
                    this.switchTab(phase);
                }
            }
        }

        // Question State Manager Class
        class QuestionStateManager {
            constructor() {
                this.state = this.initializeState();
                this.setupEventListeners();
                this.renderAllQuestions();
                this.updateProgress();
            }

            initializeState() {
                const today = new Date().toISOString().split('T')[0];
                const state = {
                    metadata: {
                        clientName: "",
                        engagementDate: today,
                        lastModified: "",
                        sessionNotes: []  // Array of { id, date, content }
                    },
                    questions: {}
                };

                // Initialize all 36 questions
                Object.keys(discoveryQuestions).forEach(phaseKey => {
                    const phase = discoveryQuestions[phaseKey];
                    const phaseNum = parseInt(phaseKey.replace('phase', ''));

                    phase.questions.forEach(q => {
                        state.questions[q.id] = {
                            questionId: q.id,
                            phase: phaseNum,
                            text: q.text,
                            findings: "",
                            status: "open",
                            discoveryMethods: [],
                            notes: "",
                            lastUpdated: "",
                            assumptionStatus: "assumption"  // "assumption" | "validated"
                        };
                    });
                });

                return state;
            }

            setupEventListeners() {
                // Event delegation for all inputs
                document.addEventListener('input', (e) => {
                    if (e.target.matches('.findings-input, .notes-input')) {
                        const questionCard = e.target.closest('.question-card');
                        const questionId = questionCard.dataset.questionId;
                        const field = e.target.dataset.field;
                        this.updateQuestion(questionId, field, e.target.value);

                        // Update character counter
                        this.updateCharCounter(e.target);
                    }
                });

                document.addEventListener('click', (e) => {
                    if (e.target.matches('.method-tag')) {
                        this.toggleMethod(e.target);
                    }
                    if (e.target.matches('.btn-mark-complete')) {
                        this.toggleQuestionStatus(e.target);
                    }
                    if (e.target.matches('.btn-nav')) {
                        const targetPhase = e.target.dataset.targetPhase;
                        if (targetPhase && tabNavigator) {
                            tabNavigator.switchTab(targetPhase);
                        }
                    }
                    // Handle technique card collapse
                    if (e.target.closest('.collapse-btn') || e.target.closest('.technique-header')) {
                        // Don't collapse card if clicking on section toggle
                        if (e.target.closest('.section-toggle')) {
                            return;
                        }
                        const header = e.target.closest('.technique-header');
                        if (header) {
                            const card = header.closest('.technique-card');
                            if (card) {
                                const isCollapsed = card.dataset.collapsed === 'true';
                                card.dataset.collapsed = isCollapsed ? 'false' : 'true';
                            }
                        }
                    }
                    // Handle section toggle for expandable detail sections
                    if (e.target.closest('.section-toggle')) {
                        const toggle = e.target.closest('.section-toggle');
                        const content = toggle.closest('.detail-section').querySelector('.section-content');
                        const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
                        toggle.setAttribute('aria-expanded', !isExpanded);
                        content.classList.toggle('collapsed', isExpanded);
                    }
                    // Handle method preset clicks
                    if (e.target.matches('.preset-btn')) {
                        const preset = e.target.dataset.preset;
                        const questionCard = e.target.closest('.question-card');
                        if (preset && questionCard) {
                            const methodIds = preset.split(',');
                            const questionId = questionCard.dataset.questionId;

                            // Clear existing methods first
                            this.state.questions[questionId].discoveryMethods = [];
                            questionCard.querySelectorAll('.method-tag').forEach(tag => {
                                tag.classList.remove('active');
                            });

                            // Apply preset methods
                            methodIds.forEach(methodId => {
                                const methodTag = questionCard.querySelector(`[data-method="${methodId}"]`);
                                if (methodTag) {
                                    methodTag.classList.add('active');
                                    if (!this.state.questions[questionId].discoveryMethods.includes(methodId)) {
                                        this.state.questions[questionId].discoveryMethods.push(methodId);
                                    }
                                }
                            });

                            this.showAutoSaveIndicator();
                        }
                    }
                    // Handle technique filter clicks
                    if (e.target.matches('.filter-btn')) {
                        const filterType = e.target.dataset.filterType;
                        const filterValue = e.target.dataset.filterValue;

                        // Update active state for this filter group
                        const filterGroup = e.target.closest('.filter-group');
                        filterGroup.querySelectorAll('.filter-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        e.target.classList.add('active');

                        // Apply filters
                        this.applyTechniqueFilters();
                    }
                });

                // Metadata listeners
                ['clientName', 'engagementDate'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('input', (e) => {
                            this.state.metadata[id] = e.target.value;
                            this.showAutoSaveIndicator();
                        });
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const cmdOrCtrl = isMac ? e.metaKey : e.ctrlKey;

                    // Cmd/Ctrl + 1-6: Switch tabs
                    if (cmdOrCtrl && e.key >= '1' && e.key <= '6') {
                        e.preventDefault();
                        const phaseMap = {
                            '1': '1', '2': '2', '3': '3',
                            '4': '4', '5': '5', '6': 'summary'
                        };
                        this.tabNavigator.switchTab(phaseMap[e.key]);
                    }

                    // Cmd/Ctrl + S: Export JSON
                    if (cmdOrCtrl && e.key === 's') {
                        e.preventDefault();
                        document.getElementById('exportBtn')?.click();
                    }

                    // Cmd/Ctrl + Enter: Generate Summary
                    if (cmdOrCtrl && e.key === 'Enter') {
                        e.preventDefault();
                        const summaryBtn = document.getElementById('generateSummary');
                        if (summaryBtn && !summaryBtn.disabled) {
                            summaryBtn.click();
                        }
                    }

                    // Cmd/Ctrl + N: New Engagement
                    if (cmdOrCtrl && e.key === 'n') {
                        e.preventDefault();
                        document.getElementById('newEngagement')?.click();
                    }
                });
            }

            updateQuestion(questionId, field, value) {
                if (!this.state.questions[questionId]) return;

                this.state.questions[questionId][field] = value;
                this.state.questions[questionId].lastUpdated = new Date().toISOString();

                // Auto-update status based on findings
                if (field === 'findings') {
                    const newStatus = value.trim().length > 0 ? 'answered' : 'open';
                    this.state.questions[questionId].status = newStatus;
                    this.updateQuestionCardStatus(questionId, newStatus);

                    // Show smart suggestions based on keywords
                    if (value.trim().length > 20) { // Only suggest if meaningful text
                        this.showSmartSuggestions(questionId, value);
                    }
                }

                this.updateProgress();
                this.showAutoSaveIndicator();
            }

            toggleMethod(methodTag) {
                methodTag.classList.toggle('active');

                const questionCard = methodTag.closest('.question-card');
                const questionId = questionCard.dataset.questionId;
                const method = methodTag.dataset.method;

                const methods = this.state.questions[questionId].discoveryMethods;
                const index = methods.indexOf(method);

                if (index > -1) {
                    methods.splice(index, 1);
                } else {
                    methods.push(method);
                }

                this.showAutoSaveIndicator();
            }

            toggleQuestionStatus(button) {
                const questionCard = button.closest('.question-card');
                const questionId = questionCard.dataset.questionId;
                const currentStatus = this.state.questions[questionId].status;

                const newStatus = currentStatus === 'open' ? 'answered' : 'open';
                this.state.questions[questionId].status = newStatus;

                this.updateQuestionCardStatus(questionId, newStatus);
                this.updateProgress();
                this.showAutoSaveIndicator();
            }

            updateQuestionCardStatus(questionId, status) {
                const card = document.querySelector(`[data-question-id="${questionId}"]`);
                if (!card) return;

                card.dataset.status = status;

                const badge = card.querySelector('.status-badge');
                badge.className = `status-badge ${status}`;
                badge.textContent = status === 'answered' ? '✓ Answered' : '○ Open';

                const button = card.querySelector('.btn-mark-complete');
                button.textContent = status === 'answered' ? 'Mark as Open' : 'Mark as Answered';
            }

            calculateCoverage() {
                const total = Object.keys(this.state.questions).length;
                const answered = Object.values(this.state.questions).filter(q => q.status === 'answered').length;

                const byPhase = {};
                for (let i = 1; i <= 5; i++) {
                    const phaseQuestions = Object.values(this.state.questions).filter(q => q.phase === i);
                    const phaseAnswered = phaseQuestions.filter(q => q.status === 'answered').length;
                    byPhase[i] = {
                        total: phaseQuestions.length,
                        answered: phaseAnswered,
                        percentage: phaseQuestions.length > 0 ? (phaseAnswered / phaseQuestions.length) * 100 : 0
                    };
                }

                return {
                    overall: (answered / total) * 100,
                    answeredCount: answered,
                    totalCount: total,
                    openCount: total - answered,
                    byPhase
                };
            }

            updateProgress() {
                const coverage = this.calculateCoverage();

                // Update main stats
                const percentageEl = document.querySelector('.percentage');
                const statValueEl = document.querySelector('.stat-value');
                const openCountEl = document.querySelector('.open-count');

                if (percentageEl) percentageEl.textContent = `${coverage.overall.toFixed(0)}%`;
                if (statValueEl) statValueEl.textContent = `${coverage.answeredCount}/${coverage.totalCount}`;
                if (openCountEl) openCountEl.textContent = coverage.openCount;

                // Update phase bars
                Object.entries(coverage.byPhase).forEach(([phase, data]) => {
                    const phaseBar = document.querySelector(`.phase-bar[data-phase="${phase}"]`);
                    if (phaseBar) {
                        const fill = phaseBar.querySelector('.progress-fill');
                        const count = phaseBar.querySelector('.phase-count');
                        if (fill) fill.style.width = `${data.percentage}%`;
                        if (count) count.textContent = `${data.answered}/${data.total}`;
                    }

                    // Update tab badges
                    const tabBtn = document.querySelector(`.tab-btn[data-phase="${phase}"]`);
                    if (tabBtn) {
                        const badge = tabBtn.querySelector('.tab-badge');
                        if (badge) {
                            badge.textContent = data.percentage === 100
                                ? `${data.answered}/${data.total} ✓`
                                : `${data.answered}/${data.total}`;
                            if (data.percentage === 100) {
                                badge.classList.add('complete');
                            } else {
                                badge.classList.remove('complete');
                            }
                        }
                    }
                });

                // Update Generate Summary button state
                this.updateSummaryButtonState(coverage.answeredCount);
            }

            updateSummaryButtonState(answeredCount) {
                const summaryBtn = document.getElementById('generateSummary');
                if (summaryBtn) {
                    if (answeredCount > 0) {
                        summaryBtn.disabled = false;
                        summaryBtn.style.cursor = 'pointer';
                        summaryBtn.style.opacity = '1';
                    } else {
                        summaryBtn.disabled = true;
                        summaryBtn.style.cursor = 'not-allowed';
                        summaryBtn.style.opacity = '0.5';
                    }
                }
            }

            showAutoSaveIndicator() {
                const indicator = document.getElementById('autoSaveIndicator');
                if (!indicator) return;

                // Show "Saving..." state
                indicator.classList.add('saving');
                indicator.querySelector('.save-text').textContent = 'Saving...';
                indicator.style.display = 'flex';

                // After 500ms, show "All changes saved"
                setTimeout(() => {
                    indicator.classList.remove('saving');
                    indicator.querySelector('.save-text').textContent = 'All changes saved';

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                }, 500);
            }

            updateCharCounter(textarea) {
                const formGroup = textarea.closest('.form-group');
                if (!formGroup) return;

                const counter = formGroup.querySelector('.char-counter');
                const charCount = counter.querySelector('.char-count');

                if (charCount) {
                    const length = textarea.value.length;
                    charCount.textContent = length;

                    // Add visual feedback for content
                    if (length > 0) {
                        counter.classList.add('has-content');
                    } else {
                        counter.classList.remove('has-content');
                    }
                }
            }

            showSmartSuggestions(currentQuestionId, text) {
                const keywords = {
                    'q2': ['customer', 'user', 'target', 'audience', 'segment'],
                    'q3': ['outcome', 'success', 'metric', 'kpi', 'measure'],
                    'q4': ['current', 'existing', 'today', 'now', 'problem'],
                    'q5': ['research', 'interview', 'test', 'data', 'evidence'],
                    'q6': ['value', 'benefit', 'worth', 'roi', 'impact'],
                    'q8': ['willing', 'pay', 'price', 'commit', 'purchase'],
                    'q9': ['build', 'technical', 'feasible', 'engineer', 'develop'],
                    'q15': ['constraint', 'limitation', 'requirement', 'must', 'compliance'],
                    'q16': ['assumption', 'believed', 'thought', 'expected', 'assumed'],
                    'q17': ['assumption', 'validated', 'tested', 'proved', 'disproved'],
                    'q37': ['overlap', 'duplicate', 'taxonomy', 'portfolio', 'redundant', 'same feature', 'multiple products']
                };

                const textLower = text.toLowerCase();
                const suggestions = [];

                // Find matching questions
                Object.entries(keywords).forEach(([qId, words]) => {
                    if (qId !== currentQuestionId && this.state.questions[qId].status === 'open') {
                        const hasMatch = words.some(word => textLower.includes(word));
                        if (hasMatch) {
                            const question = Object.values(discoveryQuestions)
                                .flatMap(p => p.questions)
                                .find(q => q.id === qId);
                            if (question) {
                                suggestions.push({ id: qId, text: question.text });
                            }
                        }
                    }
                });

                // Show suggestion banner if we have suggestions
                const questionCard = document.querySelector(`[data-question-id="${currentQuestionId}"]`);
                if (questionCard && suggestions.length > 0) {
                    this.renderSuggestionBanner(questionCard, suggestions.slice(0, 2)); // Max 2 suggestions
                }
            }

            renderSuggestionBanner(questionCard, suggestions) {
                // Remove existing banner
                const existing = questionCard.querySelector('.suggestion-banner');
                if (existing) existing.remove();

                // Create new banner
                const banner = document.createElement('div');
                banner.className = 'suggestion-banner';
                banner.innerHTML = `
                    <div class="suggestion-header">
                        <span class="suggestion-icon">💡</span>
                        <strong>Related questions to consider:</strong>
                    </div>
                    <ul class="suggestion-list">
                        ${suggestions.map(s => `
                            <li>
                                <a href="#" class="suggestion-link" data-question-id="${s.id}">
                                    ${s.text}
                                </a>
                            </li>
                        `).join('')}
                    </ul>
                `;

                // Insert after question header
                const header = questionCard.querySelector('.question-header');
                header.after(banner);

                // Add click handlers
                banner.querySelectorAll('.suggestion-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const targetQId = link.dataset.questionId;
                        const targetCard = document.querySelector(`[data-question-id="${targetQId}"]`);
                        if (targetCard) {
                            targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            targetCard.style.animation = 'highlight 2s';
                            setTimeout(() => targetCard.style.animation = '', 2000);
                        }
                    });
                });
            }

            applyTechniqueFilters() {
                // Get active filter value
                const maturityFilter = document.querySelector('.filter-btn[data-filter-type="maturity"].active')?.dataset.filterValue || 'all';

                // Apply filters to all technique cards
                const techniqueCards = document.querySelectorAll('.technique-card[data-maturity]');
                techniqueCards.forEach(card => {
                    const cardMaturity = card.dataset.maturity;

                    const maturityMatch = maturityFilter === 'all' || cardMaturity === maturityFilter;

                    // Show/hide based on filter match
                    if (maturityMatch) {
                        card.removeAttribute('data-filtered');
                    } else {
                        card.setAttribute('data-filtered', 'true');
                    }
                });
            }

            renderAllQuestions() {
                Object.keys(discoveryQuestions).forEach(phaseKey => {
                    const phase = discoveryQuestions[phaseKey];
                    const phaseNum = parseInt(phaseKey.replace('phase', ''));
                    const panel = document.querySelector(`.tab-panel[data-phase="${phaseNum}"]`);

                    if (panel && panel.dataset.phase !== 'summary') {
                        // Check if any questions in this phase are answered
                        const phaseQuestions = phase.questions.map(q => this.state.questions[q.id]);
                        const hasAnsweredQuestions = phaseQuestions.some(q => q && q.status === 'answered');

                        // Add empty state banner if no questions answered
                        const emptyStateBanner = !hasAnsweredQuestions ? `
                            <div class="empty-state-banner">
                                <div class="empty-state-icon">📝</div>
                                <div class="empty-state-content">
                                    <h4>No questions answered yet</h4>
                                    <p>Start filling out discovery findings below to build your assessment.</p>
                                </div>
                            </div>
                        ` : '';

                        const questionsHTML = phase.questions.map((q, index) => this.createQuestionCardHTML(q, phaseNum, index + 1)).join('');

                        // Add phase navigation buttons
                        const navigationHTML = `
                            <div class="phase-navigation">
                                <button
                                    class="btn-nav btn-prev"
                                    data-target-phase="${phaseNum - 1}"
                                    ${phaseNum === 1 ? 'disabled' : ''}
                                >
                                    ← Previous Phase
                                </button>
                                <button
                                    class="btn-nav btn-next"
                                    data-target-phase="${phaseNum === 5 ? 'summary' : phaseNum + 1}"
                                >
                                    ${phaseNum === 5 ? 'View Summary →' : 'Next Phase →'}
                                </button>
                            </div>
                        `;

                        panel.innerHTML = emptyStateBanner + questionsHTML + navigationHTML;
                    }
                });
            }

            createQuestionCardHTML(question, phase, questionIndex) {
                const exampleText = this.getQuestionExample(question.id);

                return `
                    <div class="question-card" data-question-id="${question.id}" data-phase="${phase}" data-status="open">
                        <div class="question-header">
                            <span class="question-number">Q${questionIndex}</span>
                            <h3 class="question-text">${question.text}</h3>
                            <span class="status-badge open">○ Open</span>
                        </div>

                        <div class="question-body">
                            <div class="form-group">
                                <label>
                                    Findings
                                    <span class="info-tooltip">
                                        <span class="info-icon">ⓘ</span>
                                        <span class="tooltip-content">${exampleText}</span>
                                    </span>
                                </label>
                                <textarea
                                    class="findings-input"
                                    data-field="findings"
                                    rows="6"
                                    placeholder="What did you discover about this question?"
                                ></textarea>
                                <div class="char-counter">
                                    <span class="char-count">0</span> characters
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Discovery Methods Used</label>
                                <div class="methods-selector">
                                    ${discoveryMethods.map(m => `
                                        <button type="button" class="method-tag" data-method="${m.id}">
                                            ${m.icon} ${m.label}
                                        </button>
                                    `).join('')}
                                </div>
                                <div class="method-presets">
                                    <span class="preset-label">Quick select:</span>
                                    <button type="button" class="preset-btn" data-preset="interview,document_review" title="Interview + Document Review">
                                        Standard Interview
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="workshop,observation" title="Workshop + Observation">
                                        Workshop Session
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="survey,data_analysis" title="Survey + Data Analysis">
                                        Data Research
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="observation,interview" title="Observation + Interview">
                                        Field Study
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Additional Notes</label>
                                <textarea
                                    class="notes-input"
                                    data-field="notes"
                                    rows="3"
                                    placeholder="Any additional context or observations..."
                                ></textarea>
                                <div class="char-counter">
                                    <span class="char-count">0</span> characters
                                </div>
                            </div>

                            <div class="question-footer">
                                <span class="last-updated"></span>
                                <button type="button" class="btn-mark-complete">Mark as Answered</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            getQuestionExample(questionId) {
                const examples = {
                    'q1': '<strong>Example:</strong> "To solve customer payment friction and increase conversion by 15%"',
                    'q2': '<strong>Example:</strong> "B2B SaaS companies with 50-500 employees struggling with manual invoice processing"',
                    'q3': '<strong>Example:</strong> "Reduce invoice processing time from 2 hours to 15 minutes per invoice"',
                    'q4': '<strong>Example:</strong> "Customers currently use Excel spreadsheets, taking 2+ hours per invoice with frequent errors"',
                    'q5': '<strong>Example:</strong> "Interviewed 8 customers, observed 5 live invoice processing sessions, analyzed 200+ support tickets"',
                    'q6': '<strong>Example:</strong> "Automation saves 90+ minutes per invoice, 40% reduction in errors, ROI achieved in 3 months"',
                    'q7': '<strong>Example:</strong> "Finance managers struggle most with manual data entry and error correction"',
                    'q8': '<strong>Example:</strong> "All 8 interviewed customers confirmed willingness to pay $199/month for this solution"',
                    'q9': '<strong>Example:</strong> "Needs OCR technology, integration with QuickBooks/Xero, requires 2 engineers for 3 months"',
                    'q10': '<strong>Example:</strong> "Product Manager owns success, works with 2 engineers and 1 designer"',
                    'q11': '<strong>Example:</strong> "PM makes feature decisions, needs approval for pricing changes over $50/month"',
                    'q12': '<strong>Example:</strong> "PM, Lead Engineer, Designer meet weekly for discovery; stakeholder review monthly"',
                    'q13': '<strong>Example:</strong> "Team works well together, designer new to discovery process, needs coaching"',
                    'q14': '<strong>Example:</strong> "Weekly 2-hour discovery sessions, PM does 3 customer interviews per week"',
                    'q15': '<strong>Example:</strong> "Must integrate with Salesforce (executive mandate), GDPR compliance required for EU customers"',
                    'q16': '<strong>Example:</strong> "Assumed customers want mobile app - testing showed 90% prefer desktop for invoice processing"',
                    'q17': '<strong>Example:</strong> "Assumed OCR needs 99% accuracy - customers accept 95% if faster and cheaper"',
                    'q18': '<strong>Example:</strong> "Testing showed complex UI confused users - simplified version increased task completion by 60%"',
                    'q19': '<strong>Example:</strong> "Believed customers wanted full automation - interviews revealed they want human oversight"',
                    'q20': '<strong>Example:</strong> "Thought pricing should be per-user - customers strongly prefer per-invoice pricing"',
                    'q21': '<strong>Example:</strong> "Built custom OCR engine - could have used existing API for 10x lower cost and faster delivery"'
                };
                return examples[questionId] || '<strong>Example:</strong> "Describe what you discovered from customer research, interviews, or data analysis"';
            }

            getState() {
                return this.state;
            }

            updateMetadata(key, value) {
                if (this.state.metadata.hasOwnProperty(key) || key === 'clientName' || key === 'engagementDate') {
                    this.state.metadata[key] = value;
                    this.state.metadata.lastModified = new Date().toISOString();
                }
            }

            setState(newState) {
                this.state = newState;
                this.renderAllQuestions();

                // Restore form values
                Object.entries(newState.questions).forEach(([qId, q]) => {
                    const card = document.querySelector(`[data-question-id="${qId}"]`);
                    if (!card) return;

                    const findingsInput = card.querySelector('.findings-input');
                    const notesInput = card.querySelector('.notes-input');

                    if (findingsInput) {
                        findingsInput.value = q.findings || '';
                        this.updateCharCounter(findingsInput);
                    }
                    if (notesInput) {
                        notesInput.value = q.notes || '';
                        this.updateCharCounter(notesInput);
                    }

                    // Restore method selections
                    q.discoveryMethods.forEach(method => {
                        const methodTag = card.querySelector(`[data-method="${method}"]`);
                        if (methodTag) methodTag.classList.add('active');
                    });

                    // Update status
                    this.updateQuestionCardStatus(qId, q.status);
                });

                // Restore metadata
                if (newState.metadata) {
                    document.getElementById('clientName').value = newState.metadata.clientName || '';
                    document.getElementById('engagementDate').value = newState.metadata.engagementDate || '';
                }

                this.updateProgress();
            }
        }

        // Data Manager Class
        class DataManager {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportToJSON();
                });

                document.getElementById('compareBtn').addEventListener('click', () => {
                    document.getElementById('compareInput').click();
                });

                document.getElementById('compareInput').addEventListener('change', (e) => {
                    this.compareAssessments(e.target.files);
                });

                document.getElementById('importBtn').addEventListener('click', (e) => {
                    console.log('Import button clicked');
                    const fileInput = document.getElementById('importInput');
                    if (!fileInput) {
                        console.error('File input element not found!');
                        return;
                    }
                    console.log('Triggering file input click...');
                    try {
                        fileInput.click();
                        console.log('File input click triggered');
                    } catch (error) {
                        console.error('Error triggering file input:', error);
                    }
                });

                document.getElementById('importInput').addEventListener('change', (e) => {
                    console.log('File selected:', e.target.files[0]?.name);
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const fileName = file.name.toLowerCase();
                        if (fileName.endsWith('.md')) {
                            this.importFromMarkdown(file);
                        } else {
                            this.importFromJSON(file);
                        }
                    } else {
                        console.error('No file selected');
                    }
                });

                document.getElementById('newEngagement').addEventListener('click', () => {
                    this.newEngagement();
                });
            }

            exportToJSON() {
                const state = this.stateManager.getState();
                const coverage = this.stateManager.calculateCoverage();

                // Generate technique recommendations
                const techniqueRecommender = new TechniqueRecommender();
                const recommendations = techniqueRecommender.recommendTechniques(state);

                // Extract findings
                const findings = Object.values(state.questions)
                    .filter(q => q.status === 'answered' && q.findings.trim())
                    .map(q => ({
                        questionId: q.questionId,
                        phase: q.phase,
                        question: q.text,
                        findings: q.findings,
                        notes: q.notes,
                        discoveryMethods: q.discoveryMethods,
                        lastUpdated: q.lastUpdated
                    }));

                // Identify gaps
                const gaps = Object.values(state.questions)
                    .filter(q => q.status === 'open' || !q.findings.trim())
                    .map(q => ({
                        questionId: q.questionId,
                        phase: q.phase,
                        question: q.text
                    }));

                // Analyze methods used
                const methodsUsed = {};
                discoveryMethods.forEach(m => {
                    methodsUsed[m.id] = {
                        label: m.label,
                        icon: m.icon,
                        count: 0
                    };
                });

                Object.values(state.questions).forEach(q => {
                    q.discoveryMethods.forEach(method => {
                        if (methodsUsed[method]) {
                            methodsUsed[method].count++;
                        }
                    });
                });

                // Phase-by-phase insights
                const phaseInsights = {};
                for (let phase = 1; phase <= 5; phase++) {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phase);
                    const answered = phaseQuestions.filter(q => q.status === 'answered');

                    phaseInsights[`phase${phase}`] = {
                        name: discoveryQuestions[`phase${phase}`].name,
                        total: phaseQuestions.length,
                        answered: answered.length,
                        percentage: phaseQuestions.length > 0 ? (answered.length / phaseQuestions.length) * 100 : 0
                    };
                }

                // Build enhanced export data (v2.0)
                const exportData = {
                    version: "2.0",
                    exportDate: new Date().toISOString(),
                    metadata: state.metadata,
                    questions: Object.values(state.questions),
                    analysis: {
                        coverage: {
                            totalQuestions: coverage.totalCount,
                            answeredQuestions: coverage.answeredCount,
                            completionPercentage: coverage.overall
                        },
                        findings: findings,
                        gaps: gaps,
                        discoveryMethods: methodsUsed,
                        phaseInsights: phaseInsights,
                        recommendedTechniques: {
                            discovery: (recommendations.discovery || []).map(rec => ({
                                name: rec.technique.name,
                                category: rec.technique.category,
                                description: rec.technique.description,
                                whenToUse: rec.technique.when_to_use,
                                timeCommitment: rec.technique.time_commitment,
                                resourcesNeeded: rec.technique.resources_needed,
                                teamMaturity: rec.technique.team_maturity,
                                outcomes: rec.technique.outcomes,
                                matchScore: rec.score,
                                matchReasons: rec.matchReasons,
                                svpgSource: rec.technique.svpg_source
                            })),
                            coaching: (recommendations.coaching || []).map(rec => ({
                                name: rec.technique.name,
                                category: rec.technique.category,
                                description: rec.technique.description,
                                whenToUse: rec.technique.when_to_use,
                                timeCommitment: rec.technique.time_commitment,
                                resourcesNeeded: rec.technique.resources_needed,
                                teamMaturity: rec.technique.team_maturity,
                                outcomes: rec.technique.outcomes,
                                matchScore: rec.score,
                                matchReasons: rec.matchReasons,
                                svpgSource: rec.technique.svpg_source
                            }))
                        }
                    }
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                const clientName = state.metadata.clientName || 'Unknown';
                const sanitized = clientName.replace(/[^a-z0-9]/gi, '-').substring(0, 50);
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `Discovery-v2-${sanitized}-${dateStr}.json`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                this.showNotification('Enhanced discovery data (v2.0) exported successfully', 'success');
            }

            importFromJSON(file) {
                if (!file) {
                    console.error('No file provided to importFromJSON');
                    return;
                }

                console.log('Starting import of file:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        console.log('File read successfully, parsing JSON...');
                        const importedData = JSON.parse(e.target.result);
                        console.log('JSON parsed successfully:', importedData);

                        // Validate version (support v1.0 and v2.0)
                        const version = importedData.version || "1.0";
                        console.log('File version:', version);
                        if (version !== "1.0" && version !== "2.0") {
                            throw new Error(`Unsupported file version: ${version}`);
                        }

                        // Reconstruct state
                        const newState = {
                            metadata: importedData.metadata || {},
                            questions: {}
                        };

                        console.log('Converting questions array to object...');
                        importedData.questions.forEach(q => {
                            newState.questions[q.questionId] = q;
                        });
                        console.log('New state constructed:', newState);

                        console.log('Calling setState...');
                        this.stateManager.setState(newState);
                        console.log('setState completed');

                        // Show appropriate notification based on version
                        const versionInfo = version === "2.0" ? " (v2.0 with analysis)" : "";
                        this.showNotification(`Discovery data${versionInfo} imported successfully`, 'success');

                        // If v2.0, log analysis data (optional - can be used later)
                        if (version === "2.0" && importedData.analysis) {
                            console.log('Imported analysis data:', importedData.analysis);
                            console.log('Recommended techniques:', importedData.analysis.recommendedTechniques);
                            // Analysis is available but we regenerate it on demand via Summary tab
                        }

                    } catch (error) {
                        console.error('Import error:', error);
                        this.showNotification('Error importing file: ' + error.message, 'error');
                    }
                };

                reader.onerror = () => {
                    this.showNotification('Error reading file', 'error');
                };

                reader.readAsText(file);
                // Reset file input
                document.getElementById('importInput').value = '';
            }

            importFromMarkdown(file) {
                if (!file) {
                    console.error('No file provided to importFromMarkdown');
                    return;
                }

                console.log('Starting markdown import of file:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        console.log('Markdown file read successfully, parsing...');
                        const markdown = e.target.result;
                        const parsedData = this.parseMarkdownToState(markdown);
                        console.log('Markdown parsed successfully:', parsedData);

                        console.log('Calling setState...');
                        this.stateManager.setState(parsedData);
                        console.log('setState completed');

                        this.showNotification('Markdown imported successfully', 'success');

                    } catch (error) {
                        console.error('Markdown import error:', error);
                        this.showNotification('Error importing markdown: ' + error.message, 'error');
                    }
                };

                reader.onerror = () => {
                    this.showNotification('Error reading markdown file', 'error');
                };

                reader.readAsText(file);
                // Reset file input
                document.getElementById('importInput').value = '';
            }

            parseMarkdownToState(markdown) {
                // Initialize state from current state manager structure
                const newState = this.stateManager.initializeState();
                const now = new Date().toISOString();

                // Question number to ID mapping
                const questionMap = {
                    1: 'q1', 2: 'q2', 3: 'q3', 4: 'q4', 5: 'q5', 6: 'q6', 7: 'q7', 8: 'q8',
                    9: 'q9', 10: 'q10', 11: 'q11', 12: 'q12', 13: 'q13', 14: 'q14', 15: 'q15',
                    16: 'q16', 17: 'q17', 18: 'q18', 19: 'q19', 20: 'q20', 21: 'q21',
                    22: 'q22', 23: 'q23', 24: 'q24', 25: 'q25', 26: 'q26', 27: 'q27',
                    28: 'q28', 29: 'q29', 30: 'q30', 31: 'q31', 32: 'q32', 33: 'q33',
                    34: 'q34', 35: 'q35', 36: 'q36'
                };

                // Parse metadata from header
                const dateMatch = markdown.match(/\*\*Date\*\*:\s*(.+)/i);
                const projectMatch = markdown.match(/\*\*Project\*\*:\s*(.+)/i);
                const participantsMatch = markdown.match(/\*\*Participants?\*\*:\s*(.+)/i);

                if (dateMatch) {
                    // Try to parse date into YYYY-MM-DD format
                    const dateStr = dateMatch[1].trim();
                    const parsedDate = new Date(dateStr);
                    if (!isNaN(parsedDate.getTime())) {
                        newState.metadata.engagementDate = parsedDate.toISOString().split('T')[0];
                    } else {
                        newState.metadata.engagementDate = dateStr;
                    }
                }

                if (projectMatch) {
                    newState.metadata.clientName = projectMatch[1].trim();
                }

                newState.metadata.lastModified = now;

                // Parse question sections
                // Match patterns like: ✅ **Q1: or ⚠️ **Q3: or ❌ **Q6:
                // Also handle variations: check mark, warning, x mark emojis
                const questionPattern = /([✅⚠️❌✓⚡❗✔️☑️☐☒✘✗])\s*\*\*Q(\d+)[:\s]/gi;
                const lines = markdown.split('\n');

                let currentQuestionNum = null;
                let currentStatus = null;
                let currentFindings = [];

                const saveCurrentQuestion = () => {
                    if (currentQuestionNum !== null && questionMap[currentQuestionNum]) {
                        const qId = questionMap[currentQuestionNum];
                        if (newState.questions[qId]) {
                            const findingsText = currentFindings.join('\n').trim();
                            newState.questions[qId].findings = findingsText;
                            newState.questions[qId].status = currentStatus;
                            newState.questions[qId].lastUpdated = now;

                            // Auto-detect discovery methods from findings text
                            newState.questions[qId].discoveryMethods = this.detectDiscoveryMethods(findingsText);
                        }
                    }
                };

                for (const line of lines) {
                    // Check if this line starts a new question
                    // Use a more permissive regex that captures the prefix before **Q
                    const questionMatch = line.match(/^(.+?)\s*\*\*Q(\d+)[:\s]/i);

                    if (questionMatch) {
                        // Save previous question if exists
                        saveCurrentQuestion();

                        // Start new question
                        const statusPrefix = questionMatch[1];
                        currentQuestionNum = parseInt(questionMatch[2]);
                        currentFindings = [];

                        // Determine status from prefix using regex tests (handles emoji variations)
                        if (/[✅✓✔☑]/.test(statusPrefix)) {
                            currentStatus = 'answered';
                        } else if (/[⚠⚡❗🟡🟠]/.test(statusPrefix)) {
                            currentStatus = 'answered'; // Partial still has findings
                        } else if (/[❌✘✗☐☒🔴]/.test(statusPrefix)) {
                            currentStatus = 'open';
                        } else {
                            // Default to open if we can't determine status
                            currentStatus = 'open';
                        }
                    } else if (currentQuestionNum !== null) {
                        // Check if this is a finding bullet point
                        const bulletMatch = line.match(/^\s*[-*•]\s*(.+)/);
                        if (bulletMatch) {
                            const finding = bulletMatch[1].trim();
                            if (finding) {
                                currentFindings.push(finding);
                            }
                        }
                    }
                }

                // Save last question
                saveCurrentQuestion();

                return newState;
            }

            detectDiscoveryMethods(text) {
                const methods = [];
                const textLower = text.toLowerCase();

                if (/\binterview(s|ed|ing)?\b/.test(textLower)) {
                    methods.push('interview');
                }
                if (/\bworkshop(s)?\b/.test(textLower)) {
                    methods.push('workshop');
                }
                if (/\bobserv(e|ed|ation|ing)\b/.test(textLower)) {
                    methods.push('observation');
                }
                if (/\bdocument(s|ation)?\b|\bdocs?\b/.test(textLower)) {
                    methods.push('document_review');
                }
                if (/\bsurvey(s|ed)?\b/.test(textLower)) {
                    methods.push('survey');
                }
                if (/\b(data|metric|analytics|analysis)\b/.test(textLower)) {
                    methods.push('data_analysis');
                }

                return methods;
            }

            async compareAssessments(files) {
                if (!files || files.length === 0) return;

                try {
                    const assessments = [];

                    // Read all files
                    for (let file of files) {
                        const data = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                try {
                                    const parsed = JSON.parse(e.target.result);
                                    resolve(parsed);
                                } catch (error) {
                                    reject(error);
                                }
                            };
                            reader.onerror = reject;
                            reader.readAsText(file);
                        });
                        assessments.push(data);
                    }

                    // Generate comparison view
                    this.showComparisonView(assessments);
                    this.showNotification(`Comparing ${assessments.length} assessments`, 'success');

                } catch (error) {
                    this.showNotification('Error comparing assessments: ' + error.message, 'error');
                }

                // Reset file input
                document.getElementById('compareInput').value = '';
            }

            showComparisonView(assessments) {
                // Switch to summary tab
                this.stateManager.tabNavigator.switchTab('summary');

                // Create comparison table
                const summaryContainer = document.getElementById('summaryContent');

                const comparisonHTML = `
                    <div class="comparison-view">
                        <h3>Assessment Comparison</h3>
                        <div class="comparison-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Metric</th>
                                        ${assessments.map((a, i) => `<th>${a.metadata?.clientName || `Assessment ${i + 1}`}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Date</strong></td>
                                        ${assessments.map(a => `<td>${a.metadata?.engagementDate || 'N/A'}</td>`).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Questions Answered</strong></td>
                                        ${assessments.map(a => {
                                            const answered = Object.values(a.questions || {}).filter(q => q.status === 'answered').length;
                                            const total = Object.keys(a.questions || {}).length;
                                            return `<td>${answered}/${total}</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Completion %</strong></td>
                                        ${assessments.map(a => {
                                            const answered = Object.values(a.questions || {}).filter(q => q.status === 'answered').length;
                                            const total = Object.keys(a.questions || {}).length;
                                            const percent = total > 0 ? ((answered / total) * 100).toFixed(1) : 0;
                                            return `<td><strong>${percent}%</strong></td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Discovery Methods Used</strong></td>
                                        ${assessments.map(a => {
                                            const methods = new Set();
                                            Object.values(a.questions || {}).forEach(q => {
                                                q.discoveryMethods?.forEach(m => methods.add(m));
                                            });
                                            return `<td>${methods.size} different methods</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 1 (Foundation)</strong></td>
                                        ${assessments.map(a => {
                                            const phase1Qs = Object.entries(a.questions || {}).filter(([id]) => ['q1', 'q2', 'q3'].includes(id));
                                            const answered = phase1Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/3</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 2 (Success)</strong></td>
                                        ${assessments.map(a => {
                                            const phase2Qs = Object.entries(a.questions || {}).filter(([id]) => ['q4', 'q5', 'q6', 'q7', 'q8'].includes(id));
                                            const answered = phase2Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/5</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 3 (Structure)</strong></td>
                                        ${assessments.map(a => {
                                            const phase3Qs = Object.entries(a.questions || {}).filter(([id]) => ['q9', 'q10', 'q11', 'q12'].includes(id));
                                            const answered = phase3Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/4</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 4 (Team Dynamics)</strong></td>
                                        ${assessments.map(a => {
                                            const phase4Qs = Object.entries(a.questions || {}).filter(([id]) => ['q13', 'q14', 'q15'].includes(id));
                                            const answered = phase4Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/3</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 5 (Assumptions)</strong></td>
                                        ${assessments.map(a => {
                                            const phase5Qs = Object.entries(a.questions || {}).filter(([id]) => ['q16', 'q17', 'q18', 'q19', 'q20', 'q21'].includes(id));
                                            const answered = phase5Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/6</td>`;
                                        }).join('')}
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <button id="closeComparison" class="btn-secondary" style="margin-top: 20px;">Close Comparison</button>
                    </div>
                `;

                summaryContainer.innerHTML = comparisonHTML;

                // Add close button handler
                document.getElementById('closeComparison').addEventListener('click', () => {
                    this.summaryGenerator.generateSummary();
                });
            }

            newEngagement() {
                const hasData = Object.values(this.stateManager.state.questions).some(q =>
                    q.findings || q.notes || q.discoveryMethods.length > 0
                );

                if (hasData) {
                    const confirmed = confirm(
                        'You have unsaved changes. Do you want to export before starting a new engagement?'
                    );
                    if (confirmed) {
                        this.exportToJSON();
                        setTimeout(() => this.resetState(), 500);
                    } else {
                        this.resetState();
                    }
                } else {
                    this.resetState();
                }
            }

            resetState() {
                this.stateManager.setState(this.stateManager.initializeState());
                document.querySelector('.tab-btn').click();
                this.showNotification('New engagement started', 'info');
            }

            showNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;

                const container = document.getElementById('notifications');
                container.appendChild(notification);

                setTimeout(() => notification.classList.add('show'), 10);

                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }

        // ============================================================================
        // VERSION MANAGER CLASS - Auto-versioning with localStorage
        // ============================================================================
        class VersionManager {
            constructor(stateManager, dataManager) {
                this.stateManager = stateManager;
                this.dataManager = dataManager;
                this.STORAGE_KEY = 'lea_clients';
                this.MAX_STORAGE_MB = 5;
                this.currentClientName = null;
                this.lastSavedStateHash = null;
                this.setupEventListeners();
                this.renderVersionHistory();
            }

            setupEventListeners() {
                document.getElementById('saveVersionBtn').addEventListener('click', () => {
                    this.promptSaveVersion();
                });

                document.getElementById('saveFirstVersionBtn').addEventListener('click', () => {
                    this.promptSaveVersion();
                });

                document.getElementById('clientSelect').addEventListener('change', (e) => {
                    this.onClientSelect(e.target.value);
                });

                document.getElementById('deleteClientBtn').addEventListener('click', () => {
                    this.confirmDeleteClient();
                });
            }

            // ==================== Core Storage Functions ====================

            getStorageData() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEY);
                    return data ? JSON.parse(data) : {};
                } catch (error) {
                    console.error('Error reading localStorage:', error);
                    return {};
                }
            }

            setStorageData(data) {
                try {
                    const jsonString = JSON.stringify(data);
                    localStorage.setItem(this.STORAGE_KEY, jsonString);
                    return true;
                } catch (error) {
                    if (error.name === 'QuotaExceededError') {
                        this.dataManager.showNotification('Storage limit reached. Please delete some versions.', 'error');
                    } else {
                        console.error('Error writing to localStorage:', error);
                        this.dataManager.showNotification('Error saving data: ' + error.message, 'error');
                    }
                    return false;
                }
            }

            // ==================== Client Name Sanitization ====================

            sanitizeClientName(name) {
                if (!name || typeof name !== 'string') return '';
                // Remove special chars that could break localStorage keys
                // Allow alphanumeric, spaces, hyphens, underscores
                return name.trim()
                    .replace(/[^a-zA-Z0-9\s\-_]/g, '')
                    .substring(0, 100);
            }

            // ==================== Core Version Functions ====================

            saveVersion(clientName) {
                const sanitizedName = this.sanitizeClientName(clientName);
                if (!sanitizedName) {
                    this.dataManager.showNotification('Please enter a valid client name', 'error');
                    return false;
                }

                const state = this.stateManager.getState();
                const coverage = this.stateManager.calculateCoverage();
                const storageData = this.getStorageData();

                // Initialize client if doesn't exist
                if (!storageData[sanitizedName]) {
                    storageData[sanitizedName] = {
                        versions: [],
                        currentVersion: 0
                    };
                }

                const client = storageData[sanitizedName];
                const newVersionNumber = client.versions.length + 1;

                // Create version snapshot
                const versionData = {
                    version: newVersionNumber,
                    timestamp: new Date().toISOString(),
                    data: JSON.parse(JSON.stringify(state)), // Deep clone
                    summary: {
                        answeredCount: coverage.answeredCount,
                        totalCount: coverage.totalCount,
                        percentage: coverage.overall
                    }
                };

                client.versions.push(versionData);
                client.currentVersion = newVersionNumber;

                if (this.setStorageData(storageData)) {
                    this.currentClientName = sanitizedName;
                    this.lastSavedStateHash = this.hashState(state);

                    // Update client name in metadata if not set
                    if (!state.metadata.clientName) {
                        document.getElementById('clientName').value = sanitizedName;
                        this.stateManager.updateMetadata('clientName', sanitizedName);
                    }

                    this.dataManager.showNotification(`Version ${newVersionNumber} saved for ${sanitizedName}`, 'success');
                    this.renderVersionHistory();
                    this.updateStorageInfo();
                    return true;
                }
                return false;
            }

            loadVersion(clientName, versionNumber) {
                const storageData = this.getStorageData();
                const client = storageData[clientName];

                if (!client) {
                    this.dataManager.showNotification('Client not found', 'error');
                    return false;
                }

                const version = client.versions.find(v => v.version === versionNumber);
                if (!version) {
                    this.dataManager.showNotification('Version not found', 'error');
                    return false;
                }

                // Restore state
                this.stateManager.setState(version.data);
                this.currentClientName = clientName;
                client.currentVersion = versionNumber;
                this.setStorageData(storageData);
                this.lastSavedStateHash = this.hashState(version.data);

                this.dataManager.showNotification(`Loaded ${clientName} - Version ${versionNumber}`, 'success');
                this.renderVersionHistory();

                // Switch to Phase 1 tab after loading
                if (window.tabNavigator) {
                    window.tabNavigator.switchTab('1');
                }

                return true;
            }

            deleteVersion(clientName, versionNumber) {
                const storageData = this.getStorageData();
                const client = storageData[clientName];

                if (!client) {
                    this.dataManager.showNotification('Client not found', 'error');
                    return false;
                }

                const versionIndex = client.versions.findIndex(v => v.version === versionNumber);
                if (versionIndex === -1) {
                    this.dataManager.showNotification('Version not found', 'error');
                    return false;
                }

                // Remove version
                client.versions.splice(versionIndex, 1);

                // If no versions left, remove client entirely
                if (client.versions.length === 0) {
                    delete storageData[clientName];
                    if (this.currentClientName === clientName) {
                        this.currentClientName = null;
                    }
                } else {
                    // Renumber remaining versions
                    client.versions.forEach((v, i) => {
                        v.version = i + 1;
                    });
                    client.currentVersion = client.versions.length;
                }

                if (this.setStorageData(storageData)) {
                    this.dataManager.showNotification(`Version ${versionNumber} deleted`, 'success');
                    this.renderVersionHistory();
                    this.updateStorageInfo();
                    return true;
                }
                return false;
            }

            deleteClient(clientName) {
                const storageData = this.getStorageData();

                if (!storageData[clientName]) {
                    this.dataManager.showNotification('Client not found', 'error');
                    return false;
                }

                delete storageData[clientName];

                if (this.currentClientName === clientName) {
                    this.currentClientName = null;
                }

                if (this.setStorageData(storageData)) {
                    this.dataManager.showNotification(`Client "${clientName}" and all versions deleted`, 'success');
                    this.renderVersionHistory();
                    this.updateStorageInfo();
                    return true;
                }
                return false;
            }

            listClients() {
                const storageData = this.getStorageData();
                return Object.entries(storageData).map(([name, client]) => ({
                    name: name,
                    versionCount: client.versions.length,
                    currentVersion: client.currentVersion,
                    lastModified: client.versions.length > 0
                        ? client.versions[client.versions.length - 1].timestamp
                        : null
                }));
            }

            // ==================== Unsaved Changes Detection ====================

            hashState(state) {
                // Simple hash of state for comparison
                return JSON.stringify({
                    metadata: state.metadata,
                    questions: Object.values(state.questions).map(q => ({
                        id: q.questionId,
                        findings: q.findings,
                        notes: q.notes,
                        status: q.status,
                        methods: q.discoveryMethods
                    }))
                });
            }

            hasUnsavedChanges() {
                if (!this.lastSavedStateHash) return true;
                const currentHash = this.hashState(this.stateManager.getState());
                return currentHash !== this.lastSavedStateHash;
            }

            // ==================== Storage Info ====================

            getStorageUsage() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEY) || '';
                    const bytes = new Blob([data]).size;
                    const mb = bytes / (1024 * 1024);
                    return {
                        bytes: bytes,
                        mb: mb,
                        percentage: (mb / this.MAX_STORAGE_MB) * 100
                    };
                } catch (error) {
                    return { bytes: 0, mb: 0, percentage: 0 };
                }
            }

            updateStorageInfo() {
                const usage = this.getStorageUsage();
                const storageInfo = document.getElementById('storageInfo');
                const storageUsed = document.getElementById('storageUsed');
                const storageBarFill = document.getElementById('storageBarFill');

                if (usage.mb > 0.01) {
                    storageInfo.style.display = 'block';
                    storageUsed.textContent = usage.mb.toFixed(2) + ' MB';
                    storageBarFill.style.width = Math.min(usage.percentage, 100) + '%';

                    // Update colors based on usage
                    storageBarFill.classList.remove('warning', 'danger');
                    storageInfo.classList.remove('warning');

                    if (usage.percentage >= 80) {
                        storageBarFill.classList.add('danger');
                        storageInfo.classList.add('warning');
                    } else if (usage.percentage >= 50) {
                        storageBarFill.classList.add('warning');
                    }
                } else {
                    storageInfo.style.display = 'none';
                }
            }

            // ==================== UI Rendering ====================

            renderVersionHistory() {
                const clients = this.listClients();
                const clientSelect = document.getElementById('clientSelect');
                const container = document.getElementById('versionListContainer');
                const deleteClientBtn = document.getElementById('deleteClientBtn');

                // Update client dropdown
                clientSelect.innerHTML = '<option value="">-- Select a client --</option>';
                clients.forEach(client => {
                    const option = document.createElement('option');
                    option.value = client.name;
                    option.textContent = `${client.name} (${client.versionCount} version${client.versionCount !== 1 ? 's' : ''})`;
                    if (client.name === this.currentClientName) {
                        option.selected = true;
                    }
                    clientSelect.appendChild(option);
                });

                // Show/hide delete client button
                deleteClientBtn.style.display = this.currentClientName ? 'inline-block' : 'none';

                // Render version list or empty state
                if (!this.currentClientName || clients.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📁</div>
                            <h3>No Saved Versions</h3>
                            <p>Save your first version to start tracking your discovery progress.</p>
                            <button id="saveFirstVersionBtn" class="btn-primary">Save First Version</button>
                        </div>
                    `;
                    document.getElementById('saveFirstVersionBtn').addEventListener('click', () => {
                        this.promptSaveVersion();
                    });
                    return;
                }

                const storageData = this.getStorageData();
                const client = storageData[this.currentClientName];

                if (!client || client.versions.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📄</div>
                            <h3>No Versions for ${this.currentClientName}</h3>
                            <p>Save a version to track your progress.</p>
                        </div>
                    `;
                    return;
                }

                // Render version list (newest first)
                const versionsHtml = client.versions
                    .slice()
                    .reverse()
                    .map(v => {
                        const date = new Date(v.timestamp);
                        const formattedDate = date.toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        const isCurrent = v.version === client.currentVersion;
                        const progress = v.summary
                            ? `${v.summary.answeredCount}/${v.summary.totalCount} (${v.summary.percentage}%)`
                            : 'N/A';

                        return `
                            <div class="version-item ${isCurrent ? 'current' : ''}" data-version="${v.version}">
                                <div class="version-info">
                                    <span class="version-number">Version ${v.version}${isCurrent ? ' (Current)' : ''}</span>
                                    <span class="version-timestamp">${formattedDate}</span>
                                    <span class="version-progress">Progress: ${progress}</span>
                                </div>
                                <div class="version-item-actions">
                                    <button class="btn-load-version" data-client="${this.currentClientName}" data-version="${v.version}">
                                        ${isCurrent ? 'Reload' : 'Load'}
                                    </button>
                                    <button class="btn-delete-version" data-client="${this.currentClientName}" data-version="${v.version}">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        `;
                    })
                    .join('');

                container.innerHTML = `<div class="version-list">${versionsHtml}</div>`;

                // Add event listeners for version actions
                container.querySelectorAll('.btn-load-version').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const clientName = btn.dataset.client;
                        const version = parseInt(btn.dataset.version, 10);
                        this.confirmLoadVersion(clientName, version);
                    });
                });

                container.querySelectorAll('.btn-delete-version').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const clientName = btn.dataset.client;
                        const version = parseInt(btn.dataset.version, 10);
                        this.confirmDeleteVersion(clientName, version);
                    });
                });

                this.updateStorageInfo();
            }

            onClientSelect(clientName) {
                this.currentClientName = clientName || null;
                this.renderVersionHistory();
            }

            // ==================== Modal Dialogs ====================

            promptSaveVersion() {
                const state = this.stateManager.getState();
                const currentClientName = state.metadata.clientName || this.currentClientName || '';

                if (currentClientName) {
                    // Auto-save to existing client
                    this.saveVersion(currentClientName);
                } else {
                    // Prompt for client name
                    this.showSaveModal();
                }
            }

            showSaveModal() {
                const state = this.stateManager.getState();
                const suggestedName = state.metadata.clientName || '';

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h3>Save Version</h3>
                        <p style="color: #666; margin-bottom: 15px;">Enter a client name to save this discovery session.</p>
                        <input type="text" id="saveClientNameInput" placeholder="Client Name" value="${suggestedName}">
                        <div class="modal-buttons">
                            <button class="btn-modal-cancel">Cancel</button>
                            <button class="btn-modal-save">Save</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                const input = modal.querySelector('#saveClientNameInput');
                input.focus();
                input.select();

                const closeModal = () => {
                    document.body.removeChild(modal);
                };

                modal.querySelector('.btn-modal-cancel').addEventListener('click', closeModal);
                modal.querySelector('.btn-modal-save').addEventListener('click', () => {
                    const name = input.value.trim();
                    if (name) {
                        closeModal();
                        this.saveVersion(name);
                    } else {
                        input.style.borderColor = '#f44336';
                    }
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        modal.querySelector('.btn-modal-save').click();
                    } else if (e.key === 'Escape') {
                        closeModal();
                    }
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
            }

            confirmLoadVersion(clientName, versionNumber) {
                if (this.hasUnsavedChanges()) {
                    this.showConfirmModal(
                        'Unsaved Changes',
                        'You have unsaved changes. Loading a different version will discard these changes. Do you want to continue?',
                        () => this.loadVersion(clientName, versionNumber)
                    );
                } else {
                    this.loadVersion(clientName, versionNumber);
                }
            }

            confirmDeleteVersion(clientName, versionNumber) {
                this.showConfirmModal(
                    'Delete Version',
                    `Are you sure you want to delete Version ${versionNumber}? This action cannot be undone.`,
                    () => this.deleteVersion(clientName, versionNumber)
                );
            }

            confirmDeleteClient() {
                if (!this.currentClientName) return;

                const storageData = this.getStorageData();
                const client = storageData[this.currentClientName];
                const versionCount = client ? client.versions.length : 0;

                this.showConfirmModal(
                    'Delete Client',
                    `Are you sure you want to delete "${this.currentClientName}" and all ${versionCount} version(s)? This action cannot be undone.`,
                    () => this.deleteClient(this.currentClientName)
                );
            }

            showConfirmModal(title, message, onConfirm) {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content confirm-dialog">
                        <h3>${title}</h3>
                        <p class="warning-text">${message}</p>
                        <div class="modal-buttons">
                            <button class="btn-modal-cancel">Cancel</button>
                            <button class="btn-modal-save" style="background: #f44336;">Delete</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                const closeModal = () => {
                    document.body.removeChild(modal);
                };

                modal.querySelector('.btn-modal-cancel').addEventListener('click', closeModal);
                modal.querySelector('.btn-modal-save').addEventListener('click', () => {
                    closeModal();
                    onConfirm();
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
            }
        }

        // ============================================================================
        // TECHNIQUE LIBRARY - 50 Comprehensive Techniques
        // Source: SVPG Masterclass December 2025 + SVPG Research
        // ============================================================================
        const svpgTechniqueLibrary = {
            "library_version": "1.0",
            "last_updated": "2025-12-25",
            "source": "SVPG Masterclass December 2025 + SVPG Research",
            "total_techniques": 51,

            "discovery_techniques": {

                "framing_and_planning": [
                    {
                        "id": "team_objective",
                        "name": "Team Objective",
                        "category": "Framing & Planning",
                        "description": "Frame work as outcomes and problems to solve rather than features to build. Answer: What problem? Who for? How measure success?",
                        "when_to_use": "At the start of any significant product work to align team on objectives and outcomes",
                        "time_commitment": "1-2 hours",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager"],
                        "outcomes": [
                            "Clear problem definition",
                            "Alignment on target market",
                            "Defined success metrics",
                            "Shift from output to outcome thinking"
                        ],
                        "matching_criteria": {
                            "keywords": ["unclear objectives", "feature factory", "no clear goal", "what are we solving", "misalignment"],
                            "discovery_patterns": ["team doesn't know why", "building features not outcomes", "no success metrics"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "pr_faq",
                        "name": "PR/FAQ (Working Backwards)",
                        "category": "Framing & Planning",
                        "description": "Write a fake press release describing customer outcomes and benefits. Forces thinking in terms of benefits over features.",
                        "when_to_use": "For significant new products or features where you need to work backwards from desired customer outcome",
                        "time_commitment": "3-5 hours for initial draft, iteration over 1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer"],
                        "outcomes": [
                            "Customer-centric product vision",
                            "Clear articulation of benefits",
                            "Alignment on customer value",
                            "FAQ addresses key concerns"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer outcome", "benefits", "value proposition", "work backwards"],
                            "discovery_patterns": ["unclear value", "feature-focused", "need customer perspective"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "opportunity_assessment",
                        "name": "Opportunity Assessment",
                        "category": "Framing & Planning",
                        "description": "Structured framework answering 4 questions: business objective, key results, customer problem, target market",
                        "when_to_use": "When evaluating whether an opportunity is worth pursuing, need to validate business viability",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager"],
                        "outcomes": [
                            "Clear business objective",
                            "Defined success metrics",
                            "Validated customer problem",
                            "Go/no-go decision framework"
                        ],
                        "matching_criteria": {
                            "keywords": ["business case", "opportunity", "should we build", "validate idea", "stakeholder alignment"],
                            "discovery_patterns": ["jumping to solutions", "unclear business value", "leadership asking for justification"],
                            "phase_indicators": [1, 2, 3]
                        },
                        "svpg_source": "SVPG Articles"
                    },
                    {
                        "id": "lean_canvas",
                        "name": "Lean Canvas / Product Canvas",
                        "category": "Framing & Planning",
                        "description": "Map hypotheses and assumptions across all aspects of product. Surface what needs to be tested.",
                        "when_to_use": "For all-new product efforts or true startups to map unknowns",
                        "time_commitment": "2-4 hours initial, ongoing refinement",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Tech Lead"],
                        "outcomes": [
                            "Identified assumptions",
                            "Clear hypotheses to test",
                            "Risk areas highlighted",
                            "Shared understanding of unknowns"
                        ],
                        "matching_criteria": {
                            "keywords": ["startup", "new product", "assumptions", "hypotheses", "unknowns"],
                            "discovery_patterns": ["many unknowns", "greenfield", "unvalidated assumptions"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "journey_map",
                        "name": "Journey Map",
                        "category": "Framing & Planning",
                        "description": "Customer-centric map of entire end-to-end experience. Visualize holistic experience, clarify ownership, uncover pain points.",
                        "when_to_use": "To understand complete customer experience, identify pain points, test new concepts",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "User Researcher"],
                        "outcomes": [
                            "Holistic view of experience",
                            "Identified pain points",
                            "Moments that matter highlighted",
                            "Clear ownership boundaries"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer journey", "end-to-end", "pain points", "experience", "touchpoints"],
                            "discovery_patterns": ["fragmented experience", "unclear user flow", "ownership gaps"],
                            "phase_indicators": [1, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "opportunity_solution_tree",
                        "name": "Opportunity Solution Tree",
                        "category": "Framing & Planning",
                        "description": "Before jumping to solutions, map various ways you might attack the problem. Consider alternatives.",
                        "when_to_use": "When you have a clear problem but need to explore solution space systematically",
                        "time_commitment": "1-2 days",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Engineer"],
                        "outcomes": [
                            "Multiple solution approaches identified",
                            "Exploration before commitment",
                            "Team alignment on options",
                            "Evidence-based solution selection"
                        ],
                        "matching_criteria": {
                            "keywords": ["solutions", "alternatives", "options", "explore", "compare approaches"],
                            "discovery_patterns": ["jumping to first solution", "narrow thinking", "need options"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "product_taxonomy_mapping",
                        "name": "Product Taxonomy Mapping",
                        "category": "Framing & Planning",
                        "description": "Workshop to visualize and map all product features across the portfolio to identify overlaps, gaps, and ownership boundaries.",
                        "when_to_use": "When there's confusion about feature ownership, suspected duplication across products, or need to rationalize the product portfolio",
                        "time_commitment": "Half-day workshop + 1-2 days follow-up analysis",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Managers from each product", "Architect or Tech Lead", "Whiteboard or Miro"],
                        "outcomes": [
                            "Visual map of all features across products",
                            "Identified overlapping capabilities",
                            "Clear ownership boundaries defined",
                            "Deprecation or consolidation candidates",
                            "Reduced user confusion from duplicate features"
                        ],
                        "matching_criteria": {
                            "keywords": ["taxonomy", "portfolio", "overlap", "duplication", "feature mapping", "product structure", "consolidation"],
                            "discovery_patterns": ["overlapping features", "unclear ownership", "duplicate functionality", "portfolio confusion"],
                            "phase_indicators": [3]
                        },
                        "svpg_source": "Product Coaching Practice"
                    }
                ],

                "customer_research": [
                    {
                        "id": "customer_discovery_program",
                        "name": "Customer Discovery Program",
                        "category": "Customer Research",
                        "description": "Recruit 6-8 'earlyvangelist' customers for deep engagement. Goal: single solution all 6 love. Defines product/market fit.",
                        "when_to_use": "For B2B products or significant new features requiring deep customer partnership",
                        "time_commitment": "2-6 months",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "dedicated time for customer engagement"],
                        "outcomes": [
                            "6-8 reference customers",
                            "Product/market fit validation",
                            "Deep customer relationships",
                            "Case studies and testimonials"
                        ],
                        "matching_criteria": {
                            "keywords": ["reference customers", "early adopters", "b2b", "customer partnership", "validation"],
                            "discovery_patterns": ["need customer commitment", "b2b product", "require testimonials"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "customer_interviews",
                        "name": "Customer Interviews",
                        "category": "Customer Research",
                        "description": "Qualitative discussions with customers to discover opportunities. Pro tip: bring engineer along.",
                        "when_to_use": "You can never do too many. Essential for understanding customer problems and needs.",
                        "time_commitment": "1-2 hours per interview, ongoing practice",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "ideally + Engineer"],
                        "outcomes": [
                            "Deep problem understanding",
                            "Opportunity discovery",
                            "Validated assumptions",
                            "Customer empathy"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer needs", "understand users", "talk to customers", "interviews", "research"],
                            "discovery_patterns": ["haven't talked to customers", "assumptions", "need user insights"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "concierge_testing",
                        "name": "Concierge Testing",
                        "category": "Customer Research",
                        "description": "Do customer's job on their behalf to spot opportunities to better solve problems. Manual service delivery.",
                        "when_to_use": "Early validation before building anything. Understand workflow intimately.",
                        "time_commitment": "1-4 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager or team member to deliver service"],
                        "outcomes": [
                            "Deep workflow understanding",
                            "Identified opportunities",
                            "Validated value hypothesis",
                            "Customer relationships built"
                        ],
                        "matching_criteria": {
                            "keywords": ["manual testing", "service workflow", "understand process", "concierge"],
                            "discovery_patterns": ["complex workflow", "unclear solution", "need deep understanding"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "ideation": [
                    {
                        "id": "private_hackathon",
                        "name": "Private Hackathon",
                        "category": "Ideation",
                        "description": "Dedicated period where normal work stops and people pursue their own ideas.",
                        "when_to_use": "To unlock team creativity, explore new directions, boost morale",
                        "time_commitment": "1-3 days",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Full team participation", "leadership buy-in"],
                        "outcomes": [
                            "Innovative ideas surfaced",
                            "Team engagement increased",
                            "Unexpected solutions discovered",
                            "Improved morale"
                        ],
                        "matching_criteria": {
                            "keywords": ["innovation", "hackathon", "team ideas", "creativity", "exploration"],
                            "discovery_patterns": ["team wants to innovate", "stagnant ideas", "low morale"],
                            "phase_indicators": [1, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "customer_misbehavior",
                        "name": "Customer Misbehavior",
                        "category": "Ideation",
                        "description": "Intentionally enable product use in unintended ways. Many exceptional ideas come from this.",
                        "when_to_use": "When you want to discover unexpected use cases and opportunities",
                        "time_commitment": "Ongoing observation",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Data analysis", "Customer observation"],
                        "outcomes": [
                            "Unexpected use cases discovered",
                            "New product opportunities",
                            "Innovation from user creativity",
                            "Market expansion possibilities"
                        ],
                        "matching_criteria": {
                            "keywords": ["unexpected usage", "workarounds", "creative use", "unintended"],
                            "discovery_patterns": ["users hacking product", "creative workarounds", "off-label use"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "prototyping": [
                    {
                        "id": "user_prototype",
                        "name": "User Prototype",
                        "category": "Prototyping",
                        "description": "Simulation of user experience requiring no engineering. Quick iteration tool for designers and PMs.",
                        "when_to_use": "Rapid internal iteration and user testing before engineering investment",
                        "time_commitment": "Hours to days",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager"],
                        "outcomes": [
                            "Rapid iteration",
                            "User feedback before coding",
                            "Validated usability",
                            "Reduced engineering waste"
                        ],
                        "matching_criteria": {
                            "keywords": ["prototype", "mockup", "test design", "usability", "iterate"],
                            "discovery_patterns": ["need quick validation", "test with users", "before engineering"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "feasibility_prototype",
                        "name": "Feasibility Prototype",
                        "category": "Prototyping",
                        "description": "Created by/for engineers to tackle technical risks. Rarely resembles final product. Speed of learning over reuse.",
                        "when_to_use": "When facing technical unknowns or risks that need validation",
                        "time_commitment": "Days to weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Engineers"],
                        "outcomes": [
                            "Technical feasibility validated",
                            "Technical approach proven",
                            "Risk reduction",
                            "Implementation confidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["technical risk", "feasibility", "can we build", "engineering", "proof of concept"],
                            "discovery_patterns": ["technical unknowns", "new technology", "performance concerns"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "live_data_prototype",
                        "name": "Live-Data Prototype",
                        "category": "Prototyping",
                        "description": "Working functionality with live data for quick usage data collection. Not fully productized.",
                        "when_to_use": "When you need real usage data quickly with actual users and live data",
                        "time_commitment": "1-3 weeks",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Engineers", "Product Manager"],
                        "outcomes": [
                            "Real usage data",
                            "Quantitative validation",
                            "Live traffic testing",
                            "Fast iteration with real data"
                        ],
                        "matching_criteria": {
                            "keywords": ["live data", "real users", "a/b test", "quantitative", "production"],
                            "discovery_patterns": ["need real data", "test at scale", "quantitative validation"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "hybrid_prototype",
                        "name": "Hybrid Prototype",
                        "category": "Prototyping",
                        "description": "Blend any prototyping techniques based on particular risks and experiments.",
                        "when_to_use": "When facing multiple types of risks requiring different validation approaches",
                        "time_commitment": "Varies based on combination",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Designer", "Engineer", "Product Manager"],
                        "outcomes": [
                            "Multiple risks addressed",
                            "Flexible validation approach",
                            "Efficient testing",
                            "Comprehensive evidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["multiple risks", "combination", "complex validation", "hybrid"],
                            "discovery_patterns": ["value and feasibility risks", "multiple unknowns", "comprehensive testing"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "wizard_of_oz",
                        "name": "Wizard of Oz Testing",
                        "category": "Prototyping",
                        "description": "Manually simulate functionality behind the scenes while users interact with seemingly automated interface.",
                        "when_to_use": "Test concept without building technology. Validate value before engineering investment.",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager", "team to operate behind scenes"],
                        "outcomes": [
                            "Concept validated without code",
                            "Value proven before building",
                            "User behavior understood",
                            "Reduced engineering risk"
                        ],
                        "matching_criteria": {
                            "keywords": ["manual backend", "simulate", "fake automation", "test without building"],
                            "discovery_patterns": ["expensive to build", "uncertain value", "need quick validation"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Research + Masterclass mention"
                    }
                ],

                "usability_testing": [
                    {
                        "id": "usability_testing",
                        "name": "Usability Testing",
                        "category": "Usability Testing",
                        "description": "Observe users performing specific tasks. May be in-person/virtual, supervised/unsupervised.",
                        "when_to_use": "Test if users can figure out how to use the solution",
                        "time_commitment": "1-2 weeks (recruit + test)",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager", "5-8 test users"],
                        "outcomes": [
                            "Usability issues identified",
                            "Task completion validated",
                            "User mental models understood",
                            "Design improvements identified"
                        ],
                        "matching_criteria": {
                            "keywords": ["usability", "can users use", "interface", "confusion", "user testing"],
                            "discovery_patterns": ["users struggling", "complex interface", "unclear navigation"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "qualitative_value_testing",
                        "name": "User Testing (Qualitative Value)",
                        "category": "Value Testing",
                        "description": "Expansion of usability testing with deeper engagement on value topic. Reveals unexpected insights.",
                        "when_to_use": "When you need to understand not just if they can use it, but if they find it valuable",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "5-8 test users"],
                        "outcomes": [
                            "Value perception understood",
                            "Willingness to use validated",
                            "Pain points quantified",
                            "Unexpected insights discovered"
                        ],
                        "matching_criteria": {
                            "keywords": ["value", "will they use", "worth it", "pay for", "qualitative"],
                            "discovery_patterns": ["uncertain value", "will users care", "worth using"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "value_testing": [
                    {
                        "id": "fake_door_test",
                        "name": "Fake Door Test",
                        "category": "Value Testing",
                        "description": "Measure interaction with feature control for functionality not yet built.",
                        "when_to_use": "Test demand for feature before building it",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "basic implementation"],
                        "outcomes": [
                            "Demand validated",
                            "Click-through rate measured",
                            "Interest quantified",
                            "Build decision informed"
                        ],
                        "matching_criteria": {
                            "keywords": ["demand", "fake door", "feature interest", "would they use"],
                            "discovery_patterns": ["uncertain demand", "test interest", "before building"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "landing_page_test",
                        "name": "Landing Page Test",
                        "category": "Value Testing",
                        "description": "Drive traffic to pitch page for non-existent product, measure conversion on call-to-action.",
                        "when_to_use": "Validate market demand before building product",
                        "time_commitment": "1-3 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Marketing"],
                        "outcomes": [
                            "Market demand validated",
                            "Conversion rate measured",
                            "Value proposition tested",
                            "Customer acquisition cost estimated"
                        ],
                        "matching_criteria": {
                            "keywords": ["landing page", "demand", "market test", "conversion", "interest"],
                            "discovery_patterns": ["new product", "market validation", "will they pay"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "explainer_video",
                        "name": "Explainer Video",
                        "category": "Value Testing",
                        "description": "Create video of prototype and measure conversion on call-to-action.",
                        "when_to_use": "Communicate value proposition when product is complex or visual",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Video production"],
                        "outcomes": [
                            "Value communicated visually",
                            "Interest measured",
                            "Conversion tracked",
                            "Concept validation"
                        ],
                        "matching_criteria": {
                            "keywords": ["explainer", "video", "complex product", "visual", "demonstrate value"],
                            "discovery_patterns": ["hard to explain", "visual product", "need demonstration"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "value_assessment_framework",
                        "name": "Assessing Value (Time/Reputation/Cash/Behavior)",
                        "category": "Value Testing",
                        "description": "Framework: Time (trial), Reputation (NPS, referrals), Cash (pre-order, LOI), Behavior (active switch from incumbent)",
                        "when_to_use": "Systematically assess if customers truly value the solution",
                        "time_commitment": "Ongoing measurement",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Analytics"],
                        "outcomes": [
                            "Value signals measured",
                            "Customer commitment validated",
                            "Real intent vs stated intent",
                            "Investment justification"
                        ],
                        "matching_criteria": {
                            "keywords": ["value", "commitment", "will they pay", "switch", "intent"],
                            "discovery_patterns": ["uncertain commitment", "stated vs actual intent", "validate value"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "preorder_campaign",
                        "name": "Pre-order Campaign",
                        "category": "Value Testing",
                        "description": "Ask customers to commit money before product exists. Ultimate value validation.",
                        "when_to_use": "When you need strongest signal of value - actual payment commitment",
                        "time_commitment": "2-4 weeks",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Product Manager", "Marketing", "Sales", "Legal"],
                        "outcomes": [
                            "Payment commitment secured",
                            "Value definitively validated",
                            "Revenue de-risked",
                            "Early adopters identified"
                        ],
                        "matching_criteria": {
                            "keywords": ["pre-order", "payment", "commit money", "pay before", "advance purchase"],
                            "discovery_patterns": ["need revenue validation", "will they pay", "financial commitment"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Research"
                    }
                ],

                "quantitative_testing": [
                    {
                        "id": "ab_testing",
                        "name": "A/B Testing",
                        "category": "Quantitative Testing",
                        "description": "Use live traffic to compare quantitative outcomes for innovation/optimization vs baseline.",
                        "when_to_use": "When you need statistically significant proof that something works",
                        "time_commitment": "1-4 weeks depending on traffic",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Engineers", "Data Analyst", "Product Manager"],
                        "outcomes": [
                            "Statistical significance achieved",
                            "Quantitative impact measured",
                            "Baseline comparison",
                            "Data-driven decisions"
                        ],
                        "matching_criteria": {
                            "keywords": ["a/b test", "quantitative", "measure impact", "statistics", "data-driven"],
                            "discovery_patterns": ["need proof", "measure impact", "optimization", "compare options"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "feasibility_viability_testing": [
                    {
                        "id": "stakeholder_testing",
                        "name": "Stakeholder Testing",
                        "category": "Viability Testing",
                        "description": "Product walkthrough with key stakeholders to uncover constraints (legal, compliance, sales, etc.).",
                        "when_to_use": "Before significant investment, ensure solution works for all business functions",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "time from stakeholders"],
                        "outcomes": [
                            "Business constraints identified",
                            "Stakeholder concerns addressed",
                            "Viability risks surfaced",
                            "Cross-functional alignment"
                        ],
                        "matching_criteria": {
                            "keywords": ["stakeholders", "constraints", "legal", "compliance", "sales", "viability"],
                            "discovery_patterns": ["need stakeholder buy-in", "business constraints", "compliance requirements"],
                            "phase_indicators": [3, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "premortem_gtm_testing",
                        "name": "Pre-mortem GTM Assumptions Testing",
                        "category": "Viability Testing",
                        "description": "Give extended product team opportunity to express all functional concerns early in discovery.",
                        "when_to_use": "Before committing to solution, surface all potential failures",
                        "time_commitment": "1-2 days",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Extended product team", "Product Manager"],
                        "outcomes": [
                            "Hidden risks surfaced",
                            "Functional concerns addressed",
                            "Failure modes identified",
                            "Risk mitigation planned"
                        ],
                        "matching_criteria": {
                            "keywords": ["pre-mortem", "gtm", "go to market", "risks", "what could fail"],
                            "discovery_patterns": ["need risk assessment", "complex launch", "many dependencies"],
                            "phase_indicators": [3, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "discovery_workflows": [
                    {
                        "id": "discovery_sprints",
                        "name": "Discovery Sprints",
                        "category": "Discovery Workflow",
                        "description": "Time-boxed intensive discovery: amorphous problem to user-tested solution in one week.",
                        "when_to_use": "Teams new to discovery, working on something big, or moving too slow",
                        "time_commitment": "1 week (5 days)",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Full product team (PM, Designer, Engineers)"],
                        "outcomes": [
                            "Rapid progress on hard problems",
                            "Team learns discovery process",
                            "Tested solution in days not months",
                            "Momentum and confidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["discovery sprint", "design sprint", "one week", "rapid", "learn discovery"],
                            "discovery_patterns": ["slow progress", "new to discovery", "big problem", "need structure"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "continuous_discovery",
                        "name": "Continuous Discovery (Weekly Cadence)",
                        "category": "Discovery Workflow",
                        "description": "Ongoing practice of weekly customer interaction and testing, not a phase.",
                        "when_to_use": "Establish sustainable discovery practice for empowered teams",
                        "time_commitment": "Ongoing - weekly rhythm",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product team commitment", "access to customers"],
                        "outcomes": [
                            "Continuous learning",
                            "Reduced feature failure rate",
                            "Faster iteration",
                            "Customer-informed decisions"
                        ],
                        "matching_criteria": {
                            "keywords": ["continuous", "weekly", "ongoing", "cadence", "habit"],
                            "discovery_patterns": ["want ongoing practice", "reduce failure rate", "build muscle"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025 + Research"
                    },
                    {
                        "id": "assumption_testing",
                        "name": "Assumption Testing",
                        "category": "Discovery Workflow",
                        "description": "Systematically identify assumptions and design experiments to validate/invalidate them.",
                        "when_to_use": "When you have many untested assumptions that could sink the product",
                        "time_commitment": "Ongoing throughout discovery",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Engineer"],
                        "outcomes": [
                            "Assumptions surfaced",
                            "Risky assumptions tested first",
                            "Evidence-based decisions",
                            "Risk reduction"
                        ],
                        "matching_criteria": {
                            "keywords": ["assumptions", "hypotheses", "validate", "test", "unknowns"],
                            "discovery_patterns": ["many assumptions", "high risk", "untested beliefs"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Research"
                    }
                ],

                "metrics_and_analysis": [
                    {
                        "id": "heart_metrics",
                        "name": "HEART Metrics",
                        "category": "Metrics & Analysis",
                        "description": "Taxonomy of KPIs for measuring product experience quality: Happiness, Engagement, Adoption, Retention, Task Success",
                        "when_to_use": "Establish comprehensive product health measurement framework",
                        "time_commitment": "1-2 weeks to establish",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Data Analyst", "Engineering for instrumentation"],
                        "outcomes": [
                            "Comprehensive metrics framework",
                            "Product health visibility",
                            "Leading indicators identified",
                            "Objective success measurement"
                        ],
                        "matching_criteria": {
                            "keywords": ["metrics", "kpis", "product health", "measurement", "happiness", "engagement"],
                            "discovery_patterns": ["no metrics", "unclear success", "need measurement framework"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ]
            },

            "coaching_techniques": {
                "assessment_and_planning": [
                    {
                        "id": "coach_assessment",
                        "name": "Coaching Assessment",
                        "category": "Coaching - Assessment",
                        "description": "Help employee become great, NOT performance evaluation. Combine with self-assessment and 360.",
                        "when_to_use": "Starting a coaching relationship, periodic check-ins",
                        "time_commitment": "2-4 hours",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach time", "Assessment frameworks"],
                        "outcomes": [
                            "Baseline understanding of capabilities",
                            "Development areas identified",
                            "Strengths recognized",
                            "Growth plan foundation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_plan",
                        "name": "Coaching Plan",
                        "category": "Coaching - Planning",
                        "description": "Gap analysis approach: develop weaknesses, leverage strengths, consider their goals.",
                        "when_to_use": "After assessment, create personalized development plan",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach time", "Clear development framework"],
                        "outcomes": [
                            "Personalized development plan",
                            "Clear growth objectives",
                            "Skill development priorities",
                            "Career progression path"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "coaching_techniques_applied": [
                    {
                        "id": "six_page_narrative",
                        "name": "6-Page Written Narrative",
                        "category": "Coaching - Thinking",
                        "description": "Tool for framing decisions and forcing deep thinking. Actual prose vs PowerPoint bullets. Includes conclusion, analysis, alternatives, objections.",
                        "when_to_use": "For major decisions, strategic thinking, developing communication skills",
                        "time_commitment": "1-2 weeks for individual to write",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Time for writing and iteration"],
                        "outcomes": [
                            "Deep strategic thinking",
                            "Clear communication developed",
                            "Thorough analysis",
                            "Confidence in decisions"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_time_management",
                        "name": "Coaching Time Management",
                        "category": "Coaching - Execution",
                        "description": "Help team make time for discovery. Leverage delivery manager and manager support.",
                        "when_to_use": "When team claims no time for discovery work",
                        "time_commitment": "1-2 sessions",
                        "team_maturity": ["all"],
                        "resources_needed": ["Calendar review", "Manager partnership"],
                        "outcomes": [
                            "Time found for discovery",
                            "Priorities clarified",
                            "Delegation identified",
                            "Discovery becomes practice"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_discovery",
                        "name": "Coaching Product Discovery",
                        "category": "Coaching - Discovery",
                        "description": "Guide through: clear problem understanding, outcome definition, risk evaluation, strategies for addressing risks, necessary collaboration.",
                        "when_to_use": "Teaching teams how to do discovery work",
                        "time_commitment": "Ongoing over months",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Coach time", "Discovery frameworks"],
                        "outcomes": [
                            "Team learns discovery practice",
                            "Risk-based approach adopted",
                            "Collaboration improved",
                            "Independence developed"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_decisions",
                        "name": "Coaching Decisions",
                        "category": "Coaching - Execution",
                        "description": "Coach on: understanding a decision, right-sizing, collaboration, handling disagreements.",
                        "when_to_use": "When team struggles with decision-making",
                        "time_commitment": "Per decision",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach guidance"],
                        "outcomes": [
                            "Better decisions made",
                            "Appropriate collaboration",
                            "Productive disagreement",
                            "Decision confidence"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "organizational_coaching": [
                    {
                        "id": "setting_team_topology",
                        "name": "Setting Team Topology",
                        "category": "Coaching - Organization",
                        "description": "Structure teams to optimize for empowerment",
                        "when_to_use": "Organizational design or redesign",
                        "time_commitment": "Weeks to months",
                        "team_maturity": ["all"],
                        "resources_needed": ["Leadership partnership", "Organizational authority"],
                        "outcomes": [
                            "Empowered team structure",
                            "Clear ownership boundaries",
                            "Reduced dependencies",
                            "Autonomous teams"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "pilot_teams",
                        "name": "Pilot Teams",
                        "category": "Coaching - Transformation",
                        "description": "Fully transform small number of teams rather than partially transform many.",
                        "when_to_use": "Starting transformation, proving new model works",
                        "time_commitment": "3-6 months per pilot",
                        "team_maturity": ["all"],
                        "resources_needed": ["Committed teams", "Leadership support", "Coach time"],
                        "outcomes": [
                            "Proof points established",
                            "Success stories created",
                            "Learning from early teams",
                            "Momentum for transformation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "outcome_based_roadmap",
                        "name": "Outcome-Based Roadmap",
                        "category": "Coaching - Transition",
                        "description": "Transitional solution: annotate roadmaps with desired business results, measure actual vs hoped-for outcomes.",
                        "when_to_use": "Transitioning from feature roadmaps to outcomes",
                        "time_commitment": "Quarterly updates",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Product Manager", "Leadership buy-in"],
                        "outcomes": [
                            "Outcome thinking introduced",
                            "Results measured",
                            "Conversation shifted",
                            "Bridge to full transformation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "team_objectives_coaching": [
                    {
                        "id": "team_objectives_empowerment",
                        "name": "Team Objectives - Empowerment",
                        "category": "Coaching - Objectives",
                        "description": "Coach teams to be assigned problems rather than features.",
                        "when_to_use": "Shifting from feature teams to empowered teams",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Coach support", "Leadership alignment"],
                        "outcomes": [
                            "Problem-focused teams",
                            "Empowerment established",
                            "Ownership of outcomes",
                            "Innovation enabled"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_ambition",
                        "name": "Team Objectives - Ambition",
                        "category": "Coaching - Objectives",
                        "description": "Coach on setting ambition level: 10% vs 10x, roofshot vs moonshot, 80% vs 20% confidence.",
                        "when_to_use": "Setting team objectives and key results",
                        "time_commitment": "Quarterly",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Coach guidance", "Leadership support"],
                        "outcomes": [
                            "Appropriate stretch established",
                            "Innovation encouraged",
                            "Realistic expectations",
                            "Team motivation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_commitments",
                        "name": "Team Objectives - Commitments",
                        "category": "Coaching - Objectives",
                        "description": "Distinguish high-integrity commitments (major promises) from keep-the-lights-on work.",
                        "when_to_use": "Managing team commitments and expectations",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Trust between team and leadership"],
                        "outcomes": [
                            "Clear commitment framework",
                            "Appropriate promises",
                            "Trust established",
                            "Delivery predictability"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_management",
                        "name": "Team Objectives - Management",
                        "category": "Coaching - Objectives",
                        "description": "Coach on cadence (quarterly planning), progress tracking (weekly), early escalation, accountability.",
                        "when_to_use": "Establishing team objectives discipline",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["all"],
                        "resources_needed": ["Management systems", "Coach support"],
                        "outcomes": [
                            "Rhythm established",
                            "Progress visible",
                            "Early problem surfacing",
                            "Accountability clear"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ]
            }
        };

        // Technique Dependency Graph for sequencing recommendations
        const techniqueDependencyGraph = {
            'team_objective': { prerequisites: [], enables: ['opportunity_assessment', 'customer_interviews', 'lean_canvas'] },
            'opportunity_assessment': { prerequisites: ['team_objective'], enables: ['lean_canvas', 'journey_map', 'stakeholder_mapping'] },
            'customer_interviews': { prerequisites: ['team_objective'], enables: ['usability_testing', 'prototype_testing', 'jobs_to_be_done'] },
            'user_interviews': { prerequisites: [], enables: ['journey_map', 'jobs_to_be_done', 'prototype_testing'] },
            'assumption_testing': { prerequisites: [], enables: ['prototype_testing', 'a_b_testing', 'concierge_test'] },
            'prototype_testing': { prerequisites: ['assumption_testing'], enables: ['usability_testing', 'a_b_testing'] },
            'usability_testing': { prerequisites: ['prototype_testing'], enables: ['a_b_testing'] },
            'lean_canvas': { prerequisites: ['opportunity_assessment'], enables: ['pr_faq', 'assumption_testing'] },
            'pr_faq': { prerequisites: ['lean_canvas'], enables: ['prototype_testing'] },
            'journey_map': { prerequisites: ['user_interviews'], enables: ['story_mapping', 'usability_testing'] },
            'story_mapping': { prerequisites: ['journey_map'], enables: ['prototype_testing'] },
            'jobs_to_be_done': { prerequisites: ['customer_interviews'], enables: ['opportunity_assessment', 'prototype_testing'] },
            'a_b_testing': { prerequisites: ['prototype_testing'], enables: ['heart_metrics', 'data_mining'] },
            'heart_metrics': { prerequisites: [], enables: ['a_b_testing', 'data_mining'] },
            'data_mining': { prerequisites: ['heart_metrics'], enables: ['assumption_testing'] },
            'concierge_test': { prerequisites: ['assumption_testing'], enables: ['wizard_of_oz', 'prototype_testing'] },
            'wizard_of_oz': { prerequisites: ['concierge_test'], enables: ['prototype_testing'] },
            'stakeholder_mapping': { prerequisites: ['opportunity_assessment'], enables: ['reference_customers'] },
            'reference_customers': { prerequisites: ['stakeholder_mapping'], enables: [] },
            'continuous_discovery': { prerequisites: ['customer_interviews'], enables: ['usability_testing', 'a_b_testing'] },
            'product_taxonomy_mapping': { prerequisites: [], enables: ['journey_map', 'stakeholder_mapping'] }
        };

        // Blocker Detection Patterns for urgency classification
        const blockerPatterns = [
            { id: 'no_customer_contact', patterns: ['no customer', 'haven\'t talked', 'no interviews', 'never spoken', 'no user research', 'no customer contact'], urgencyBoost: 'critical' },
            { id: 'unclear_problem', patterns: ['unclear problem', 'feature factory', 'don\'t know why', 'no problem definition', 'problem not defined', 'unclear why'], urgencyBoost: 'critical' },
            { id: 'no_metrics', patterns: ['no metrics', 'no success criteria', 'don\'t measure', 'no kpis', 'not measuring', 'no measurement'], urgencyBoost: 'important' },
            { id: 'no_validation', patterns: ['no validation', 'not validated', 'unvalidated', 'assumptions not tested', 'never tested'], urgencyBoost: 'important' },
            { id: 'stakeholder_misalignment', patterns: ['stakeholders disagree', 'no alignment', 'conflicting priorities', 'misaligned'], urgencyBoost: 'important' },
            { id: 'no_discovery', patterns: ['no discovery', 'skipping discovery', 'straight to build', 'build first'], urgencyBoost: 'critical' }
        ];

        // Technique Recommender Class
        class TechniqueRecommender {
            constructor() {
                // No initialization needed
            }

            /**
             * Get all discovery techniques from the library
             */
            getAllDiscoveryTechniques() {
                const techniques = [];

                // Load all discovery techniques from all categories
                Object.values(svpgTechniqueLibrary.discovery_techniques).forEach(category => {
                    techniques.push(...category);
                });

                return techniques;
            }

            /**
             * Get all coaching techniques from the library
             */
            getAllCoachingTechniques() {
                const techniques = [];

                // Load all coaching techniques from all categories
                Object.values(svpgTechniqueLibrary.coaching_techniques).forEach(category => {
                    techniques.push(...category);
                });

                return techniques;
            }

            /**
             * Analyze discovery findings and recommend techniques
             * @param {Object} state - The current state with all questions
             * @param {String} type - 'discovery' or 'coaching' or 'all'
             * @returns {Object} - Discovery and Coaching recommendations
             */
            recommendTechniques(state, type = 'all') {
                // Extract all findings text
                const allFindings = this.extractAllFindings(state);

                if (!allFindings || allFindings.trim().length === 0) {
                    return { discovery: [], coaching: [] };
                }

                const result = {
                    discovery: [],
                    coaching: []
                };

                // Recommend discovery techniques
                if (type === 'all' || type === 'discovery') {
                    result.discovery = this.scoreAndRankTechniques(
                        this.getAllDiscoveryTechniques(),
                        allFindings,
                        state
                    ).slice(0, 10); // Top 10 discovery techniques
                }

                // Recommend coaching techniques
                if (type === 'all' || type === 'coaching') {
                    result.coaching = this.scoreAndRankTechniques(
                        this.getAllCoachingTechniques(),
                        allFindings,
                        state
                    ).slice(0, 5); // Top 5 coaching techniques
                }

                return result;
            }

            /**
             * Score and rank techniques based on findings
             */
            scoreAndRankTechniques(techniques, allFindings, state) {
                const clientName = state.metadata?.clientName || 'your team';

                // Build Q&A attribution map once for all techniques
                const qaMap = this.buildQAAttributionMap(state);

                // Detect blockers once
                const detectedBlockers = this.detectBlockers(allFindings);

                const scoredTechniques = techniques.map(technique => {
                    let score = 0;
                    const matchReasons = [];
                    const matchedKeywords = [];
                    const matchedPatterns = [];

                    // Track score breakdown
                    let keywordScore = 0;
                    let patternScore = 0;
                    let phaseScore = 0;
                    let whenToUseScore = 0;

                    // Track Q&A contributions
                    const qaContributions = [];

                    // Match using the new matching_criteria
                    if (technique.matching_criteria) {
                        // Keyword matching with Q&A attribution
                        technique.matching_criteria.keywords.forEach(keyword => {
                            if (allFindings.toLowerCase().includes(keyword.toLowerCase())) {
                                score += 10;
                                keywordScore += 10;
                                matchedKeywords.push(keyword);

                                // Find which Q&A contributed this keyword
                                qaMap.forEach(qa => {
                                    if (qa.findings.includes(keyword.toLowerCase())) {
                                        const existing = qaContributions.find(c => c.questionId === qa.questionId);
                                        if (existing) {
                                            existing.matchedTerms.push(keyword);
                                            existing.points += 10;
                                        } else {
                                            qaContributions.push({
                                                questionId: qa.questionId,
                                                questionText: qa.questionText,
                                                matchedTerms: [keyword],
                                                points: 10
                                            });
                                        }
                                    }
                                });
                            }
                        });

                        // Discovery pattern matching (higher weight) with Q&A attribution
                        technique.matching_criteria.discovery_patterns.forEach(pattern => {
                            if (allFindings.toLowerCase().includes(pattern.toLowerCase())) {
                                score += 15;
                                patternScore += 15;
                                matchedPatterns.push(pattern);

                                // Find which Q&A contributed this pattern
                                qaMap.forEach(qa => {
                                    if (qa.findings.includes(pattern.toLowerCase())) {
                                        const existing = qaContributions.find(c => c.questionId === qa.questionId);
                                        if (existing) {
                                            existing.matchedTerms.push(pattern);
                                            existing.points += 15;
                                        } else {
                                            qaContributions.push({
                                                questionId: qa.questionId,
                                                questionText: qa.questionText,
                                                matchedTerms: [pattern],
                                                points: 15
                                            });
                                        }
                                    }
                                });
                            }
                        });

                        // Phase indicator matching
                        const phaseMatch = this.matchPhaseIndicators(state, technique.matching_criteria.phase_indicators);
                        score += phaseMatch.score;
                        phaseScore = phaseMatch.score;
                        if (phaseMatch.reason) {
                            matchReasons.push(phaseMatch.reason);
                        }
                    }

                    // When to use matching
                    const whenToUseMatch = this.matchWhenToUse(allFindings, technique.when_to_use);
                    score += whenToUseMatch.score;
                    whenToUseScore = whenToUseMatch.score;

                    // Generate client-contextualized benefit statement
                    if (matchedKeywords.length > 0 || matchedPatterns.length > 0) {
                        const benefitStatement = this.generateClientBenefit(
                            technique,
                            matchedKeywords,
                            matchedPatterns,
                            clientName
                        );
                        matchReasons.unshift(benefitStatement);
                    }

                    // Add a summary of what was detected
                    if (matchedKeywords.length > 0) {
                        matchReasons.push(`Detected in your findings: ${matchedKeywords.slice(0, 3).join(', ')}`);
                    }

                    // Calculate urgency
                    const urgency = this.calculateUrgency(score, technique, detectedBlockers);

                    // Generate contextual rationale
                    const contextualRationale = this.generateContextualRationale(technique, qaContributions, clientName);

                    // Contextualize outcomes
                    const contextualizedOutcomes = this.contextualizeOutcomes(technique.outcomes, qaContributions, clientName);

                    return {
                        technique,
                        score,
                        matchReasons: this.deduplicateReasons(matchReasons),
                        // NEW FIELDS:
                        scoreBreakdown: {
                            keywordScore,
                            patternScore,
                            phaseScore,
                            whenToUseScore,
                            matchedKeywords,
                            matchedPatterns
                        },
                        qaContributions: qaContributions.sort((a, b) => b.points - a.points),
                        urgency,
                        contextualRationale,
                        contextualizedOutcomes
                    };
                });

                // Filter and sort
                let filtered = scoredTechniques
                    .filter(t => t.score > 0)
                    .sort((a, b) => b.score - a.score);

                // Apply sequencing logic
                return this.applySequencingLogic(filtered);
            }

            /**
             * Generate a client-contextualized benefit statement for a technique
             */
            generateClientBenefit(technique, matchedKeywords, matchedPatterns, clientName) {
                const outcomes = technique.outcomes || [];
                const primaryOutcome = outcomes[0] || '';
                const secondaryOutcome = outcomes[1] || '';

                // Build context-aware benefit statements based on technique category and matches
                const benefitTemplates = {
                    'assumption_testing': `${clientName} has untested assumptions that could derail the product. This technique will help systematically identify and validate these assumptions, reducing risk and ensuring evidence-based decisions.`,
                    'user_interviews': `Your discovery reveals the need to understand user perspectives better. Conducting structured interviews will uncover ${clientName}'s users' real needs, pain points, and motivations.`,
                    'prototype_testing': `${clientName} needs to validate solutions before building. Prototyping will let you test ideas quickly with real users and iterate based on feedback.`,
                    'opportunity_assessment': `${clientName} should evaluate whether this opportunity is worth pursuing. This framework will clarify the business objective, success metrics, and validate the customer problem.`,
                    'team_objective': `${clientName} needs clearer alignment on goals. This technique shifts focus from features to outcomes, ensuring the team knows what problem they're solving and how to measure success.`,
                    'continuous_discovery': `${clientName} would benefit from ongoing customer engagement. Weekly touchpoints with customers will keep the team grounded in real user needs throughout development.`,
                    'story_mapping': `${clientName} needs to visualize the user journey. Story mapping will help prioritize work based on user value and identify gaps in the experience.`,
                    'jobs_to_be_done': `Understanding the jobs ${clientName}'s users are trying to accomplish will reveal unmet needs and opportunities for differentiation.`,
                    'usability_testing': `${clientName} should validate that solutions are actually usable. Testing with real users will uncover friction points before launch.`,
                    'a_b_testing': `${clientName} can use data to make decisions. A/B testing will provide evidence for which approaches work best with your users.`,
                    'lean_canvas': `${clientName} has multiple assumptions to track. The Lean Canvas will map all hypotheses and surface what needs testing first.`,
                    'pr_faq': `${clientName} should work backwards from the desired customer outcome. Writing a PR/FAQ forces clarity on the value proposition and customer benefits.`,
                    'heart_metrics': `${clientName} needs a framework for measuring product success. HEART metrics will establish comprehensive KPIs across happiness, engagement, adoption, retention, and task success.`,
                    'data_mining': `${clientName} has existing data that can reveal insights. Analyzing behavioral patterns will uncover what users actually do vs. what they say.`,
                    'concierge_test': `${clientName} can validate demand before building. Manually delivering the service first will prove whether customers actually want and will pay for the solution.`,
                    'wizard_of_oz': `${clientName} can test the experience without building the technology. Simulating the backend manually lets you validate the user experience first.`,
                    'stakeholder_mapping': `${clientName} has multiple stakeholders to manage. Mapping their interests and influence will help navigate organizational dynamics.`,
                    'reference_customers': `${clientName} needs early adopters to validate and champion the product. Identifying and nurturing reference customers will accelerate adoption.`,
                    'product_taxonomy_mapping': `${clientName} may have overlapping features across products causing user confusion and wasted effort. This workshop will map all capabilities, identify duplications, and establish clear ownership boundaries.`
                };

                // Check if we have a specific template for this technique
                if (benefitTemplates[technique.id]) {
                    return benefitTemplates[technique.id];
                }

                // Generate a generic but still contextual benefit statement
                let benefit = `Based on ${clientName}'s discovery findings, `;

                if (matchedPatterns.length > 0) {
                    benefit += `the identified pattern "${matchedPatterns[0]}" suggests this technique will help. `;
                }

                if (primaryOutcome) {
                    benefit += `Expected outcome: ${primaryOutcome}.`;
                }

                if (secondaryOutcome && benefit.length < 200) {
                    benefit += ` Additionally: ${secondaryOutcome}.`;
                }

                return benefit;
            }

            /**
             * Build Q&A Attribution Map - maps each question to its findings for attribution tracking
             */
            buildQAAttributionMap(state) {
                const qaMap = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'answered' && q.findings && q.findings.trim()) {
                        qaMap.push({
                            questionId: q.questionId,
                            questionText: q.text,
                            findings: q.findings.toLowerCase(),
                            phase: q.phase
                        });
                    }
                    if (q.notes && q.notes.trim()) {
                        qaMap.push({
                            questionId: q.questionId,
                            questionText: q.text + ' (notes)',
                            findings: q.notes.toLowerCase(),
                            phase: q.phase
                        });
                    }
                });

                return qaMap;
            }

            /**
             * Detect blockers from findings
             */
            detectBlockers(allFindings) {
                const detectedBlockers = [];

                blockerPatterns.forEach(blocker => {
                    blocker.patterns.forEach(pattern => {
                        if (allFindings.toLowerCase().includes(pattern.toLowerCase())) {
                            if (!detectedBlockers.find(b => b.id === blocker.id)) {
                                detectedBlockers.push({
                                    id: blocker.id,
                                    matchedPattern: pattern,
                                    urgencyBoost: blocker.urgencyBoost
                                });
                            }
                        }
                    });
                });

                return detectedBlockers;
            }

            /**
             * Calculate urgency level based on score and blockers
             */
            calculateUrgency(score, technique, detectedBlockers) {
                const hasBlockers = detectedBlockers.length > 0;
                const hasCriticalBlockers = detectedBlockers.some(b => b.urgencyBoost === 'critical');

                let level, indicator;

                if (score > 70 && hasCriticalBlockers) {
                    level = 'critical';
                    indicator = '🔴';
                } else if (score >= 40 || (score > 70 && !hasCriticalBlockers)) {
                    level = 'important';
                    indicator = '🟠';
                } else {
                    level = 'valuable';
                    indicator = '🟡';
                }

                return {
                    level,
                    indicator,
                    hasBlockers,
                    blockerReasons: detectedBlockers.map(b => b.matchedPattern)
                };
            }

            /**
             * Generate contextual rationale based on Q&A contributions
             */
            generateContextualRationale(technique, qaContributions, clientName) {
                if (qaContributions.length === 0) {
                    return `This technique is recommended for ${clientName} based on the current discovery phase.`;
                }

                const topContribution = qaContributions[0];
                let rationale = `Based on your finding about "${topContribution.matchedTerms.slice(0, 2).join(', ')}"`;

                if (qaContributions.length > 1) {
                    rationale += ` and ${qaContributions.length - 1} other related finding${qaContributions.length > 2 ? 's' : ''}`;
                }

                rationale += `, ${clientName} would benefit from ${technique.name}. `;

                // Add specific benefit based on technique
                if (technique.outcomes && technique.outcomes[0]) {
                    rationale += `This will help achieve: ${technique.outcomes[0]}.`;
                }

                return rationale;
            }

            /**
             * Contextualize outcomes tied to detected client situation
             */
            contextualizeOutcomes(outcomes, qaContributions, clientName) {
                if (!outcomes || outcomes.length === 0) return [];

                return outcomes.map((outcome, index) => {
                    let contextualizedOutcome = outcome;

                    // Add client context to first few outcomes
                    if (index < 2 && qaContributions.length > 0) {
                        const relevantTerms = qaContributions
                            .flatMap(qa => qa.matchedTerms)
                            .slice(0, 2);

                        if (relevantTerms.length > 0) {
                            contextualizedOutcome = `${outcome} (addresses: ${relevantTerms.join(', ')})`;
                        }
                    }

                    return contextualizedOutcome;
                });
            }

            /**
             * Apply sequencing logic from dependency graph
             */
            applySequencingLogic(scoredTechniques) {
                const techniqueIds = scoredTechniques.map(t => t.technique.id);

                return scoredTechniques.map(rec => {
                    const techId = rec.technique.id;
                    const dependencies = techniqueDependencyGraph[techId];

                    let prerequisites = [];
                    let sequenceRationale = '';

                    if (dependencies) {
                        // Find prerequisites that are also recommended
                        prerequisites = dependencies.prerequisites.filter(prereq =>
                            techniqueIds.includes(prereq)
                        );

                        if (prerequisites.length > 0) {
                            const prereqNames = prerequisites.map(prereq => {
                                const found = scoredTechniques.find(t => t.technique.id === prereq);
                                return found ? found.technique.name : prereq;
                            });
                            sequenceRationale = `Consider completing ${prereqNames.join(', ')} first for better results.`;
                        } else if (dependencies.enables.length > 0) {
                            const enabledNames = dependencies.enables
                                .filter(e => techniqueIds.includes(e))
                                .map(e => {
                                    const found = scoredTechniques.find(t => t.technique.id === e);
                                    return found ? found.technique.name : e;
                                })
                                .slice(0, 2);

                            if (enabledNames.length > 0) {
                                sequenceRationale = `This technique will enable: ${enabledNames.join(', ')}.`;
                            }
                        }
                    }

                    return {
                        ...rec,
                        sequencing: {
                            prerequisites,
                            sequenceRationale
                        }
                    };
                });
            }

            /**
             * Extract all findings text from answered questions
             */
            extractAllFindings(state) {
                const findings = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'answered' && q.findings.trim()) {
                        findings.push(q.findings);
                    }
                    if (q.notes && q.notes.trim()) {
                        findings.push(q.notes);
                    }
                });

                return findings.join(' ').toLowerCase();
            }

            /**
             * Match findings against technique situations
             */
            matchSituations(findings, situations) {
                let score = 0;
                const reasons = [];

                situations.forEach(situation => {
                    const situationLower = situation.toLowerCase();

                    // Check for exact phrase match (high value)
                    if (findings.includes(situationLower)) {
                        score += 15;
                        reasons.push(`Your discovery reveals: "${situation}"`);
                    } else {
                        // Check for partial word matches
                        const situationWords = situationLower.split(/\s+/).filter(w => w.length > 3);
                        const matchingWords = situationWords.filter(word => findings.includes(word));

                        if (matchingWords.length >= 3) {
                            score += 8;
                            reasons.push(`Discovery findings align with: "${situation}"`);
                        } else if (matchingWords.length >= 2) {
                            score += 4;
                        }
                    }
                });

                return { score, reasons };
            }

            /**
             * Match findings against when_to_use description
             */
            matchWhenToUse(findings, whenToUse) {
                const whenToUseLower = whenToUse.toLowerCase();
                let score = 0;
                let reason = null;

                // Check for significant overlap with when_to_use
                const whenToUseWords = whenToUseLower.split(/\s+/).filter(w => w.length > 4);
                const matchingWords = whenToUseWords.filter(word => findings.includes(word));

                if (matchingWords.length >= 5) {
                    score = 12;
                    reason = `Timing is right: ${whenToUse}`;
                } else if (matchingWords.length >= 3) {
                    score = 6;
                } else if (matchingWords.length >= 2) {
                    score = 3;
                }

                return { score, reason };
            }

            /**
             * Match technique against phase indicators
             * Checks if questions in indicated phases have issues/gaps
             */
            matchPhaseIndicators(state, phaseIndicators) {
                let score = 0;
                let reason = null;

                if (!phaseIndicators || phaseIndicators.length === 0) {
                    return { score: 0, reason: null };
                }

                // Check which phases have gaps or issues
                const phaseGaps = [];
                phaseIndicators.forEach(phaseNum => {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phaseNum);
                    const unanswered = phaseQuestions.filter(q => q.status === 'open').length;

                    if (unanswered > 0) {
                        score += 5;
                        phaseGaps.push(`Phase ${phaseNum}`);
                    }
                });

                if (phaseGaps.length > 0) {
                    reason = `Addresses gaps in: ${phaseGaps.join(', ')}`;
                }

                return { score, reason };
            }

            /**
             * DEPRECATED - kept for backwards compatibility
             * Score technique based on keyword matches
             */
            scoreByKeywords(findings, technique) {
                let score = 0;

                // Define impactful keywords for different categories
                const keywordMappings = {
                    discovery: ['customer', 'users', 'research', 'insights', 'understand', 'problem', 'validate'],
                    strategy: ['direction', 'vision', 'alignment', 'priorities', 'goals', 'objectives'],
                    validation: ['test', 'validate', 'experiment', 'prototype', 'verify', 'proof'],
                    collaboration: ['stakeholder', 'alignment', 'communication', 'trust', 'partnership'],
                    process: ['workflow', 'process', 'agile', 'sprint', 'delivery'],
                    team: ['autonomy', 'ownership', 'empowered', 'decision']
                };

                const categoryKeywords = keywordMappings[technique.category.toLowerCase()] || [];

                categoryKeywords.forEach(keyword => {
                    if (findings.includes(keyword)) {
                        score += 2;
                    }
                });

                return score;
            }

            /**
             * Remove duplicate or very similar reasons
             */
            deduplicateReasons(reasons) {
                const unique = [];

                reasons.forEach(reason => {
                    const isDuplicate = unique.some(existing =>
                        existing.toLowerCase() === reason.toLowerCase() ||
                        existing.includes(reason) ||
                        reason.includes(existing)
                    );

                    if (!isDuplicate) {
                        unique.push(reason);
                    }
                });

                return unique.slice(0, 3); // Limit to top 3 reasons
            }
        }

        // Summary Generator Class
        class SummaryGenerator {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.techniqueRecommender = new TechniqueRecommender();
                this.setupEventListeners();
            }

            setupEventListeners() {
                const btn = document.getElementById('generateSummary');
                if (btn) {
                    btn.addEventListener('click', () => {
                        this.generateSummary();
                    });
                }
            }

            generateSummary() {
                const btn = document.getElementById('generateSummary');
                const originalText = btn.textContent;

                // Show loading state with progress ring
                btn.disabled = true;
                btn.innerHTML = '<span class="progress-ring"></span> Generating...';
                btn.style.cursor = 'wait';
                btn.style.opacity = '0.7';

                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    try {
                        const state = this.stateManager.getState();
                        const coverage = this.stateManager.calculateCoverage();

                        // Get recommendations (returns {discovery: [], coaching: []})
                        const recommendations = this.techniqueRecommender.recommendTechniques(state, 'all');

                        const summary = {
                            coverage: coverage,
                            keyFindings: this.extractKeyFindings(state),
                            gaps: this.identifyGaps(state),
                            methodsUsed: this.analyzeMethodsUsed(state),
                            phaseInsights: this.generatePhaseInsights(state),
                            discoveryTechniques: recommendations.discovery,
                            coachingTechniques: recommendations.coaching
                        };

                        this.renderSummary(summary);
                    } catch (error) {
                        console.error('Error generating summary:', error);
                        const summaryContainer = document.getElementById('summaryContent');
                        if (summaryContainer) {
                            summaryContainer.innerHTML = `<div class="error-message" style="color: #d32f2f; padding: 20px;">Error generating summary: ${error.message}</div>`;
                        }
                    } finally {
                        // Restore button state
                        btn.disabled = false;
                        btn.textContent = originalText;
                        btn.style.cursor = 'pointer';
                        btn.style.opacity = '1';
                    }
                }, 100);
            }

            extractKeyFindings(state) {
                const findings = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'answered' && q.findings.trim()) {
                        findings.push({
                            phase: q.phase,
                            questionId: q.questionId,
                            questionText: q.text,
                            text: q.findings
                        });
                    }
                });

                return findings;
            }

            identifyGaps(state) {
                const gaps = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'open' || !q.findings.trim()) {
                        gaps.push({
                            questionId: q.questionId,
                            text: q.text,
                            phase: q.phase
                        });
                    }
                });

                return gaps;
            }

            analyzeMethodsUsed(state) {
                const methodCounts = {};

                discoveryMethods.forEach(m => {
                    methodCounts[m.id] = {
                        label: m.label,
                        icon: m.icon,
                        count: 0
                    };
                });

                Object.values(state.questions).forEach(q => {
                    q.discoveryMethods.forEach(method => {
                        if (methodCounts[method]) {
                            methodCounts[method].count++;
                        }
                    });
                });

                return methodCounts;
            }

            generatePhaseInsights(state) {
                const insights = {};

                for (let phase = 1; phase <= 5; phase++) {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phase);
                    const answered = phaseQuestions.filter(q => q.status === 'answered');

                    insights[phase] = {
                        name: discoveryQuestions[`phase${phase}`].name,
                        total: phaseQuestions.length,
                        answered: answered.length,
                        percentage: phaseQuestions.length > 0 ? (answered.length / phaseQuestions.length) * 100 : 0
                    };
                }

                return insights;
            }

            renderSummary(summary) {
                const summaryContainer = document.getElementById('summaryContent');

                const html = `
                    <div class="summary-section">
                        <h3>Overall Coverage: ${summary.coverage.overall.toFixed(1)}%</h3>
                        <p>${summary.coverage.answeredCount} of ${summary.coverage.totalCount} questions answered</p>
                    </div>

                    <div class="summary-section">
                        <h4>Key Findings</h4>
                        ${summary.keyFindings.length > 0 ? `
                            <ul>
                                ${summary.keyFindings.map(f => `
                                    <li>
                                        <strong>${f.questionText}</strong><br>
                                        ${f.text.substring(0, 300)}${f.text.length > 300 ? '...' : ''}
                                    </li>
                                `).join('')}
                            </ul>
                        ` : '<p>No findings recorded yet.</p>'}
                    </div>

                    <div class="summary-section">
                        <h4>Discovery Gaps</h4>
                        ${summary.gaps.length > 0 ? `
                            <ul class="gaps-list">
                                ${summary.gaps.map(g => `
                                    <li>Phase ${g.phase}: ${g.text}</li>
                                `).join('')}
                            </ul>
                        ` : '<p style="color: #4caf50; font-weight: 600;">All questions answered! ✓</p>'}
                    </div>

                    <div class="summary-section">
                        <h4>Discovery Methods Used</h4>
                        <div class="methods-chart">
                            ${Object.entries(summary.methodsUsed).map(([key, method]) => `
                                <div class="method-stat ${method.count > 0 ? 'used' : ''}">
                                    <span class="method-icon">${method.icon}</span>
                                    <span class="method-label">${method.label}</span>
                                    <span class="method-count">${method.count}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="summary-section">
                        <h4>Phase-by-Phase Coverage</h4>
                        ${Object.entries(summary.phaseInsights).map(([phase, data]) => `
                            <div class="phase-insight">
                                <h5>Phase ${phase}: ${data.name}</h5>
                                <div class="phase-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${data.percentage}%"></div>
                                    </div>
                                    <span>${data.answered}/${data.total} (${data.percentage.toFixed(0)}%)</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div class="summary-section">
                        <h3>📋 Recommended Discovery Techniques (Top 10)</h3>
                        <p style="color: #666; margin-bottom: 15px;">Based on your discovery findings, here are specific techniques the TEAM should use:</p>
                        <div class="urgency-legend" style="display: flex; gap: 20px; font-size: 0.85em; color: #888; margin-bottom: 12px; padding: 8px 12px; background: #f8f9fa; border-radius: 6px;">
                            <span title="Score >70 with blockers detected (immediate action needed)">🔴 Critical</span>
                            <span title="Score 40-69 (address soon)">🟠 Important</span>
                            <span title="Score <40 (sequence as capacity allows)">🟡 Valuable</span>
                        </div>
                        ${summary.discoveryTechniques && summary.discoveryTechniques.length > 0 ? `
                            <div class="technique-filters">
                                <div class="filter-group">
                                    <label class="filter-label">Maturity:</label>
                                    <button class="filter-btn active" data-filter-type="maturity" data-filter-value="all">All</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="beginner">Beginner</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="intermediate">Intermediate</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="advanced">Advanced</button>
                                </div>
                            </div>
                            <div class="techniques-recommendations">
                                ${summary.discoveryTechniques.map((rec, index) => {
                                    const technique = rec.technique;
                                    const categorySlug = technique.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');

                                    // Determine maturity level
                                    const maturityLevel = technique.team_maturity.some(m => m.toLowerCase().includes('beginner')) ? 'beginner' :
                                                         technique.team_maturity.some(m => m.toLowerCase().includes('advanced')) ? 'advanced' : 'intermediate';

                                    // Get urgency info
                                    const urgency = rec.urgency || { level: 'valuable', indicator: '🟡' };

                                    return `
                                        <div class="technique-card" data-collapsed="false" data-maturity="${maturityLevel}">
                                            <div class="technique-header">
                                                <div class="header-left">
                                                    <span class="urgency-indicator ${urgency.level}" title="Urgency: ${urgency.level}">${urgency.indicator}</span>
                                                    <h4>${index + 1}. ${technique.name}</h4>
                                                    <span class="technique-badge ${categorySlug}">${technique.category}</span>
                                                    <span class="score-badge">Score: ${rec.score}</span>
                                                </div>
                                                <button class="collapse-btn" aria-label="Toggle details">
                                                    <span class="collapse-icon">▼</span>
                                                </button>
                                            </div>
                                            <div class="technique-collapsible-content">
                                                <p class="technique-description">${technique.description}</p>

                                                <div class="technique-details-sections">
                                                    <!-- Section 1: Why This Matters (default expanded) -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="true">Why This Matters</button>
                                                        <div class="section-content">
                                                            <div class="contextual-rationale">${rec.contextualRationale || ''}</div>
                                                            ${rec.qaContributions && rec.qaContributions.length > 0 ? `
                                                                <div class="qa-attribution">
                                                                    <div class="qa-attribution-header">Based on your answers:</div>
                                                                    ${rec.qaContributions.slice(0, 3).map(qa => `
                                                                        <div class="qa-item">
                                                                            <div class="qa-question">${qa.questionText}</div>
                                                                            <div class="qa-terms">Matched: ${qa.matchedTerms.slice(0, 3).join(', ')}</div>
                                                                            <div class="qa-points">+${qa.points} points</div>
                                                                        </div>
                                                                    `).join('')}
                                                                </div>
                                                            ` : ''}
                                                        </div>
                                                    </div>

                                                    <!-- Section 2: Expected Outcomes -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="false">Expected Outcomes</button>
                                                        <div class="section-content collapsed">
                                                            <div class="contextualized-outcomes">
                                                                <ul>
                                                                    ${(rec.contextualizedOutcomes || technique.outcomes).map(o => `<li>${o}</li>`).join('')}
                                                                </ul>
                                                            </div>
                                                        </div>
                                                    </div>

                                                    <!-- Section 3: Sequencing -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="false">Sequencing</button>
                                                        <div class="section-content collapsed">
                                                            <div class="sequencing-info">
                                                                ${rec.sequencing && rec.sequencing.prerequisites && rec.sequencing.prerequisites.length > 0 ? `
                                                                    <div class="sequencing-prerequisites">
                                                                        <strong>Prerequisites:</strong>
                                                                        <ul class="sequencing-prerequisite-list">
                                                                            ${rec.sequencing.prerequisites.map(p => `<li>${p}</li>`).join('')}
                                                                        </ul>
                                                                    </div>
                                                                ` : ''}
                                                                <p>${rec.sequencing?.sequenceRationale || 'This technique can be started independently.'}</p>
                                                            </div>
                                                        </div>
                                                    </div>

                                                    <!-- Section 4: Score Breakdown -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="false">Score Breakdown</button>
                                                        <div class="section-content collapsed">
                                                            <div class="score-breakdown">
                                                                <div class="score-row">
                                                                    <span class="score-label">Keyword matches:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.keywordScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.keywordScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Pattern matches:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.patternScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.patternScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Phase alignment:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.phaseScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.phaseScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Timing match:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.whenToUseScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.whenToUseScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Total:</span>
                                                                    <span class="score-value">${rec.score}</span>
                                                                </div>
                                                                ${rec.scoreBreakdown?.matchedKeywords?.length > 0 ? `
                                                                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                                                        <strong>Keywords:</strong> ${rec.scoreBreakdown.matchedKeywords.slice(0, 5).join(', ')}
                                                                    </div>
                                                                ` : ''}
                                                                ${rec.scoreBreakdown?.matchedPatterns?.length > 0 ? `
                                                                    <div style="margin-top: 5px; font-size: 12px; color: #666;">
                                                                        <strong>Patterns:</strong> ${rec.scoreBreakdown.matchedPatterns.slice(0, 3).join(', ')}
                                                                    </div>
                                                                ` : ''}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div class="technique-meta">
                                                    <div class="meta-item">
                                                        <span class="meta-label">When to use:</span>
                                                        <span class="meta-value">${technique.when_to_use}</span>
                                                    </div>
                                                    <div class="meta-item">
                                                        <span class="meta-label">Resources needed:</span>
                                                        <span class="meta-value">${technique.resources_needed.join(', ')}</span>
                                                    </div>
                                                    <div class="meta-item">
                                                        <span class="meta-label">Team maturity:</span>
                                                        <span class="meta-value">${technique.team_maturity.map(level => {
                                                            if (level === 'beginner') return 'Beginner (Teams new to product discovery)';
                                                            if (level === 'intermediate') return 'Intermediate (Teams with some discovery experience)';
                                                            if (level === 'advanced') return 'Advanced (Experienced teams with mature practices)';
                                                            return level;
                                                        }).join(', ')}</span>
                                                    </div>
                                                </div>

                                                <div class="technique-source">
                                                    <small>Source: ${technique.svpg_source}</small>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p>Answer more discovery questions to get personalized technique recommendations.</p>'}
                    </div>

                    <div class="summary-section coaching-section">
                        <h3>👨‍🏫 Coaching Techniques for You (Top 5)</h3>
                        <p style="color: #666; margin-bottom: 20px;">As a coach, here are techniques to guide this team's development:</p>
                        ${summary.coachingTechniques && summary.coachingTechniques.length > 0 ? `
                            <div class="techniques-recommendations">
                                ${summary.coachingTechniques.map((rec, index) => {
                                    const technique = rec.technique;
                                    const categorySlug = technique.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');

                                    // Get urgency info
                                    const urgency = rec.urgency || { level: 'valuable', indicator: '🟡' };

                                    return `
                                        <div class="technique-card coaching-card" data-collapsed="false">
                                            <div class="technique-header">
                                                <div class="header-left">
                                                    <span class="urgency-indicator ${urgency.level}" title="Urgency: ${urgency.level}">${urgency.indicator}</span>
                                                    <h4>${index + 1}. ${technique.name}</h4>
                                                    <span class="technique-badge coaching">${technique.category}</span>
                                                    <span class="score-badge coaching">Score: ${rec.score}</span>
                                                </div>
                                                <button class="collapse-btn" aria-label="Toggle details">
                                                    <span class="collapse-icon">▼</span>
                                                </button>
                                            </div>
                                            <div class="technique-collapsible-content">
                                                <p class="technique-description">${technique.description}</p>

                                                <div class="technique-details-sections">
                                                    <!-- Section 1: Why This Matters (default expanded) -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="true">Why This Matters</button>
                                                        <div class="section-content">
                                                            <div class="contextual-rationale">${rec.contextualRationale || ''}</div>
                                                            ${rec.qaContributions && rec.qaContributions.length > 0 ? `
                                                                <div class="qa-attribution">
                                                                    <div class="qa-attribution-header">Based on your answers:</div>
                                                                    ${rec.qaContributions.slice(0, 3).map(qa => `
                                                                        <div class="qa-item">
                                                                            <div class="qa-question">${qa.questionText}</div>
                                                                            <div class="qa-terms">Matched: ${qa.matchedTerms.slice(0, 3).join(', ')}</div>
                                                                            <div class="qa-points">+${qa.points} points</div>
                                                                        </div>
                                                                    `).join('')}
                                                                </div>
                                                            ` : ''}
                                                        </div>
                                                    </div>

                                                    <!-- Section 2: Expected Outcomes -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="false">Expected Outcomes</button>
                                                        <div class="section-content collapsed">
                                                            <div class="contextualized-outcomes">
                                                                <ul>
                                                                    ${(rec.contextualizedOutcomes || technique.outcomes).map(o => `<li>${o}</li>`).join('')}
                                                                </ul>
                                                            </div>
                                                        </div>
                                                    </div>

                                                    <!-- Section 3: Score Breakdown -->
                                                    <div class="detail-section">
                                                        <button class="section-toggle" aria-expanded="false">Score Breakdown</button>
                                                        <div class="section-content collapsed">
                                                            <div class="score-breakdown">
                                                                <div class="score-row">
                                                                    <span class="score-label">Keyword matches:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.keywordScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.keywordScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Pattern matches:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.patternScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.patternScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Phase alignment:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.phaseScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.phaseScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Timing match:</span>
                                                                    <span class="score-value ${rec.scoreBreakdown?.whenToUseScore === 0 ? 'zero' : ''}">+${rec.scoreBreakdown?.whenToUseScore || 0}</span>
                                                                </div>
                                                                <div class="score-row">
                                                                    <span class="score-label">Total:</span>
                                                                    <span class="score-value">${rec.score}</span>
                                                                </div>
                                                                ${rec.scoreBreakdown?.matchedKeywords?.length > 0 ? `
                                                                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                                                        <strong>Keywords:</strong> ${rec.scoreBreakdown.matchedKeywords.slice(0, 5).join(', ')}
                                                                    </div>
                                                                ` : ''}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div class="technique-meta">
                                                    <div class="meta-item">
                                                        <span class="meta-label">When to use:</span>
                                                        <span class="meta-value">${technique.when_to_use}</span>
                                                    </div>
                                                    <div class="meta-item">
                                                        <span class="meta-label">Resources needed:</span>
                                                        <span class="meta-value">${technique.resources_needed.join(', ')}</span>
                                                    </div>
                                                    <div class="meta-item">
                                                        <span class="meta-label">Team maturity:</span>
                                                        <span class="meta-value">${technique.team_maturity.map(level => {
                                                            if (level === 'beginner') return 'Beginner (Teams new to product discovery)';
                                                            if (level === 'intermediate') return 'Intermediate (Teams with some discovery experience)';
                                                            if (level === 'advanced') return 'Advanced (Experienced teams with mature practices)';
                                                            return level;
                                                        }).join(', ')}</span>
                                                    </div>
                                                </div>

                                                <div class="technique-source">
                                                    <small>Source: ${technique.svpg_source}</small>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p>Answer more discovery questions to get personalized coaching technique recommendations.</p>'}
                    </div>
                `;

                summaryContainer.innerHTML = html;
            }

        }

        // ============================================
        // TEST FRAMEWORK
        // ============================================
        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async runAll() {
                this.results = [];
                console.log('🧪 Starting LEA Regression Test Suite...\n');

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.results.push({ name: test.name, passed: true, error: null });
                        console.log(`✅ PASS: ${test.name}`);
                    } catch (error) {
                        this.results.push({ name: test.name, passed: false, error: error.message });
                        console.error(`❌ FAIL: ${test.name}`, error.message);
                    }
                }

                this.displayResults();
                return this.results;
            }

            displayResults() {
                const passed = this.results.filter(r => r.passed).length;
                const failed = this.results.filter(r => !r.passed).length;
                const total = this.results.length;

                console.log('\n' + '='.repeat(60));
                console.log(`📊 Test Results: ${passed}/${total} passed, ${failed} failed`);
                console.log('='.repeat(60));

                this.showResultsModal(passed, failed, total);
            }

            showResultsModal(passed, failed, total) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: white; padding: 30px; border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000;
                    max-width: 600px; max-height: 80vh; overflow-y: auto;
                `;

                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); z-index: 9999;
                `;

                const resultsHtml = `
                    <h2 style="margin-bottom: 20px;">🧪 LEA Regression Tests</h2>
                    <div style="margin-bottom: 20px;">
                        <strong>Total:</strong> ${total} tests<br>
                        <strong style="color: #4CAF50;">Passed:</strong> ${passed}<br>
                        <strong style="color: #f44336;">Failed:</strong> ${failed}
                    </div>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${this.results.map(r => `
                            <div style="padding: 8px; margin: 5px 0; background: ${r.passed ? '#e8f5e9' : '#ffebee'}; border-radius: 4px;">
                                ${r.passed ? '✅' : '❌'} ${r.name}
                                ${r.error ? `<br><small style="color: #d32f2f;">${r.error}</small>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <button id="closeTestResults" style="margin-top: 20px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                `;

                modal.innerHTML = resultsHtml;
                document.body.appendChild(overlay);
                document.body.appendChild(modal);

                document.getElementById('closeTestResults').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });

                overlay.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });
            }

            assert(condition, message) {
                if (!condition) throw new Error(message || 'Assertion failed');
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) throw new Error(message || `Expected ${expected}, got ${actual}`);
            }

            assertNotNull(value, message) {
                if (value === null || value === undefined) throw new Error(message || 'Value is null or undefined');
            }
        }

        // Initialize test framework
        const testFramework = new TestFramework();

        // Core functionality tests
        testFramework.test('All Manager Classes Initialize', () => {
            testFramework.assertNotNull(stateManager, 'StateManager should be initialized');
            testFramework.assertNotNull(tabNavigator, 'TabNavigator should be initialized');
            testFramework.assertNotNull(dataManager, 'DataManager should be initialized');
            testFramework.assertNotNull(summaryGenerator, 'SummaryGenerator should be initialized');
        });

        testFramework.test('Technique Library Loads (51 techniques)', () => {
            testFramework.assertNotNull(svpgTechniqueLibrary, 'Library should exist');
            testFramework.assertNotNull(svpgTechniqueLibrary.discovery_techniques, 'Discovery techniques exist');
            testFramework.assertNotNull(svpgTechniqueLibrary.coaching_techniques, 'Coaching techniques exist');
            testFramework.assertEqual(svpgTechniqueLibrary.total_techniques, 51, 'Should have 51 techniques');
        });

        testFramework.test('Discovery Questions Defined', () => {
            testFramework.assertNotNull(discoveryQuestions, 'Questions should be defined');
            testFramework.assertNotNull(discoveryQuestions.phase1, 'Phase 1 exists');
            testFramework.assertNotNull(discoveryQuestions.phase2, 'Phase 2 exists');
            testFramework.assertNotNull(discoveryQuestions.phase3, 'Phase 3 exists');
            testFramework.assertNotNull(discoveryQuestions.phase4, 'Phase 4 exists');
            testFramework.assertNotNull(discoveryQuestions.phase5, 'Phase 5 exists');
        });

        testFramework.test('TechniqueRecommender Class Works', () => {
            const recommender = new TechniqueRecommender();
            testFramework.assertNotNull(recommender, 'TechniqueRecommender should instantiate');

            const mockState = {
                questions: {
                    q1: { questionId: 'q1', phase: 1, status: 'answered', findings: 'no customer contact', discoveryMethods: [] }
                }
            };

            const recommendations = recommender.recommendTechniques(mockState);
            testFramework.assertNotNull(recommendations, 'Should return recommendations');
            testFramework.assertNotNull(recommendations.discovery, 'Should have discovery array');
            testFramework.assertNotNull(recommendations.coaching, 'Should have coaching array');
            testFramework.assert(Array.isArray(recommendations.discovery), 'Discovery should be array');
            testFramework.assert(Array.isArray(recommendations.coaching), 'Coaching should be array');
        });

        testFramework.test('State Manager Initializes Questions', () => {
            const state = stateManager.getState();
            testFramework.assertNotNull(state.questions, 'Questions object exists');
            const questionCount = Object.keys(state.questions).length;
            testFramework.assertEqual(questionCount, 37, 'Should have 37 questions');
        });

        testFramework.test('Export Functionality Available', () => {
            testFramework.assertNotNull(dataManager.exportToJSON, 'Export method exists');
            testFramework.assert(typeof dataManager.exportToJSON === 'function', 'Export is a function');
        });

        testFramework.test('Import Functionality Available', () => {
            testFramework.assertNotNull(dataManager.importFromJSON, 'Import method exists');
            testFramework.assert(typeof dataManager.importFromJSON === 'function', 'Import is a function');
        });

        testFramework.test('Tab Navigation Works', () => {
            testFramework.assertNotNull(tabNavigator.switchTab, 'SwitchTab method exists');
            testFramework.assertNotNull(tabNavigator.activeTab, 'Active tab property exists');
            testFramework.assert(typeof tabNavigator.switchTab === 'function', 'SwitchTab is a function');
        });

        testFramework.test('Summary Generator Works', () => {
            testFramework.assertNotNull(summaryGenerator.generateSummary, 'Generate method exists');
            testFramework.assert(typeof summaryGenerator.generateSummary === 'function', 'Generate is a function');
            testFramework.assertNotNull(summaryGenerator.extractKeyFindings, 'Extract findings method exists');
            testFramework.assertNotNull(summaryGenerator.identifyGaps, 'Identify gaps method exists');
        });

        // ============================================
        // VERSION MANAGER TESTS
        // ============================================
        testFramework.test('Version Manager Initializes', () => {
            testFramework.assertNotNull(versionManager, 'VersionManager should be initialized');
            testFramework.assertNotNull(versionManager.saveVersion, 'saveVersion method exists');
            testFramework.assertNotNull(versionManager.loadVersion, 'loadVersion method exists');
            testFramework.assertNotNull(versionManager.deleteVersion, 'deleteVersion method exists');
            testFramework.assertNotNull(versionManager.listClients, 'listClients method exists');
        });

        testFramework.test('Version Manager - Client Name Sanitization', () => {
            const sanitized1 = versionManager.sanitizeClientName('Test Client 123');
            testFramework.assertEqual(sanitized1, 'Test Client 123', 'Normal name should remain unchanged');

            const sanitized2 = versionManager.sanitizeClientName('Test@Client#$%');
            testFramework.assertEqual(sanitized2, 'TestClient', 'Special chars should be removed');

            const sanitized3 = versionManager.sanitizeClientName('   Spaces   ');
            testFramework.assertEqual(sanitized3, 'Spaces', 'Should trim whitespace');

            const sanitized4 = versionManager.sanitizeClientName('');
            testFramework.assertEqual(sanitized4, '', 'Empty string should return empty');

            const sanitized5 = versionManager.sanitizeClientName(null);
            testFramework.assertEqual(sanitized5, '', 'Null should return empty');
        });

        testFramework.test('Version Manager - Save and Load Version', () => {
            // Clean up any existing test data
            const testClientName = 'TestClient_' + Date.now();

            // Set some test state
            stateManager.updateQuestion('q1', 'findings', 'Test finding for version test');

            // Save version
            const saveResult = versionManager.saveVersion(testClientName);
            testFramework.assert(saveResult === true, 'Save should return true');

            // Check client exists
            const clients = versionManager.listClients();
            const testClient = clients.find(c => c.name === testClientName);
            testFramework.assertNotNull(testClient, 'Client should exist after save');
            testFramework.assertEqual(testClient.versionCount, 1, 'Should have 1 version');

            // Clear state and load
            stateManager.updateQuestion('q1', 'findings', '');
            const loadResult = versionManager.loadVersion(testClientName, 1);
            testFramework.assert(loadResult === true, 'Load should return true');

            // Verify state restored
            const state = stateManager.getState();
            testFramework.assertEqual(state.questions.q1.findings, 'Test finding for version test', 'Findings should be restored');

            // Clean up
            versionManager.deleteClient(testClientName);
        });

        testFramework.test('Version Manager - Multiple Versions', () => {
            const testClientName = 'TestClient_MultiVersion_' + Date.now();

            // Save first version
            stateManager.updateQuestion('q1', 'findings', 'Version 1 finding');
            versionManager.saveVersion(testClientName);

            // Save second version
            stateManager.updateQuestion('q1', 'findings', 'Version 2 finding');
            versionManager.saveVersion(testClientName);

            // Check version count
            const clients = versionManager.listClients();
            const testClient = clients.find(c => c.name === testClientName);
            testFramework.assertEqual(testClient.versionCount, 2, 'Should have 2 versions');

            // Load version 1
            versionManager.loadVersion(testClientName, 1);
            let state = stateManager.getState();
            testFramework.assertEqual(state.questions.q1.findings, 'Version 1 finding', 'Should load version 1');

            // Load version 2
            versionManager.loadVersion(testClientName, 2);
            state = stateManager.getState();
            testFramework.assertEqual(state.questions.q1.findings, 'Version 2 finding', 'Should load version 2');

            // Clean up
            versionManager.deleteClient(testClientName);
        });

        testFramework.test('Version Manager - Delete Version', () => {
            const testClientName = 'TestClient_Delete_' + Date.now();

            // Save two versions
            stateManager.updateQuestion('q1', 'findings', 'Version 1');
            versionManager.saveVersion(testClientName);
            stateManager.updateQuestion('q1', 'findings', 'Version 2');
            versionManager.saveVersion(testClientName);

            // Delete version 1
            const deleteResult = versionManager.deleteVersion(testClientName, 1);
            testFramework.assert(deleteResult === true, 'Delete should return true');

            // Check only 1 version remains
            const clients = versionManager.listClients();
            const testClient = clients.find(c => c.name === testClientName);
            testFramework.assertEqual(testClient.versionCount, 1, 'Should have 1 version after delete');

            // Clean up
            versionManager.deleteClient(testClientName);
        });

        testFramework.test('Version Manager - Storage Info', () => {
            const usage = versionManager.getStorageUsage();
            testFramework.assertNotNull(usage, 'Usage should be returned');
            testFramework.assert(typeof usage.bytes === 'number', 'Bytes should be a number');
            testFramework.assert(typeof usage.mb === 'number', 'MB should be a number');
            testFramework.assert(typeof usage.percentage === 'number', 'Percentage should be a number');
            testFramework.assert(usage.percentage >= 0, 'Percentage should be >= 0');
        });

        // ============================================
        // TRANSPARENCY & RATIONALE FEATURE TESTS
        // ============================================

        testFramework.test('TechniqueRecommender - Score Breakdown Tracking', () => {
            const recommender = new TechniqueRecommender();
            const mockState = {
                metadata: { clientName: 'TestClient' },
                questions: {
                    q1: { questionId: 'q1', text: 'Test question', findings: 'customer interviews needed', status: 'answered', phase: 1 }
                }
            };

            const techniques = recommender.getAllDiscoveryTechniques();
            const allFindings = recommender.extractAllFindings(mockState);
            const results = recommender.scoreAndRankTechniques(techniques, allFindings, mockState);

            // Check that we get results with score breakdown
            testFramework.assert(results.length > 0, 'Should return scored techniques');

            const firstResult = results[0];
            testFramework.assertNotNull(firstResult.scoreBreakdown, 'Should have scoreBreakdown');
            testFramework.assert(typeof firstResult.scoreBreakdown.keywordScore === 'number', 'keywordScore should be a number');
            testFramework.assert(typeof firstResult.scoreBreakdown.patternScore === 'number', 'patternScore should be a number');
            testFramework.assert(typeof firstResult.scoreBreakdown.phaseScore === 'number', 'phaseScore should be a number');
            testFramework.assert(typeof firstResult.scoreBreakdown.whenToUseScore === 'number', 'whenToUseScore should be a number');
        });

        testFramework.test('TechniqueRecommender - Urgency Classification', () => {
            const recommender = new TechniqueRecommender();

            // Test critical urgency (high score + blockers)
            const criticalBlockers = [{ id: 'no_customer_contact', matchedPattern: 'no customer', urgencyBoost: 'critical' }];
            const urgencyCritical = recommender.calculateUrgency(75, {}, criticalBlockers);
            testFramework.assertEqual(urgencyCritical.level, 'critical', 'Score > 70 with critical blockers should be critical');
            testFramework.assertEqual(urgencyCritical.indicator, '🔴', 'Critical should have red indicator');

            // Test important urgency (medium score)
            const urgencyImportant = recommender.calculateUrgency(50, {}, []);
            testFramework.assertEqual(urgencyImportant.level, 'important', 'Score 40-69 should be important');
            testFramework.assertEqual(urgencyImportant.indicator, '🟠', 'Important should have orange indicator');

            // Test valuable urgency (low score)
            const urgencyValuable = recommender.calculateUrgency(25, {}, []);
            testFramework.assertEqual(urgencyValuable.level, 'valuable', 'Score < 40 should be valuable');
            testFramework.assertEqual(urgencyValuable.indicator, '🟡', 'Valuable should have yellow indicator');
        });

        testFramework.test('TechniqueRecommender - QA Attribution', () => {
            const recommender = new TechniqueRecommender();
            const mockState = {
                metadata: { clientName: 'TestClient' },
                questions: {
                    q1: { questionId: 'q1', text: 'Why does this product exist?', findings: 'We need customer interviews', status: 'answered', phase: 1 },
                    q2: { questionId: 'q2', text: 'Who experiences the problem?', findings: 'Users are unclear about problem', status: 'answered', phase: 1 }
                }
            };

            const qaMap = recommender.buildQAAttributionMap(mockState);
            testFramework.assertEqual(qaMap.length, 2, 'Should have 2 Q&A entries');
            testFramework.assertEqual(qaMap[0].questionId, 'q1', 'First entry should be q1');
            testFramework.assert(qaMap[0].findings.includes('customer'), 'Findings should contain customer');
        });

        testFramework.test('TechniqueRecommender - Blocker Detection', () => {
            const recommender = new TechniqueRecommender();

            // Test with blocker pattern
            const findingsWithBlocker = 'we have no customer contact with users';
            const blockers = recommender.detectBlockers(findingsWithBlocker);
            testFramework.assert(blockers.length > 0, 'Should detect blocker');
            testFramework.assertEqual(blockers[0].id, 'no_customer_contact', 'Should detect no_customer_contact blocker');

            // Test without blocker pattern
            const findingsWithoutBlocker = 'we regularly talk to users';
            const noBlockers = recommender.detectBlockers(findingsWithoutBlocker);
            testFramework.assertEqual(noBlockers.length, 0, 'Should not detect blockers');
        });

        testFramework.test('TechniqueRecommender - Sequencing Logic', () => {
            const recommender = new TechniqueRecommender();

            // Create mock scored techniques with known dependencies
            const mockScoredTechniques = [
                { technique: { id: 'team_objective', name: 'Team Objective' }, score: 80 },
                { technique: { id: 'opportunity_assessment', name: 'Opportunity Assessment' }, score: 70 },
                { technique: { id: 'customer_interviews', name: 'Customer Interviews' }, score: 60 }
            ];

            const result = recommender.applySequencingLogic(mockScoredTechniques);

            // Check that sequencing info was added
            testFramework.assertNotNull(result[0].sequencing, 'Should have sequencing info');
            testFramework.assert(Array.isArray(result[0].sequencing.prerequisites), 'Should have prerequisites array');

            // team_objective should enable opportunity_assessment
            const teamObj = result.find(r => r.technique.id === 'team_objective');
            testFramework.assert(teamObj.sequencing.sequenceRationale.length > 0, 'team_objective should have sequence rationale');
        });

        testFramework.test('TechniqueRecommender - Contextual Rationale Generation', () => {
            const recommender = new TechniqueRecommender();
            const mockTechnique = {
                id: 'customer_interviews',
                name: 'Customer Interviews',
                outcomes: ['Deep customer understanding', 'Validated assumptions']
            };
            const mockQAContributions = [
                { questionId: 'q1', questionText: 'Who experiences the problem?', matchedTerms: ['customer', 'interviews'], points: 25 }
            ];

            const rationale = recommender.generateContextualRationale(mockTechnique, mockQAContributions, 'TestClient');

            testFramework.assert(rationale.includes('TestClient'), 'Rationale should include client name');
            testFramework.assert(rationale.includes('customer'), 'Rationale should reference matched terms');
            testFramework.assert(rationale.length > 50, 'Rationale should be meaningful length');
        });

        // Global manager variables
        let stateManager, tabNavigator, dataManager, summaryGenerator, versionManager;

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            stateManager = new QuestionStateManager();
            tabNavigator = new TabNavigator();
            dataManager = new DataManager(stateManager);
            summaryGenerator = new SummaryGenerator(stateManager);
            versionManager = new VersionManager(stateManager, dataManager);

            // Make managers globally accessible
            window.dataManager = dataManager;
            window.tabNavigator = tabNavigator;
            window.versionManager = versionManager;

            // Set default engagement date
            document.getElementById('engagementDate').value = new Date().toISOString().split('T')[0];

            // Wire up test button
            document.getElementById('runTestsBtn').addEventListener('click', () => {
                console.clear();
                testFramework.runAll();
            });
        });
    </script>
</body>
</html>
