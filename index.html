<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discovery Verification System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: white;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        header {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
            padding: 40px 50px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        h2 {
            color: #f9a825;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #f9a825;
        }

        textarea:disabled {
            background: #f5f5f5;
            color: #666;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }


        button {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(249, 168, 37, 0.4);
        }

        button:active {
            transform: translateY(0);
        }


        /* Engagement Metadata */
        .engagement-metadata {
            padding: 30px 50px;
            background: #f8f9fa;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            padding-bottom: 10px;
            border-bottom: 2px solid #ddd;
            margin-bottom: 5px;
        }

        .mode-badge {
            font-weight: 700;
            font-size: 1.1em;
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .mode-badge.edit-mode {
            background: #4caf50;
            color: white;
        }

        .mode-badge.view-mode {
            background: #2196f3;
            color: white;
        }

        .btn-mode-toggle {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #ddd;
            font-family: inherit;
            font-size: 0.95em;
            background: white;
            color: #666;
        }

        .btn-mode-toggle:hover {
            border-color: #f9a825;
            color: #f9a825;
            transform: translateY(-2px);
        }

        .engagement-metadata input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
        }

        .engagement-metadata input:focus {
            outline: none;
            border-color: #f9a825;
        }

        .engagement-metadata input:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .auto-save-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #e8f5e9;
            border: 1px solid #4caf50;
            border-radius: 6px;
            color: #2e7d32;
            font-size: 14px;
            font-weight: 500;
            animation: fadeIn 0.3s ease-in;
        }

        .auto-save-indicator.saving {
            background: #fff3e0;
            border-color: #ff9800;
            color: #e65100;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .metadata-actions {
            display: flex;
            gap: 10px;
        }

        .btn-primary, .btn-secondary {
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-family: inherit;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(249, 168, 37, 0.4);
        }

        .btn-secondary {
            background: white;
            border: 2px solid #ddd;
            color: #666;
        }

        .btn-secondary:hover {
            border-color: #f9a825;
            color: #f9a825;
            transform: translateY(-2px);
        }

        /* Dashboard */
        .dashboard-section {
            background: linear-gradient(135deg, #f9d423 0%, #ff9800 100%);
            padding: 30px;
            color: white;
        }

        .coverage-overview {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 40px;
            max-width: 100%;
            padding: 0 30px;
            align-items: center;
        }

        .overall-stats {
            display: flex;
            gap: 25px;
            align-items: center;
        }

        .stat-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 4px solid white;
        }

        .stat-content {
            text-align: center;
        }

        .percentage {
            display: block;
            font-size: 2em;
            font-weight: 700;
            line-height: 1;
        }

        .label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-top: 5px;
            display: block;
        }

        .stat-details {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
        }

        .stat-row .icon {
            font-size: 1.3em;
        }

        .phase-breakdown {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .phase-bar {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .phase-label {
            min-width: 220px;
            font-weight: 500;
            font-size: 0.95em;
        }

        .progress-bar {
            flex: 1;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: white;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .phase-count {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
        }

        /* Tab Navigation */
        .tabs-navigation {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #ddd;
            background: #f8f9fa;
            padding: 0 30px;
            overflow-x: auto;
        }

        .tab-btn {
            background: transparent;
            border: none;
            padding: 15px 20px;
            color: #666;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
            width: auto;
            font-size: 14px;
        }

        .tab-btn:hover {
            background: rgba(249, 168, 37, 0.1);
            color: #f9a825;
            transform: none;
            box-shadow: none;
        }

        .tab-btn.active {
            color: #f9a825;
            border-bottom-color: #f9a825;
            background: white;
        }

        .tab-badge {
            display: inline-block;
            background: #ddd;
            color: #666;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 8px;
            font-weight: 600;
        }

        .tab-badge.complete {
            background: #4caf50;
            color: white;
        }

        /* Phase Color Coding */
        .tab-btn[data-phase="1"].active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
        }

        .tab-btn[data-phase="2"].active {
            border-bottom-color: #10b981;
            color: #10b981;
        }

        .tab-btn[data-phase="3"].active {
            border-bottom-color: #8b5cf6;
            color: #8b5cf6;
        }

        .tab-btn[data-phase="4"].active {
            border-bottom-color: #f59e0b;
            color: #f59e0b;
        }

        .tab-btn[data-phase="5"].active {
            border-bottom-color: #ef4444;
            color: #ef4444;
        }

        /* Tab Panels */
        .tabs-content {
            padding: 0;
        }

        .tab-panel {
            display: none;
            padding: 40px 50px;
        }

        .tab-panel.active {
            display: block;
        }

        /* Question Cards */
        .question-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .question-card:hover {
            border-color: #f9a825;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .question-card[data-status="answered"] {
            border-left: 5px solid #4caf50;
        }

        .question-card[data-status="open"] {
            border-left: 5px solid #ff9800;
        }

        .question-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .question-number {
            background: #f9a825;
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 0.9em;
            min-width: 50px;
            text-align: center;
        }

        /* Phase-specific question number colors */
        .question-card[data-phase="1"] .question-number {
            background: #3b82f6;
        }

        .question-card[data-phase="2"] .question-number {
            background: #10b981;
        }

        .question-card[data-phase="3"] .question-number {
            background: #8b5cf6;
        }

        .question-card[data-phase="4"] .question-number {
            background: #f59e0b;
        }

        .question-card[data-phase="5"] .question-number {
            background: #ef4444;
        }

        .question-text {
            flex: 1;
            margin: 0;
            font-size: 1.1em;
            color: #333;
            font-weight: 600;
        }

        .status-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
        }

        .status-badge.answered {
            background: #4caf50;
            color: white;
        }

        .status-badge.open {
            background: #ff9800;
            color: white;
        }

        /* Discovery Methods Selector */
        .methods-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .method-tag {
            background: #f0f0f0;
            border: 2px solid #ddd;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            width: auto;
            font-family: inherit;
        }

        .method-tag:hover {
            background: #fff;
            border-color: #f9a825;
            transform: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .method-tag.active {
            background: #f9a825;
            border-color: #f9a825;
            color: white;
        }

        .method-tag:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .method-tag:disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: #ddd;
            background: #f5f5f5;
        }

        /* Smart Suggestion Banner */
        .suggestion-banner {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border-left: 4px solid #ffa726;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            animation: slideIn 0.3s ease-out;
        }

        .suggestion-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: #e65100;
        }

        .suggestion-icon {
            font-size: 20px;
        }

        .suggestion-list {
            margin: 0;
            padding-left: 25px;
            list-style-type: none;
        }

        .suggestion-list li {
            margin: 6px 0;
        }

        .suggestion-list li::before {
            content: "â†’ ";
            color: #ffa726;
            font-weight: bold;
            margin-right: 8px;
        }

        .suggestion-link {
            color: #1976d2;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .suggestion-link:hover {
            color: #0d47a1;
            text-decoration: underline;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes highlight {
            0%, 100% {
                background: white;
            }
            50% {
                background: #fff9c4;
            }
        }

        /* Progress Ring */
        .progress-ring {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Technique Filters */
        .technique-filters {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-label {
            font-weight: 600;
            color: #666;
            font-size: 14px;
            min-width: 70px;
        }

        .filter-btn {
            background: white;
            border: 2px solid #ddd;
            padding: 6px 14px;
            border-radius: 18px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }

        .filter-btn:hover {
            border-color: #ff6b35;
            color: #ff6b35;
        }

        .filter-btn.active {
            background: #ff6b35;
            border-color: #ff6b35;
            color: white;
        }

        .technique-card[data-filtered="true"] {
            display: none;
        }

        /* Info Tooltip */
        .info-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 6px;
        }

        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 50%;
            font-size: 12px;
            cursor: help;
            font-weight: bold;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            left: 0;
            top: 25px;
            background: #333;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            white-space: normal;
            min-width: 300px;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: opacity 0.3s, visibility 0.3s;
            font-weight: normal;
        }

        .tooltip-content::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 10px;
            border: 6px solid transparent;
            border-bottom-color: #333;
        }

        .info-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        /* Method Presets */
        .method-presets {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed #ddd;
            flex-wrap: wrap;
        }

        .preset-label {
            font-size: 0.85em;
            color: #666;
            font-weight: 500;
        }

        .preset-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        .question-body {
            margin-top: 20px;
        }

        .question-footer {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .last-updated {
            font-size: 0.85em;
            color: #999;
        }

        .btn-mark-complete {
            background: #4caf50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-mark-complete:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-mark-complete:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #9e9e9e;
        }

        .btn-mark-complete:disabled:hover {
            transform: none;
            background: #9e9e9e;
        }

        /* Empty State Banner */
        .empty-state-banner {
            background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            text-align: left;
        }

        .empty-state-icon {
            font-size: 48px;
            flex-shrink: 0;
        }

        .empty-state-content h4 {
            margin: 0 0 8px 0;
            color: #2d3748;
            font-size: 18px;
            font-weight: 600;
        }

        .empty-state-content p {
            margin: 0;
            color: #718096;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Character Counter */
        .char-counter {
            text-align: right;
            font-size: 12px;
            color: #999;
            margin-top: 4px;
            transition: color 0.2s;
        }

        .char-counter .char-count {
            font-weight: 600;
            color: #666;
        }

        .char-counter.has-content .char-count {
            color: #ff6b35;
        }

        /* Phase Navigation */
        .phase-navigation {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }

        .btn-nav {
            flex: 1;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 600;
            border: 2px solid #ff6b35;
            background: white;
            color: #ff6b35;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-nav:hover:not(:disabled) {
            background: #ff6b35;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .btn-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #ccc;
            color: #999;
        }

        .btn-nav.btn-next {
            background: #ff6b35;
            color: white;
        }

        .btn-nav.btn-next:hover:not(:disabled) {
            background: #e55a2b;
        }

        /* Summary Panel */
        .summary-panel {
            max-width: 100%;
            width: 100%;
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .summary-content {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 30px;
            min-height: 200px;
            width: 100%;
        }

        .summary-section {
            margin-bottom: 30px;
        }

        .summary-section h3 {
            color: #f9a825;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .summary-section h4 {
            color: #333;
            margin-bottom: 10px;
            margin-top: 20px;
        }

        .summary-section ul {
            list-style: none;
            padding: 0;
        }

        .summary-section li {
            padding: 10px;
            background: white;
            border-left: 3px solid #f9a825;
            margin-bottom: 8px;
            border-radius: 4px;
        }

        .gaps-list li {
            border-left-color: #ff9800;
        }

        .coaching-section {
            background: #fffde7;
            border-left: 4px solid #fbc02d;
            padding: 20px;
            margin-top: 30px;
            border-radius: 8px;
        }

        .coaching-section h3 {
            color: #f57f17;
        }

        .technique-source {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            color: #999;
            font-size: 0.9em;
        }

        .methods-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .method-stat {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #eee;
        }

        .method-stat.used {
            border-color: #4caf50;
        }

        .method-icon {
            font-size: 2em;
            display: block;
            margin-bottom: 8px;
        }

        .method-label {
            display: block;
            font-weight: 600;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .method-count {
            display: block;
            font-size: 1.5em;
            font-weight: 700;
            color: #f9a825;
        }

        .phase-insight {
            margin-bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 6px;
        }

        .phase-insight h5 {
            color: #f9a825;
            margin-bottom: 10px;
        }

        .phase-progress {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .phase-progress .progress-bar {
            background: #eee;
        }

        .phase-progress .progress-fill {
            background: #4caf50;
        }

        /* Technique Recommendations */
        .techniques-recommendations {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        .technique-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #eee;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        .technique-card:hover {
            border-color: #f9a825;
            box-shadow: 0 4px 12px rgba(249, 168, 37, 0.15);
        }

        .technique-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            gap: 15px;
            cursor: pointer;
        }

        .technique-header .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            flex-wrap: wrap;
        }

        .technique-header h4 {
            margin: 0;
            color: #333;
            font-size: 1.2em;
        }

        .collapse-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            color: #666;
            transition: transform 0.3s, color 0.2s;
        }

        .collapse-btn:hover {
            color: #ff6b35;
        }

        .technique-card[data-collapsed="true"] .collapse-btn .collapse-icon {
            transform: rotate(-90deg);
            display: inline-block;
        }

        .technique-collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
        }

        .technique-card[data-collapsed="true"] .technique-collapsible-content {
            max-height: 0;
            opacity: 0;
        }

        .technique-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
            text-transform: uppercase;
        }

        /* Discovery Technique Categories */
        .technique-badge.framing-planning {
            background: #e3f2fd;
            color: #1976d2;
        }

        .technique-badge.customer-research {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .technique-badge.ideation {
            background: #fff9c4;
            color: #f57f17;
        }

        .technique-badge.prototyping {
            background: #e8f5e9;
            color: #388e3c;
        }

        .technique-badge.usability-testing {
            background: #fff3e0;
            color: #f57c00;
        }

        .technique-badge.value-testing {
            background: #fce4ec;
            color: #c2185b;
        }

        .technique-badge.quantitative-testing {
            background: #e0f2f1;
            color: #00796b;
        }

        .technique-badge.feasibility-viability-testing {
            background: #fff9c4;
            color: #f57f17;
        }

        .technique-badge.discovery-workflows {
            background: #f1f8e9;
            color: #689f38;
        }

        .technique-badge.metrics-analysis {
            background: #e8eaf6;
            color: #3f51b5;
        }

        /* Coaching Technique Categories */
        .technique-badge.coaching,
        .technique-badge.assessment-planning,
        .technique-badge.coaching-techniques-applied,
        .technique-badge.organizational-coaching,
        .technique-badge.team-objectives-coaching {
            background: #fff3e0;
            color: #e65100;
        }

        /* Score Badge */
        .score-badge {
            background: #4caf50;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 8px;
        }

        .score-badge.coaching {
            background: #ff9800;
        }

        .technique-description {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .technique-match-reasons {
            background: #fffbf0;
            border-left: 4px solid #f9a825;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .technique-match-reasons strong {
            color: #f9a825;
            display: block;
            margin-bottom: 8px;
        }

        .technique-match-reasons ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .technique-match-reasons li {
            padding: 4px 0;
            background: none;
            border: none;
            margin: 0;
            color: #555;
        }

        .technique-meta {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .meta-item {
            margin-bottom: 10px;
        }

        .meta-item:last-child {
            margin-bottom: 0;
        }

        .meta-label {
            font-weight: 600;
            color: #666;
            display: inline-block;
            min-width: 140px;
        }

        .meta-value {
            color: #333;
        }

        .technique-outcomes {
            margin-top: 15px;
        }

        .technique-outcomes strong {
            color: #333;
            display: block;
            margin-bottom: 8px;
        }

        .technique-outcomes ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .technique-outcomes li {
            padding: 4px 0;
            background: none;
            border: none;
            margin: 0;
            color: #555;
        }

        /* Execution Guide Styles */
        .execution-guide {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .execution-steps,
        .execution-variations,
        .execution-pitfalls {
            margin-bottom: 15px;
        }

        .execution-steps:last-child,
        .execution-variations:last-child,
        .execution-pitfalls:last-child {
            margin-bottom: 0;
        }

        .execution-steps h4,
        .execution-variations h4,
        .execution-pitfalls h4 {
            color: #333;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 10px 0;
        }

        .execution-steps ol {
            margin: 0;
            padding-left: 20px;
            list-style-position: outside;
        }

        .execution-steps li {
            padding: 6px 0;
            color: #444;
            line-height: 1.6;
        }

        .execution-variations ul,
        .execution-pitfalls ul {
            margin: 0;
            padding-left: 20px;
            list-style: disc;
        }

        .execution-variations li,
        .execution-pitfalls li {
            padding: 4px 0;
            color: #555;
            line-height: 1.5;
        }

        .execution-pitfalls {
            background: #fff3cd;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #ff9800;
        }

        .execution-pitfalls h4 {
            color: #856404;
        }

        .execution-pitfalls li {
            color: #856404;
        }

        .summary-actions {
            margin-top: 30px;
            display: flex;
            gap: 15px;
        }

        /* Notifications */
        #notifications {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }

        .notification {
            background: white;
            padding: 15px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            margin-bottom: 10px;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid #4caf50;
        }

        .notification.error {
            border-left: 4px solid #f44336;
        }

        .notification.info {
            border-left: 4px solid #2196f3;
        }

        /* Responsive */
        @media (max-width: 968px) {
            .coverage-overview {
                grid-template-columns: 1fr;
                gap: 25px;
            }

            .overall-stats {
                flex-direction: column;
                text-align: center;
            }

            .tabs-navigation {
                padding: 0 15px;
            }

            .tab-btn {
                padding: 12px 15px;
                font-size: 0.85em;
            }

            .tabs-content {
                padding: 15px;
            }

            .engagement-metadata {
                flex-direction: column;
                align-items: stretch;
            }

            .metadata-actions {
                width: 100%;
            }

            .metadata-actions button {
                flex: 1;
            }

            .phase-label {
                min-width: 100px;
                font-size: 0.85em;
            }

            .question-header {
                flex-wrap: wrap;
            }

            .summary-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }

            .technique-header {
                flex-direction: column;
                gap: 10px;
            }

            .technique-badge {
                align-self: flex-start;
            }

            .meta-label {
                min-width: auto;
                display: block;
                margin-bottom: 5px;
            }

            header h1 {
                font-size: 2em;
            }
        }
        /* Comparison View */
        .comparison-view {
            background: white;
            padding: 30px;
            border-radius: 8px;
        }

        .comparison-view h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .comparison-table {
            overflow-x: auto;
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        .comparison-table td:first-child {
            font-weight: 600;
            color: #666;
            min-width: 200px;
        }

        /* Print Styles */
        @media print {
            /* Hide interactive elements */
            .metadata-actions,
            .tabs-navigation,
            .phase-navigation,
            .method-tag,
            .method-presets,
            .preset-btn,
            .btn-mark-complete,
            .collapse-btn,
            .technique-filters,
            .filter-btn,
            .info-tooltip,
            .auto-save-indicator,
            .suggestion-banner,
            button,
            input[type="date"] {
                display: none !important;
            }

            /* Show all content */
            body {
                background: white;
                padding: 0;
                margin: 0;
            }

            .container {
                max-width: 100%;
                box-shadow: none;
                border-radius: 0;
            }

            header {
                background: white;
                color: #333;
                padding: 20px;
                border-bottom: 3px solid #333;
            }

            /* Show only summary tab for printing */
            .tab-panel {
                display: none !important;
            }

            .tab-panel[data-phase="summary"] {
                display: block !important;
                padding: 20px;
            }

            /* Expand all technique cards */
            .technique-card {
                page-break-inside: avoid;
                border: 1px solid #333;
                margin-bottom: 15px;
            }

            .technique-collapsible-content {
                max-height: none !important;
                opacity: 1 !important;
                display: block !important;
            }

            .technique-card[data-filtered="true"] {
                display: block !important;
            }

            /* Remove backgrounds for print */
            .summary-section,
            .coverage-overview,
            .technique-header,
            .empty-state-banner {
                background: white !important;
            }

            /* Make text more readable */
            body, p, li, span {
                color: #000 !important;
            }

            h1, h2, h3, h4, h5 {
                color: #000 !important;
            }

            /* Page breaks */
            .summary-section {
                page-break-inside: avoid;
            }

            h3 {
                page-break-after: avoid;
            }

            /* Show metadata as header */
            .metadata-form {
                display: block;
                margin-bottom: 20px;
                padding: 10px;
                border: 1px solid #333;
            }

            .metadata-form input {
                display: inline-block !important;
                border: none;
                border-bottom: 1px solid #333;
                background: white;
                padding: 2px;
            }

            /* Technique badges */
            .technique-badge,
            .score-badge {
                border: 1px solid #333;
                background: white !important;
                color: #000 !important;
            }

            /* Simplify technique cards for printing */
            .technique-card {
                box-shadow: none;
            }

            .technique-meta {
                border-top: 1px solid #ddd;
                padding-top: 10px;
            }

            /* Footer on each page */
            @page {
                margin: 1.5cm;
                @bottom-right {
                    content: "Page " counter(page);
                }
            }
        }

        /* Session Health Tracking */
        .session-health-tracker {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            margin-left: auto;
            white-space: nowrap;
        }

        .session-health-tracker.health-good {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }

        .session-health-tracker.health-warning {
            background: #fff8e1;
            color: #f57f17;
            border: 1px solid #ffcc80;
        }

        .session-health-tracker.health-degrading {
            background: #fff3e0;
            color: #e65100;
            border: 1px solid #ffb74d;
        }

        .session-health-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .session-health-count {
            font-weight: 700;
        }

        .session-health-message {
            font-size: 0.8em;
            font-weight: 400;
            opacity: 0.9;
        }

        .btn-fresh-session {
            padding: 6px 12px !important;
            font-size: 0.85em !important;
            background: white !important;
            color: #666 !important;
            border: 1px solid #ddd !important;
            width: auto !important;
        }

        .btn-fresh-session:hover {
            border-color: #4caf50 !important;
            color: #4caf50 !important;
            background: #f1f8e9 !important;
        }

        @media print {
            .session-health-tracker {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Learning Empowered Advisor</h1>
            <p>Discovery Coaching Assistant</p>
        </header>

        <!-- Engagement Metadata -->
        <div class="engagement-metadata">
            <div id="autoSaveIndicator" class="auto-save-indicator" style="display: none;">
                <span class="save-icon">ðŸ’¾</span>
                <span class="save-text">All changes saved</span>
            </div>
            <input id="clientName" type="text" placeholder="Client Name">
            <input id="engagementDate" type="date" style="max-width: 180px;">
            <input id="coachName" type="text" placeholder="Coach Name">
            <div class="metadata-actions">
                <button id="newEngagement" class="btn-secondary">New Engagement</button>
                <button id="importBtn" class="btn-secondary">Import</button>
                <button id="compareBtn" class="btn-secondary">Compare Assessments</button>
                <button id="exportBtn" class="btn-secondary">Export JSON</button>
                <button id="exportPdfBtn" class="btn-secondary">Export PDF</button>
                <button id="runTestsBtn" class="btn-secondary">Run Tests</button>
                <button id="toggleModeBtn" class="btn-secondary">View Mode</button>
                <div id="sessionHealthTracker" class="session-health-tracker health-good">
                    <div class="session-health-content">
                        <span class="session-health-count">Session: 0 analyses</span>
                        <span class="session-health-message"></span>
                    </div>
                    <button id="freshSessionBtn" class="btn-fresh-session">Fresh Session</button>
                </div>
            </div>
        </div>

        <!-- Coverage Dashboard -->
        <div class="dashboard-section">
            <div class="coverage-overview">
                <div class="overall-stats">
                    <div class="stat-circle">
                        <div class="stat-content">
                            <span class="percentage">0%</span>
                            <span class="label">Complete</span>
                        </div>
                    </div>
                    <div class="stat-details">
                        <div class="stat-row">
                            <span class="icon">âœ“</span>
                            <span class="stat-value">0/36</span>
                            <span class="stat-label">Answered</span>
                        </div>
                        <div class="stat-row">
                            <span class="icon">â—‹</span>
                            <span class="open-count">36</span>
                            <span class="stat-label">Open</span>
                        </div>
                    </div>
                </div>

                <div class="phase-breakdown">
                    <div class="phase-bar" data-phase="1">
                        <span class="phase-label">Phase 1: Foundation & Context</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="2">
                        <span class="phase-label">Phase 2: Success & Outcomes</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="3">
                        <span class="phase-label">Phase 3: Structure & Ownership</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/4</span>
                    </div>
                    <div class="phase-bar" data-phase="4">
                        <span class="phase-label">Phase 4: Team Dynamics & Constraints</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/8</span>
                    </div>
                    <div class="phase-bar" data-phase="5">
                        <span class="phase-label">Phase 5: Untested Assumptions</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="phase-count">0/1</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Navigation -->
        <nav class="tabs-navigation">
            <button class="tab-btn active" data-phase="1">Phase 1: Foundation<span class="tab-badge">0/6</span></button>
            <button class="tab-btn" data-phase="2">Phase 2: Success<span class="tab-badge">0/10</span></button>
            <button class="tab-btn" data-phase="3">Phase 3: Structure<span class="tab-badge">0/6</span></button>
            <button class="tab-btn" data-phase="4">Phase 4: Dynamics<span class="tab-badge">0/13</span></button>
            <button class="tab-btn" data-phase="5">Phase 5: Assumptions<span class="tab-badge">0/1</span></button>
            <button class="tab-btn" data-phase="summary">Summary</button>
        </nav>

        <!-- Tab Panels -->
        <div class="tabs-content">
            <div class="tab-panel active" data-phase="1"></div>
            <div class="tab-panel" data-phase="2"></div>
            <div class="tab-panel" data-phase="3"></div>
            <div class="tab-panel" data-phase="4"></div>
            <div class="tab-panel" data-phase="5"></div>
            <div class="tab-panel" data-phase="summary">
                <div class="summary-panel">
                    <div class="summary-header">
                        <h2>Leadership Summary</h2>
                        <button id="generateSummary" class="btn-primary" disabled>Generate Summary</button>
                    </div>
                    <div id="summaryContent" class="summary-content"></div>
                </div>
            </div>
        </div>

        <!-- Hidden file input for JSON import -->
        <input type="file" id="importInput" accept=".json" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
        <input type="file" id="compareInput" accept=".json" multiple style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">

        <!-- Notifications container -->
        <div id="notifications"></div>
    </div>

    <script>
        'use strict';


        // Discovery Questions Data
        const discoveryQuestions = {
            phase1: {
                name: "Foundation & Context",
                questions: [
                    { id: "q1", text: "Why does this product exist?" },
                    { id: "q2", text: "Who actually experiences the problem we are solving?" },
                    { id: "q3", text: "How do we know this problem is worth solving now?" },
                    { id: "q4", text: "What decision are we trying to enable or change?" },
                    { id: "q22", text: "What alternatives do users have today?" },
                    { id: "q23", text: "What's been tried before and why did it fail?" }
                ]
            },
            phase2: {
                name: "Success & Outcomes",
                questions: [
                    { id: "q5", text: "What would good look like three months from now?" },
                    { id: "q6", text: "What success would look like in a (insert time period)?" },
                    { id: "q7", text: "How will we know this worked?" },
                    { id: "q8", text: "The team's relationship with metrics" },
                    { id: "q24", text: "What is the team actually measuring today?" },
                    { id: "q25", text: "Do we have baseline data to compare against?" },
                    { id: "q26", text: "Does the team have the tools/infrastructure to measure outcomes?" },
                    { id: "q27", text: "How long does it take to know if something worked?" },
                    { id: "q28", text: "How do we know our changes caused the outcome vs external factors?" },
                    { id: "q29", text: "Are we tracking leading indicators or only lagging ones?" }
                ]
            },
            phase3: {
                name: "Structure & Ownership",
                questions: [
                    { id: "q9", text: "Where product ownership actually lives today?" },
                    { id: "q10", text: "Role clarity across PO, PMs, and engineers" },
                    { id: "q11", text: "Who decides when priorities collide?" },
                    { id: "q12", text: "How intentional the backlog really is?" },
                    { id: "q30", text: "Are key stakeholders aligned on the vision and priorities?" },
                    { id: "q31", text: "How do decisions and learnings get shared across the org?" }
                ]
            },
            phase4: {
                name: "Team Dynamics & Constraints",
                questions: [
                    { id: "q13", text: "The team's and leadership's appetite for challenge vs safety" },
                    { id: "q14", text: "How much autonomy the team believes they have?" },
                    { id: "q15", text: "How the team currently defines value" },
                    { id: "q16", text: "Team's past failures or trauma (did a big project fail?)" },
                    { id: "q17", text: "Hidden stakeholders who actually control decisions" },
                    { id: "q18", text: "Budget or resource constraints that nobody talks about" },
                    { id: "q19", text: "Technical debt or system constraints limiting autonomy" },
                    { id: "q20", text: "Geographic or org structure issues (distributed teams, cross functional friction)" },
                    { id: "q32", text: "How often does the team directly interact with customers/users?" },
                    { id: "q33", text: "What external dependencies could block or delay progress?" },
                    { id: "q34", text: "How does the team currently learn and experiment?" },
                    { id: "q35", text: "Does the team have the capabilities needed for this work?" },
                    { id: "q36", text: "Are there hard external deadlines driving this work?" }
                ]
            },
            phase5: {
                name: "Untested Assumptions",
                questions: [
                    { id: "q21", text: "What assumptions are we making that we have not tested?" }
                ]
            }
        };

        // Discovery Methods
        const discoveryMethods = [
            { id: "interview", label: "Interview", icon: "ðŸ—£ï¸" },
            { id: "workshop", label: "Workshop", icon: "ðŸ‘¥" },
            { id: "observation", label: "Observation", icon: "ðŸ‘€" },
            { id: "document_review", label: "Document Review", icon: "ðŸ“„" },
            { id: "survey", label: "Survey", icon: "ðŸ“Š" },
            { id: "data_analysis", label: "Data Analysis", icon: "ðŸ“ˆ" }
        ];

        // Tab Navigator Class
        class TabNavigator {
            constructor() {
                this.activeTab = "1";
                this.setupEventListeners();
                this.initializeFromHash();
            }

            setupEventListeners() {
                document.querySelector('.tabs-navigation').addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-btn')) {
                        const phase = e.target.dataset.phase;
                        this.switchTab(phase);
                    }
                });

                // Handle browser back/forward
                window.addEventListener('hashchange', () => {
                    this.initializeFromHash();
                });
            }

            switchTab(phaseId) {
                // Remove active from all
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

                // Add active to selected
                const activeBtn = document.querySelector(`.tab-btn[data-phase="${phaseId}"]`);
                const activePanel = document.querySelector(`.tab-panel[data-phase="${phaseId}"]`);

                if (activeBtn && activePanel) {
                    activeBtn.classList.add('active');
                    activePanel.classList.add('active');
                    this.activeTab = phaseId;
                    window.location.hash = `phase-${phaseId}`;
                }
            }

            initializeFromHash() {
                if (window.location.hash) {
                    const phase = window.location.hash.replace('#phase-', '');
                    this.switchTab(phase);
                }
            }
        }

        // Question State Manager Class
        class QuestionStateManager {
            constructor() {
                this.state = this.initializeState();
                this.setupEventListeners();
                this.renderAllQuestions();
                this.updateProgress();
            }

            initializeState() {
                const today = new Date().toISOString().split('T')[0];
                const state = {
                    metadata: {
                        clientName: "",
                        engagementDate: today,
                        coach: "",
                        lastModified: ""
                    },
                    questions: {}
                };

                // Initialize all 36 questions
                Object.keys(discoveryQuestions).forEach(phaseKey => {
                    const phase = discoveryQuestions[phaseKey];
                    const phaseNum = parseInt(phaseKey.replace('phase', ''));

                    phase.questions.forEach(q => {
                        state.questions[q.id] = {
                            questionId: q.id,
                            phase: phaseNum,
                            text: q.text,
                            findings: "",
                            status: "open",
                            discoveryMethods: [],
                            notes: "",
                            lastUpdated: ""
                        };
                    });
                });

                return state;
            }

            setupEventListeners() {
                // Event delegation for all inputs
                document.addEventListener('input', (e) => {
                    if (e.target.matches('.findings-input, .notes-input')) {
                        const questionCard = e.target.closest('.question-card');
                        const questionId = questionCard.dataset.questionId;
                        const field = e.target.dataset.field;
                        this.updateQuestion(questionId, field, e.target.value);

                        // Update character counter
                        this.updateCharCounter(e.target);
                    }
                });

                document.addEventListener('click', (e) => {
                    if (e.target.matches('.method-tag')) {
                        this.toggleMethod(e.target);
                    }
                    if (e.target.matches('.btn-mark-complete')) {
                        this.toggleQuestionStatus(e.target);
                    }
                    if (e.target.matches('.btn-nav')) {
                        const targetPhase = e.target.dataset.targetPhase;
                        if (targetPhase) {
                            this.tabNavigator.switchTab(targetPhase);
                        }
                    }
                    // Handle technique card collapse
                    if (e.target.closest('.collapse-btn') || e.target.closest('.technique-header')) {
                        const header = e.target.closest('.technique-header');
                        if (header) {
                            const card = header.closest('.technique-card');
                            if (card) {
                                const isCollapsed = card.dataset.collapsed === 'true';
                                card.dataset.collapsed = isCollapsed ? 'false' : 'true';
                            }
                        }
                    }
                    // Handle method preset clicks
                    if (e.target.matches('.preset-btn')) {
                        const preset = e.target.dataset.preset;
                        const questionCard = e.target.closest('.question-card');
                        if (preset && questionCard) {
                            const methodIds = preset.split(',');
                            const questionId = questionCard.dataset.questionId;

                            // Clear existing methods first
                            this.state.questions[questionId].discoveryMethods = [];
                            questionCard.querySelectorAll('.method-tag').forEach(tag => {
                                tag.classList.remove('active');
                            });

                            // Apply preset methods
                            methodIds.forEach(methodId => {
                                const methodTag = questionCard.querySelector(`[data-method="${methodId}"]`);
                                if (methodTag) {
                                    methodTag.classList.add('active');
                                    if (!this.state.questions[questionId].discoveryMethods.includes(methodId)) {
                                        this.state.questions[questionId].discoveryMethods.push(methodId);
                                    }
                                }
                            });

                            this.showAutoSaveIndicator();
                        }
                    }
                    // Handle technique filter clicks
                    if (e.target.matches('.filter-btn')) {
                        const filterType = e.target.dataset.filterType;
                        const filterValue = e.target.dataset.filterValue;

                        // Update active state for this filter group
                        const filterGroup = e.target.closest('.filter-group');
                        filterGroup.querySelectorAll('.filter-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        e.target.classList.add('active');

                        // Apply filters
                        this.applyTechniqueFilters();
                    }
                });

                // Metadata listeners
                ['clientName', 'engagementDate', 'coachName'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('input', (e) => {
                            const key = id === 'coachName' ? 'coach' : id;
                            this.state.metadata[key] = e.target.value;
                            this.showAutoSaveIndicator();
                        });
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const cmdOrCtrl = isMac ? e.metaKey : e.ctrlKey;

                    // Cmd/Ctrl + 1-6: Switch tabs
                    if (cmdOrCtrl && e.key >= '1' && e.key <= '6') {
                        e.preventDefault();
                        const phaseMap = {
                            '1': '1', '2': '2', '3': '3',
                            '4': '4', '5': '5', '6': 'summary'
                        };
                        this.tabNavigator.switchTab(phaseMap[e.key]);
                    }

                    // Cmd/Ctrl + S: Export JSON
                    if (cmdOrCtrl && e.key === 's') {
                        e.preventDefault();
                        document.getElementById('exportBtn')?.click();
                    }

                    // Cmd/Ctrl + Enter: Generate Summary
                    if (cmdOrCtrl && e.key === 'Enter') {
                        e.preventDefault();
                        const summaryBtn = document.getElementById('generateSummary');
                        if (summaryBtn && !summaryBtn.disabled) {
                            summaryBtn.click();
                        }
                    }

                    // Cmd/Ctrl + N: New Engagement
                    if (cmdOrCtrl && e.key === 'n') {
                        e.preventDefault();
                        document.getElementById('newEngagement')?.click();
                    }
                });
            }

            updateQuestion(questionId, field, value) {
                if (!this.state.questions[questionId]) return;

                this.state.questions[questionId][field] = value;
                this.state.questions[questionId].lastUpdated = new Date().toISOString();

                // Auto-update status based on findings
                if (field === 'findings') {
                    const newStatus = value.trim().length > 0 ? 'answered' : 'open';
                    this.state.questions[questionId].status = newStatus;
                    this.updateQuestionCardStatus(questionId, newStatus);

                    // Show smart suggestions based on keywords
                    if (value.trim().length > 20) { // Only suggest if meaningful text
                        this.showSmartSuggestions(questionId, value);
                    }
                }

                this.updateProgress();
                this.showAutoSaveIndicator();
            }

            toggleMethod(methodTag) {
                methodTag.classList.toggle('active');

                const questionCard = methodTag.closest('.question-card');
                const questionId = questionCard.dataset.questionId;
                const method = methodTag.dataset.method;

                const methods = this.state.questions[questionId].discoveryMethods;
                const index = methods.indexOf(method);

                if (index > -1) {
                    methods.splice(index, 1);
                } else {
                    methods.push(method);
                }

                this.showAutoSaveIndicator();
            }

            toggleQuestionStatus(button) {
                const questionCard = button.closest('.question-card');
                const questionId = questionCard.dataset.questionId;
                const currentStatus = this.state.questions[questionId].status;

                const newStatus = currentStatus === 'open' ? 'answered' : 'open';
                this.state.questions[questionId].status = newStatus;

                this.updateQuestionCardStatus(questionId, newStatus);
                this.updateProgress();
                this.showAutoSaveIndicator();
            }

            updateQuestionCardStatus(questionId, status) {
                const card = document.querySelector(`[data-question-id="${questionId}"]`);
                if (!card) return;

                card.dataset.status = status;

                const badge = card.querySelector('.status-badge');
                badge.className = `status-badge ${status}`;
                badge.textContent = status === 'answered' ? 'âœ“ Answered' : 'â—‹ Open';

                const button = card.querySelector('.btn-mark-complete');
                button.textContent = status === 'answered' ? 'Mark as Open' : 'Mark as Answered';
            }

            calculateCoverage() {
                const total = Object.keys(this.state.questions).length;
                const answered = Object.values(this.state.questions).filter(q => q.status === 'answered').length;

                const byPhase = {};
                for (let i = 1; i <= 5; i++) {
                    const phaseQuestions = Object.values(this.state.questions).filter(q => q.phase === i);
                    const phaseAnswered = phaseQuestions.filter(q => q.status === 'answered').length;
                    byPhase[i] = {
                        total: phaseQuestions.length,
                        answered: phaseAnswered,
                        percentage: phaseQuestions.length > 0 ? (phaseAnswered / phaseQuestions.length) * 100 : 0
                    };
                }

                return {
                    overall: (answered / total) * 100,
                    answeredCount: answered,
                    totalCount: total,
                    openCount: total - answered,
                    byPhase
                };
            }

            updateProgress() {
                const coverage = this.calculateCoverage();

                // Update main stats
                const percentageEl = document.querySelector('.percentage');
                const statValueEl = document.querySelector('.stat-value');
                const openCountEl = document.querySelector('.open-count');

                if (percentageEl) percentageEl.textContent = `${coverage.overall.toFixed(0)}%`;
                if (statValueEl) statValueEl.textContent = `${coverage.answeredCount}/${coverage.totalCount}`;
                if (openCountEl) openCountEl.textContent = coverage.openCount;

                // Update phase bars
                Object.entries(coverage.byPhase).forEach(([phase, data]) => {
                    const phaseBar = document.querySelector(`.phase-bar[data-phase="${phase}"]`);
                    if (phaseBar) {
                        const fill = phaseBar.querySelector('.progress-fill');
                        const count = phaseBar.querySelector('.phase-count');
                        if (fill) fill.style.width = `${data.percentage}%`;
                        if (count) count.textContent = `${data.answered}/${data.total}`;
                    }

                    // Update tab badges
                    const tabBtn = document.querySelector(`.tab-btn[data-phase="${phase}"]`);
                    if (tabBtn) {
                        const badge = tabBtn.querySelector('.tab-badge');
                        if (badge) {
                            badge.textContent = data.percentage === 100
                                ? `${data.answered}/${data.total} âœ“`
                                : `${data.answered}/${data.total}`;
                            if (data.percentage === 100) {
                                badge.classList.add('complete');
                            } else {
                                badge.classList.remove('complete');
                            }
                        }
                    }
                });

                // Update Generate Summary button state
                this.updateSummaryButtonState(coverage.answeredCount);
            }

            updateSummaryButtonState(answeredCount) {
                const summaryBtn = document.getElementById('generateSummary');
                if (summaryBtn) {
                    if (answeredCount > 0) {
                        summaryBtn.disabled = false;
                        summaryBtn.style.cursor = 'pointer';
                        summaryBtn.style.opacity = '1';
                    } else {
                        summaryBtn.disabled = true;
                        summaryBtn.style.cursor = 'not-allowed';
                        summaryBtn.style.opacity = '0.5';
                    }
                }
            }

            showAutoSaveIndicator() {
                const indicator = document.getElementById('autoSaveIndicator');
                if (!indicator) return;

                // Show "Saving..." state
                indicator.classList.add('saving');
                indicator.querySelector('.save-text').textContent = 'Saving...';
                indicator.style.display = 'flex';

                // After 500ms, show "All changes saved"
                setTimeout(() => {
                    indicator.classList.remove('saving');
                    indicator.querySelector('.save-text').textContent = 'All changes saved';

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                }, 500);
            }

            updateCharCounter(textarea) {
                const formGroup = textarea.closest('.form-group');
                if (!formGroup) return;

                const counter = formGroup.querySelector('.char-counter');
                const charCount = counter.querySelector('.char-count');

                if (charCount) {
                    const length = textarea.value.length;
                    charCount.textContent = length;

                    // Add visual feedback for content
                    if (length > 0) {
                        counter.classList.add('has-content');
                    } else {
                        counter.classList.remove('has-content');
                    }
                }
            }

            showSmartSuggestions(currentQuestionId, text) {
                const keywords = {
                    'q2': ['customer', 'user', 'target', 'audience', 'segment'],
                    'q3': ['outcome', 'success', 'metric', 'kpi', 'measure'],
                    'q4': ['current', 'existing', 'today', 'now', 'problem'],
                    'q5': ['research', 'interview', 'test', 'data', 'evidence'],
                    'q6': ['value', 'benefit', 'worth', 'roi', 'impact'],
                    'q8': ['willing', 'pay', 'price', 'commit', 'purchase'],
                    'q9': ['build', 'technical', 'feasible', 'engineer', 'develop'],
                    'q15': ['constraint', 'limitation', 'requirement', 'must', 'compliance'],
                    'q16': ['assumption', 'believed', 'thought', 'expected', 'assumed'],
                    'q17': ['assumption', 'validated', 'tested', 'proved', 'disproved']
                };

                const textLower = text.toLowerCase();
                const suggestions = [];

                // Find matching questions
                Object.entries(keywords).forEach(([qId, words]) => {
                    if (qId !== currentQuestionId && this.state.questions[qId].status === 'open') {
                        const hasMatch = words.some(word => textLower.includes(word));
                        if (hasMatch) {
                            const question = Object.values(discoveryQuestions)
                                .flatMap(p => p.questions)
                                .find(q => q.id === qId);
                            if (question) {
                                suggestions.push({ id: qId, text: question.text });
                            }
                        }
                    }
                });

                // Show suggestion banner if we have suggestions
                const questionCard = document.querySelector(`[data-question-id="${currentQuestionId}"]`);
                if (questionCard && suggestions.length > 0) {
                    this.renderSuggestionBanner(questionCard, suggestions.slice(0, 2)); // Max 2 suggestions
                }
            }

            renderSuggestionBanner(questionCard, suggestions) {
                // Remove existing banner
                const existing = questionCard.querySelector('.suggestion-banner');
                if (existing) existing.remove();

                // Create new banner
                const banner = document.createElement('div');
                banner.className = 'suggestion-banner';
                banner.innerHTML = `
                    <div class="suggestion-header">
                        <span class="suggestion-icon">ðŸ’¡</span>
                        <strong>Related questions to consider:</strong>
                    </div>
                    <ul class="suggestion-list">
                        ${suggestions.map(s => `
                            <li>
                                <a href="#" class="suggestion-link" data-question-id="${s.id}">
                                    ${s.text}
                                </a>
                            </li>
                        `).join('')}
                    </ul>
                `;

                // Insert after question header
                const header = questionCard.querySelector('.question-header');
                header.after(banner);

                // Add click handlers
                banner.querySelectorAll('.suggestion-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const targetQId = link.dataset.questionId;
                        const targetCard = document.querySelector(`[data-question-id="${targetQId}"]`);
                        if (targetCard) {
                            targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            targetCard.style.animation = 'highlight 2s';
                            setTimeout(() => targetCard.style.animation = '', 2000);
                        }
                    });
                });
            }

            applyTechniqueFilters() {
                // Get active filter values
                const timeFilter = document.querySelector('.filter-btn[data-filter-type="time"].active')?.dataset.filterValue || 'all';
                const maturityFilter = document.querySelector('.filter-btn[data-filter-type="maturity"].active')?.dataset.filterValue || 'all';

                // Apply filters to all technique cards
                const techniqueCards = document.querySelectorAll('.technique-card[data-time]');
                techniqueCards.forEach(card => {
                    const cardTime = card.dataset.time;
                    const cardMaturity = card.dataset.maturity;

                    const timeMatch = timeFilter === 'all' || cardTime === timeFilter;
                    const maturityMatch = maturityFilter === 'all' || cardMaturity === maturityFilter;

                    // Show/hide based on filter match
                    if (timeMatch && maturityMatch) {
                        card.removeAttribute('data-filtered');
                    } else {
                        card.setAttribute('data-filtered', 'true');
                    }
                });
            }

            renderAllQuestions() {
                Object.keys(discoveryQuestions).forEach(phaseKey => {
                    const phase = discoveryQuestions[phaseKey];
                    const phaseNum = parseInt(phaseKey.replace('phase', ''));
                    const panel = document.querySelector(`.tab-panel[data-phase="${phaseNum}"]`);

                    if (panel && panel.dataset.phase !== 'summary') {
                        // Check if any questions in this phase are answered
                        const phaseQuestions = phase.questions.map(q => this.state.questions[q.id]);
                        const hasAnsweredQuestions = phaseQuestions.some(q => q && q.status === 'answered');

                        // Add empty state banner if no questions answered
                        const emptyStateBanner = !hasAnsweredQuestions ? `
                            <div class="empty-state-banner">
                                <div class="empty-state-icon">ðŸ“</div>
                                <div class="empty-state-content">
                                    <h4>No questions answered yet</h4>
                                    <p>Start filling out discovery findings below to build your assessment.</p>
                                </div>
                            </div>
                        ` : '';

                        const questionsHTML = phase.questions.map(q => this.createQuestionCardHTML(q, phaseNum)).join('');

                        // Add phase navigation buttons
                        const navigationHTML = `
                            <div class="phase-navigation">
                                <button
                                    class="btn-nav btn-prev"
                                    data-target-phase="${phaseNum - 1}"
                                    ${phaseNum === 1 ? 'disabled' : ''}
                                >
                                    â† Previous Phase
                                </button>
                                <button
                                    class="btn-nav btn-next"
                                    data-target-phase="${phaseNum === 5 ? 'summary' : phaseNum + 1}"
                                >
                                    ${phaseNum === 5 ? 'View Summary â†’' : 'Next Phase â†’'}
                                </button>
                            </div>
                        `;

                        panel.innerHTML = emptyStateBanner + questionsHTML + navigationHTML;
                    }
                });
            }

            createQuestionCardHTML(question, phase) {
                const qNum = parseInt(question.id.replace('q', ''));
                const exampleText = this.getQuestionExample(question.id);

                return `
                    <div class="question-card" data-question-id="${question.id}" data-phase="${phase}" data-status="open">
                        <div class="question-header">
                            <span class="question-number">Q${qNum}</span>
                            <h3 class="question-text">${question.text}</h3>
                            <span class="status-badge open">â—‹ Open</span>
                        </div>

                        <div class="question-body">
                            <div class="form-group">
                                <label>
                                    Findings
                                    <span class="info-tooltip">
                                        <span class="info-icon">â“˜</span>
                                        <span class="tooltip-content">${exampleText}</span>
                                    </span>
                                </label>
                                <textarea
                                    class="findings-input"
                                    data-field="findings"
                                    rows="6"
                                    placeholder="What did you discover about this question?"
                                ></textarea>
                                <div class="char-counter">
                                    <span class="char-count">0</span> characters
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Discovery Methods Used</label>
                                <div class="methods-selector">
                                    ${discoveryMethods.map(m => `
                                        <button type="button" class="method-tag" data-method="${m.id}">
                                            ${m.icon} ${m.label}
                                        </button>
                                    `).join('')}
                                </div>
                                <div class="method-presets">
                                    <span class="preset-label">Quick select:</span>
                                    <button type="button" class="preset-btn" data-preset="interview,document_review" title="Interview + Document Review">
                                        Standard Interview
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="workshop,observation" title="Workshop + Observation">
                                        Workshop Session
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="survey,data_analysis" title="Survey + Data Analysis">
                                        Data Research
                                    </button>
                                    <button type="button" class="preset-btn" data-preset="observation,interview" title="Observation + Interview">
                                        Field Study
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Additional Notes</label>
                                <textarea
                                    class="notes-input"
                                    data-field="notes"
                                    rows="3"
                                    placeholder="Any additional context or observations..."
                                ></textarea>
                                <div class="char-counter">
                                    <span class="char-count">0</span> characters
                                </div>
                            </div>

                            <div class="question-footer">
                                <span class="last-updated"></span>
                                <button type="button" class="btn-mark-complete">Mark as Answered</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            getQuestionExample(questionId) {
                const examples = {
                    'q1': '<strong>Example:</strong> "To solve customer payment friction and increase conversion by 15%"',
                    'q2': '<strong>Example:</strong> "B2B SaaS companies with 50-500 employees struggling with manual invoice processing"',
                    'q3': '<strong>Example:</strong> "Reduce invoice processing time from 2 hours to 15 minutes per invoice"',
                    'q4': '<strong>Example:</strong> "Customers currently use Excel spreadsheets, taking 2+ hours per invoice with frequent errors"',
                    'q5': '<strong>Example:</strong> "Interviewed 8 customers, observed 5 live invoice processing sessions, analyzed 200+ support tickets"',
                    'q6': '<strong>Example:</strong> "Automation saves 90+ minutes per invoice, 40% reduction in errors, ROI achieved in 3 months"',
                    'q7': '<strong>Example:</strong> "Finance managers struggle most with manual data entry and error correction"',
                    'q8': '<strong>Example:</strong> "All 8 interviewed customers confirmed willingness to pay $199/month for this solution"',
                    'q9': '<strong>Example:</strong> "Needs OCR technology, integration with QuickBooks/Xero, requires 2 engineers for 3 months"',
                    'q10': '<strong>Example:</strong> "Product Manager owns success, works with 2 engineers and 1 designer"',
                    'q11': '<strong>Example:</strong> "PM makes feature decisions, needs approval for pricing changes over $50/month"',
                    'q12': '<strong>Example:</strong> "PM, Lead Engineer, Designer meet weekly for discovery; stakeholder review monthly"',
                    'q13': '<strong>Example:</strong> "Team works well together, designer new to discovery process, needs coaching"',
                    'q14': '<strong>Example:</strong> "Weekly 2-hour discovery sessions, PM does 3 customer interviews per week"',
                    'q15': '<strong>Example:</strong> "Must integrate with Salesforce (executive mandate), GDPR compliance required for EU customers"',
                    'q16': '<strong>Example:</strong> "Assumed customers want mobile app - testing showed 90% prefer desktop for invoice processing"',
                    'q17': '<strong>Example:</strong> "Assumed OCR needs 99% accuracy - customers accept 95% if faster and cheaper"',
                    'q18': '<strong>Example:</strong> "Testing showed complex UI confused users - simplified version increased task completion by 60%"',
                    'q19': '<strong>Example:</strong> "Believed customers wanted full automation - interviews revealed they want human oversight"',
                    'q20': '<strong>Example:</strong> "Thought pricing should be per-user - customers strongly prefer per-invoice pricing"',
                    'q21': '<strong>Example:</strong> "Built custom OCR engine - could have used existing API for 10x lower cost and faster delivery"'
                };
                return examples[questionId] || '<strong>Example:</strong> "Describe what you discovered from customer research, interviews, or data analysis"';
            }

            getState() {
                return this.state;
            }

            setState(newState) {
                this.state = newState;
                this.renderAllQuestions();

                // Restore form values
                Object.entries(newState.questions).forEach(([qId, q]) => {
                    const card = document.querySelector(`[data-question-id="${qId}"]`);
                    if (!card) return;

                    const findingsInput = card.querySelector('.findings-input');
                    const notesInput = card.querySelector('.notes-input');

                    if (findingsInput) {
                        findingsInput.value = q.findings || '';
                        this.updateCharCounter(findingsInput);
                    }
                    if (notesInput) {
                        notesInput.value = q.notes || '';
                        this.updateCharCounter(notesInput);
                    }

                    // Restore method selections
                    q.discoveryMethods.forEach(method => {
                        const methodTag = card.querySelector(`[data-method="${method}"]`);
                        if (methodTag) methodTag.classList.add('active');
                    });

                    // Update status
                    this.updateQuestionCardStatus(qId, q.status);
                });

                // Restore metadata
                if (newState.metadata) {
                    document.getElementById('clientName').value = newState.metadata.clientName || '';
                    document.getElementById('engagementDate').value = newState.metadata.engagementDate || '';
                    document.getElementById('coachName').value = newState.metadata.coach || '';
                }

                this.updateProgress();

                // Re-apply current mode after restoring state
                if (window.viewModeManager) {
                    window.viewModeManager.applyMode();
                }
            }
        }

        // Data Manager Class
        class DataManager {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportToJSON();
                });

                document.getElementById('exportPdfBtn').addEventListener('click', () => {
                    this.exportToPDF();
                });

                document.getElementById('compareBtn').addEventListener('click', () => {
                    document.getElementById('compareInput').click();
                });

                document.getElementById('compareInput').addEventListener('change', (e) => {
                    this.compareAssessments(e.target.files);
                });

                document.getElementById('importBtn').addEventListener('click', (e) => {
                    console.log('Import button clicked');
                    const fileInput = document.getElementById('importInput');
                    if (!fileInput) {
                        console.error('File input element not found!');
                        return;
                    }
                    console.log('Triggering file input click...');
                    try {
                        fileInput.click();
                        console.log('File input click triggered');
                    } catch (error) {
                        console.error('Error triggering file input:', error);
                    }
                });

                document.getElementById('importInput').addEventListener('change', (e) => {
                    console.log('File selected:', e.target.files[0]?.name);
                    if (e.target.files && e.target.files[0]) {
                        this.importFromJSON(e.target.files[0]);
                    } else {
                        console.error('No file selected');
                    }
                });

                document.getElementById('newEngagement').addEventListener('click', () => {
                    this.newEngagement();
                });
            }

            exportToJSON() {
                const state = this.stateManager.getState();
                const coverage = this.stateManager.calculateCoverage();

                // Generate technique recommendations
                const techniqueRecommender = new TechniqueRecommender();
                const recommendations = techniqueRecommender.recommendTechniques(state);

                // Extract findings
                const findings = Object.values(state.questions)
                    .filter(q => q.status === 'answered' && q.findings.trim())
                    .map(q => ({
                        questionId: q.questionId,
                        phase: q.phase,
                        question: q.text,
                        findings: q.findings,
                        notes: q.notes,
                        discoveryMethods: q.discoveryMethods,
                        lastUpdated: q.lastUpdated
                    }));

                // Identify gaps
                const gaps = Object.values(state.questions)
                    .filter(q => q.status === 'open' || !q.findings.trim())
                    .map(q => ({
                        questionId: q.questionId,
                        phase: q.phase,
                        question: q.text
                    }));

                // Analyze methods used
                const methodsUsed = {};
                discoveryMethods.forEach(m => {
                    methodsUsed[m.id] = {
                        label: m.label,
                        icon: m.icon,
                        count: 0
                    };
                });

                Object.values(state.questions).forEach(q => {
                    q.discoveryMethods.forEach(method => {
                        if (methodsUsed[method]) {
                            methodsUsed[method].count++;
                        }
                    });
                });

                // Phase-by-phase insights
                const phaseInsights = {};
                for (let phase = 1; phase <= 5; phase++) {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phase);
                    const answered = phaseQuestions.filter(q => q.status === 'answered');

                    phaseInsights[`phase${phase}`] = {
                        name: discoveryQuestions[`phase${phase}`].name,
                        total: phaseQuestions.length,
                        answered: answered.length,
                        percentage: phaseQuestions.length > 0 ? (answered.length / phaseQuestions.length) * 100 : 0
                    };
                }

                // Build enhanced export data (v2.0)
                const exportData = {
                    version: "2.0",
                    exportDate: new Date().toISOString(),
                    metadata: state.metadata,
                    questions: Object.values(state.questions),
                    analysis: {
                        coverage: {
                            totalQuestions: coverage.totalCount,
                            answeredQuestions: coverage.answeredCount,
                            completionPercentage: coverage.overall
                        },
                        findings: findings,
                        gaps: gaps,
                        discoveryMethods: methodsUsed,
                        phaseInsights: phaseInsights,
                        recommendedTechniques: {
                            discovery: (recommendations.discovery || []).map(rec => {
                                const mapping = techniqueExecutionMappings[rec.technique.id];
                                return {
                                    name: rec.technique.name,
                                    category: rec.technique.category,
                                    description: rec.technique.description,
                                    whenToUse: rec.technique.when_to_use,
                                    timeCommitment: rec.technique.time_commitment,
                                    resourcesNeeded: rec.technique.resources_needed,
                                    teamMaturity: rec.technique.team_maturity,
                                    outcomes: rec.technique.outcomes,
                                    matchScore: rec.score,
                                    matchReasons: rec.matchReasons,
                                    svpgSource: rec.technique.svpg_source,
                                    executionGuidance: mapping ? {
                                        steps: mapping.howToExecute.steps,
                                        variations: mapping.howToExecute.variations,
                                        commonPitfalls: mapping.howToExecute.commonPitfalls
                                    } : null
                                };
                            }),
                            coaching: (recommendations.coaching || []).map(rec => {
                                const mapping = techniqueExecutionMappings[rec.technique.id];
                                return {
                                    name: rec.technique.name,
                                    category: rec.technique.category,
                                    description: rec.technique.description,
                                    whenToUse: rec.technique.when_to_use,
                                    timeCommitment: rec.technique.time_commitment,
                                    resourcesNeeded: rec.technique.resources_needed,
                                    teamMaturity: rec.technique.team_maturity,
                                    outcomes: rec.technique.outcomes,
                                    matchScore: rec.score,
                                    matchReasons: rec.matchReasons,
                                    svpgSource: rec.technique.svpg_source,
                                    executionGuidance: mapping ? {
                                        steps: mapping.howToExecute.steps,
                                        variations: mapping.howToExecute.variations,
                                        commonPitfalls: mapping.howToExecute.commonPitfalls
                                    } : null
                                };
                            })
                        },
                        rankedSpecificTechniques: (() => {
                            // Phase 2: Add ranked specific techniques for top 3 approaches
                            const ranker = new TechniqueRanker(state);
                            const topApproaches = (recommendations.discovery || []).slice(0, 3);

                            return topApproaches.map(rec => {
                                const approachKey = rec.technique.id;
                                const techniqueIds = approachToTechniqueMappings[approachKey];

                                if (!techniqueIds || techniqueIds.length === 0) {
                                    return {
                                        approach: rec.technique.name,
                                        approachScore: rec.score,
                                        techniques: []
                                    };
                                }

                                const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);

                                return {
                                    approach: rec.technique.name,
                                    approachScore: rec.score,
                                    whyRecommended: rec.matchReasons.slice(0, 2),
                                    techniques: rankedTechniques.map((tech, index) => ({
                                        rank: index + 1,
                                        name: tech.name,
                                        score: tech.score,
                                        rankLabel: getRankLabel(index, tech.score),
                                        rankIcon: getRankIcon(index, tech.score),
                                        category: tech.category,
                                        description: tech.description,
                                        whenToUse: tech.when_to_use,
                                        timeCommitment: tech.time_commitment,
                                        teamMaturity: tech.team_maturity,
                                        resourcesNeeded: tech.resources_needed,
                                        pros: tech.pros,
                                        cons: tech.cons,
                                        quickStart: tech.quick_start,
                                        matchReasons: tech.matchReasons,
                                        outcomes: tech.outcomes
                                    }))
                                };
                            });
                        })(),
                        comparisonMatrices: (() => {
                            // Phase 3: Add comparison matrices for top 3 approaches
                            const ranker = new TechniqueRanker(state);
                            const topApproaches = (recommendations.discovery || []).slice(0, 3);

                            return topApproaches.map(rec => {
                                const approachKey = rec.technique.id;
                                const techniqueIds = approachToTechniqueMappings[approachKey];

                                if (!techniqueIds || techniqueIds.length === 0) {
                                    return {
                                        approach: rec.technique.name,
                                        approachScore: rec.score,
                                        matrices: []
                                    };
                                }

                                const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);
                                const matrixBuilder = new ComparisonMatrixBuilder(rankedTechniques);

                                // Export all 4 sort versions
                                const matrices = {};
                                ['relevance', 'speed', 'cost', 'effort'].forEach(sortBy => {
                                    const sorted = matrixBuilder.sortMatrix(sortBy);
                                    matrices[sortBy] = {
                                        sortExplanation: matrixBuilder.getSortExplanation(sortBy),
                                        techniques: sorted.map((tech, index) => ({
                                            rank: index + 1,
                                            name: tech.name,
                                            score: tech.score,
                                            timeCommitment: tech.timeCommitment,
                                            timeInDays: tech.timeInDays,
                                            teamMaturity: tech.teamMaturity,
                                            maturityComplexity: tech.maturityComplexity,
                                            resourceCost: tech.resourceCost,
                                            keyStrength: tech.keyStrength,
                                            bestWhen: tech.bestWhen,
                                            resourcesNeeded: tech.resourcesNeeded,
                                            quickStart: tech.quickStart
                                        }))
                                    };
                                });

                                return {
                                    approach: rec.technique.name,
                                    approachScore: rec.score,
                                    whyRecommended: rec.matchReasons.slice(0, 2),
                                    matrices: matrices
                                };
                            });
                        })()
                    }
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                const clientName = state.metadata.clientName || 'Unknown';
                const sanitized = clientName.replace(/[^a-z0-9]/gi, '-').substring(0, 50);
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `Discovery-v2-${sanitized}-${dateStr}.json`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                // Increment session health counter on export
                if (window.sessionHealthManager) {
                    window.sessionHealthManager.increment();
                }

                this.showNotification('Enhanced discovery data (v2.0) exported successfully', 'success');
            }

            async exportToPDF() {
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    const state = this.stateManager.getState();
                    const coverage = this.stateManager.calculateCoverage();

                    // Title
                    doc.setFontSize(20);
                    doc.text('Discovery Assessment Report', 20, 20);

                    // Metadata
                    doc.setFontSize(12);
                    doc.text(`Client: ${state.metadata.clientName || 'N/A'}`, 20, 35);
                    doc.text(`Date: ${state.metadata.engagementDate || 'N/A'}`, 20, 42);
                    doc.text(`Coach: ${state.metadata.coach || 'N/A'}`, 20, 49);

                    // Coverage
                    doc.setFontSize(14);
                    doc.text('Overall Coverage', 20, 65);
                    doc.setFontSize(11);
                    doc.text(`${coverage.answeredCount}/${coverage.totalCount} questions answered (${coverage.overall.toFixed(1)}%)`, 20, 73);

                    let yPos = 85;

                    // Key Findings
                    doc.setFontSize(14);
                    doc.text('Key Findings', 20, yPos);
                    yPos += 10;
                    doc.setFontSize(10);

                    Object.entries(state.questions).forEach(([qId, q]) => {
                        if (q.findings && q.findings.trim()) {
                            const questionText = Object.values(discoveryQuestions)
                                .flatMap(p => p.questions)
                                .find(quest => quest.id === qId)?.text || qId;

                            // Check if we need a new page
                            if (yPos > 270) {
                                doc.addPage();
                                yPos = 20;
                            }

                            doc.setFont(undefined, 'bold');
                            const wrappedQuestion = doc.splitTextToSize(questionText, 170);
                            doc.text(wrappedQuestion, 20, yPos);
                            yPos += wrappedQuestion.length * 5 + 3;

                            doc.setFont(undefined, 'normal');
                            const wrappedFindings = doc.splitTextToSize(q.findings.substring(0, 200), 170);
                            doc.text(wrappedFindings, 20, yPos);
                            yPos += wrappedFindings.length * 5 + 8;
                        }
                    });

                    // Save PDF
                    const fileName = `discovery-assessment-${state.metadata.clientName || 'export'}-${new Date().toISOString().split('T')[0]}.pdf`;
                    doc.save(fileName);

                    this.showNotification('PDF exported successfully', 'success');
                } catch (error) {
                    console.error('PDF export error:', error);
                    this.showNotification('Failed to export PDF: ' + error.message, 'error');
                }
            }

            importFromJSON(file) {
                if (!file) {
                    console.error('No file provided to importFromJSON');
                    return;
                }

                console.log('Starting import of file:', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        console.log('File read successfully, parsing JSON...');
                        const importedData = JSON.parse(e.target.result);
                        console.log('JSON parsed successfully:', importedData);

                        // Validate version (support v1.0 and v2.0)
                        const version = importedData.version || "1.0";
                        console.log('File version:', version);
                        if (version !== "1.0" && version !== "2.0") {
                            throw new Error(`Unsupported file version: ${version}`);
                        }

                        // Reconstruct state
                        const newState = {
                            metadata: importedData.metadata || {},
                            questions: {}
                        };

                        console.log('Converting questions array to object...');
                        importedData.questions.forEach(q => {
                            newState.questions[q.questionId] = q;
                        });
                        console.log('New state constructed:', newState);

                        console.log('Calling setState...');
                        this.stateManager.setState(newState);
                        console.log('setState completed');

                        // Show appropriate notification based on version
                        const versionInfo = version === "2.0" ? " (v2.0 with analysis)" : "";
                        this.showNotification(`Discovery data${versionInfo} imported successfully - Switched to View Mode`, 'success');

                        // If v2.0, log analysis data (optional - can be used later)
                        if (version === "2.0" && importedData.analysis) {
                            console.log('Imported analysis data:', importedData.analysis);
                            console.log('Recommended techniques:', importedData.analysis.recommendedTechniques);
                            // Analysis is available but we regenerate it on demand via Summary tab
                        }

                        // Switch to view mode after import (safety measure)
                        if (window.viewModeManager) {
                            setTimeout(() => {
                                window.viewModeManager.setMode(true);
                            }, 100);
                        }

                    } catch (error) {
                        console.error('Import error:', error);
                        this.showNotification('Error importing file: ' + error.message, 'error');
                    }
                };

                reader.onerror = () => {
                    this.showNotification('Error reading file', 'error');
                };

                reader.readAsText(file);
                // Reset file input
                document.getElementById('importInput').value = '';
            }

            async compareAssessments(files) {
                if (!files || files.length === 0) return;

                try {
                    const assessments = [];

                    // Read all files
                    for (let file of files) {
                        const data = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                try {
                                    const parsed = JSON.parse(e.target.result);
                                    resolve(parsed);
                                } catch (error) {
                                    reject(error);
                                }
                            };
                            reader.onerror = reject;
                            reader.readAsText(file);
                        });
                        assessments.push(data);
                    }

                    // Generate comparison view
                    this.showComparisonView(assessments);
                    this.showNotification(`Comparing ${assessments.length} assessments`, 'success');

                } catch (error) {
                    this.showNotification('Error comparing assessments: ' + error.message, 'error');
                }

                // Reset file input
                document.getElementById('compareInput').value = '';
            }

            showComparisonView(assessments) {
                // Switch to summary tab
                this.stateManager.tabNavigator.switchTab('summary');

                // Create comparison table
                const summaryContainer = document.getElementById('summaryContent');

                const comparisonHTML = `
                    <div class="comparison-view">
                        <h3>Assessment Comparison</h3>
                        <div class="comparison-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Metric</th>
                                        ${assessments.map((a, i) => `<th>${a.metadata?.clientName || `Assessment ${i + 1}`}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Date</strong></td>
                                        ${assessments.map(a => `<td>${a.metadata?.engagementDate || 'N/A'}</td>`).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Questions Answered</strong></td>
                                        ${assessments.map(a => {
                                            const answered = Object.values(a.questions || {}).filter(q => q.status === 'answered').length;
                                            const total = Object.keys(a.questions || {}).length;
                                            return `<td>${answered}/${total}</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Completion %</strong></td>
                                        ${assessments.map(a => {
                                            const answered = Object.values(a.questions || {}).filter(q => q.status === 'answered').length;
                                            const total = Object.keys(a.questions || {}).length;
                                            const percent = total > 0 ? ((answered / total) * 100).toFixed(1) : 0;
                                            return `<td><strong>${percent}%</strong></td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Discovery Methods Used</strong></td>
                                        ${assessments.map(a => {
                                            const methods = new Set();
                                            Object.values(a.questions || {}).forEach(q => {
                                                q.discoveryMethods?.forEach(m => methods.add(m));
                                            });
                                            return `<td>${methods.size} different methods</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 1 (Foundation)</strong></td>
                                        ${assessments.map(a => {
                                            const phase1Qs = Object.entries(a.questions || {}).filter(([id]) => ['q1', 'q2', 'q3'].includes(id));
                                            const answered = phase1Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/3</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 2 (Success)</strong></td>
                                        ${assessments.map(a => {
                                            const phase2Qs = Object.entries(a.questions || {}).filter(([id]) => ['q4', 'q5', 'q6', 'q7', 'q8'].includes(id));
                                            const answered = phase2Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/5</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 3 (Structure)</strong></td>
                                        ${assessments.map(a => {
                                            const phase3Qs = Object.entries(a.questions || {}).filter(([id]) => ['q9', 'q10', 'q11', 'q12'].includes(id));
                                            const answered = phase3Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/4</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 4 (Team Dynamics)</strong></td>
                                        ${assessments.map(a => {
                                            const phase4Qs = Object.entries(a.questions || {}).filter(([id]) => ['q13', 'q14', 'q15'].includes(id));
                                            const answered = phase4Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/3</td>`;
                                        }).join('')}
                                    </tr>
                                    <tr>
                                        <td><strong>Phase 5 (Assumptions)</strong></td>
                                        ${assessments.map(a => {
                                            const phase5Qs = Object.entries(a.questions || {}).filter(([id]) => ['q16', 'q17', 'q18', 'q19', 'q20', 'q21'].includes(id));
                                            const answered = phase5Qs.filter(([,q]) => q.status === 'answered').length;
                                            return `<td>${answered}/6</td>`;
                                        }).join('')}
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <button id="closeComparison" class="btn-secondary" style="margin-top: 20px;">Close Comparison</button>
                    </div>
                `;

                summaryContainer.innerHTML = comparisonHTML;

                // Add close button handler
                document.getElementById('closeComparison').addEventListener('click', () => {
                    this.summaryGenerator.generateSummary();
                });
            }

            newEngagement() {
                const hasData = Object.values(this.stateManager.state.questions).some(q =>
                    q.findings || q.notes || q.discoveryMethods.length > 0
                );

                if (hasData) {
                    const confirmed = confirm(
                        'You have unsaved changes. Do you want to export before starting a new engagement?'
                    );
                    if (confirmed) {
                        this.exportToJSON();
                        setTimeout(() => this.resetState(), 500);
                    } else {
                        this.resetState();
                    }
                } else {
                    this.resetState();
                }
            }

            resetState() {
                this.stateManager.setState(this.stateManager.initializeState());
                document.querySelector('.tab-btn').click();
                this.showNotification('New engagement started', 'info');
            }

            showNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;

                const container = document.getElementById('notifications');
                container.appendChild(notification);

                setTimeout(() => notification.classList.add('show'), 10);

                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }

        // ============================================================================
        // TECHNIQUE LIBRARY - 50 Comprehensive Techniques
        // Source: SVPG Masterclass December 2025 + SVPG Research
        // ============================================================================
        const svpgTechniqueLibrary = {
            "library_version": "1.0",
            "last_updated": "2025-12-25",
            "source": "SVPG Masterclass December 2025 + SVPG Research",
            "total_techniques": 50,

            "discovery_techniques": {

                "framing_and_planning": [
                    {
                        "id": "team_objective",
                        "name": "Team Objective",
                        "category": "Framing & Planning",
                        "description": "Frame work as outcomes and problems to solve rather than features to build. Answer: What problem? Who for? How measure success?",
                        "when_to_use": "At the start of any significant product work to align team on objectives and outcomes",
                        "time_commitment": "1-2 hours",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager"],
                        "outcomes": [
                            "Clear problem definition",
                            "Alignment on target market",
                            "Defined success metrics",
                            "Shift from output to outcome thinking"
                        ],
                        "matching_criteria": {
                            "keywords": ["unclear objectives", "feature factory", "no clear goal", "what are we solving", "misalignment"],
                            "discovery_patterns": ["team doesn't know why", "building features not outcomes", "no success metrics"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "pr_faq",
                        "name": "PR/FAQ (Working Backwards)",
                        "category": "Framing & Planning",
                        "description": "Write a fake press release describing customer outcomes and benefits. Forces thinking in terms of benefits over features.",
                        "when_to_use": "For significant new products or features where you need to work backwards from desired customer outcome",
                        "time_commitment": "3-5 hours for initial draft, iteration over 1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer"],
                        "outcomes": [
                            "Customer-centric product vision",
                            "Clear articulation of benefits",
                            "Alignment on customer value",
                            "FAQ addresses key concerns"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer outcome", "benefits", "value proposition", "work backwards"],
                            "discovery_patterns": ["unclear value", "feature-focused", "need customer perspective"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "opportunity_assessment",
                        "name": "Opportunity Assessment",
                        "category": "Framing & Planning",
                        "description": "Structured framework answering 4 questions: business objective, key results, customer problem, target market",
                        "when_to_use": "When evaluating whether an opportunity is worth pursuing, need to validate business viability",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager"],
                        "outcomes": [
                            "Clear business objective",
                            "Defined success metrics",
                            "Validated customer problem",
                            "Go/no-go decision framework"
                        ],
                        "matching_criteria": {
                            "keywords": ["business case", "opportunity", "should we build", "validate idea", "stakeholder alignment"],
                            "discovery_patterns": ["jumping to solutions", "unclear business value", "leadership asking for justification"],
                            "phase_indicators": [1, 2, 3]
                        },
                        "svpg_source": "SVPG Articles"
                    },
                    {
                        "id": "lean_canvas",
                        "name": "Lean Canvas / Product Canvas",
                        "category": "Framing & Planning",
                        "description": "Map hypotheses and assumptions across all aspects of product. Surface what needs to be tested.",
                        "when_to_use": "For all-new product efforts or true startups to map unknowns",
                        "time_commitment": "2-4 hours initial, ongoing refinement",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Tech Lead"],
                        "outcomes": [
                            "Identified assumptions",
                            "Clear hypotheses to test",
                            "Risk areas highlighted",
                            "Shared understanding of unknowns"
                        ],
                        "matching_criteria": {
                            "keywords": ["startup", "new product", "assumptions", "hypotheses", "unknowns"],
                            "discovery_patterns": ["many unknowns", "greenfield", "unvalidated assumptions"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "journey_map",
                        "name": "Journey Map",
                        "category": "Framing & Planning",
                        "description": "Customer-centric map of entire end-to-end experience. Visualize holistic experience, clarify ownership, uncover pain points.",
                        "when_to_use": "To understand complete customer experience, identify pain points, test new concepts",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "User Researcher"],
                        "outcomes": [
                            "Holistic view of experience",
                            "Identified pain points",
                            "Moments that matter highlighted",
                            "Clear ownership boundaries"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer journey", "end-to-end", "pain points", "experience", "touchpoints"],
                            "discovery_patterns": ["fragmented experience", "unclear user flow", "ownership gaps"],
                            "phase_indicators": [1, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "opportunity_solution_tree",
                        "name": "Opportunity Solution Tree",
                        "category": "Framing & Planning",
                        "description": "Before jumping to solutions, map various ways you might attack the problem. Consider alternatives.",
                        "when_to_use": "When you have a clear problem but need to explore solution space systematically",
                        "time_commitment": "1-2 days",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Engineer"],
                        "outcomes": [
                            "Multiple solution approaches identified",
                            "Exploration before commitment",
                            "Team alignment on options",
                            "Evidence-based solution selection"
                        ],
                        "matching_criteria": {
                            "keywords": ["solutions", "alternatives", "options", "explore", "compare approaches"],
                            "discovery_patterns": ["jumping to first solution", "narrow thinking", "need options"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "customer_research": [
                    {
                        "id": "customer_discovery_program",
                        "name": "Customer Discovery Program",
                        "category": "Customer Research",
                        "description": "Recruit 6-8 'earlyvangelist' customers for deep engagement. Goal: single solution all 6 love. Defines product/market fit.",
                        "when_to_use": "For B2B products or significant new features requiring deep customer partnership",
                        "time_commitment": "2-6 months",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "dedicated time for customer engagement"],
                        "outcomes": [
                            "6-8 reference customers",
                            "Product/market fit validation",
                            "Deep customer relationships",
                            "Case studies and testimonials"
                        ],
                        "matching_criteria": {
                            "keywords": ["reference customers", "early adopters", "b2b", "customer partnership", "validation"],
                            "discovery_patterns": ["need customer commitment", "b2b product", "require testimonials"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "customer_interviews",
                        "name": "Customer Interviews",
                        "category": "Customer Research",
                        "description": "Qualitative discussions with customers to discover opportunities. Pro tip: bring engineer along.",
                        "when_to_use": "You can never do too many. Essential for understanding customer problems and needs.",
                        "time_commitment": "1-2 hours per interview, ongoing practice",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "ideally + Engineer"],
                        "outcomes": [
                            "Deep problem understanding",
                            "Opportunity discovery",
                            "Validated assumptions",
                            "Customer empathy"
                        ],
                        "matching_criteria": {
                            "keywords": ["customer needs", "understand users", "talk to customers", "interviews", "research"],
                            "discovery_patterns": ["haven't talked to customers", "assumptions", "need user insights"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "concierge_testing",
                        "name": "Concierge Testing",
                        "category": "Customer Research",
                        "description": "Do customer's job on their behalf to spot opportunities to better solve problems. Manual service delivery.",
                        "when_to_use": "Early validation before building anything. Understand workflow intimately.",
                        "time_commitment": "1-4 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager or team member to deliver service"],
                        "outcomes": [
                            "Deep workflow understanding",
                            "Identified opportunities",
                            "Validated value hypothesis",
                            "Customer relationships built"
                        ],
                        "matching_criteria": {
                            "keywords": ["manual testing", "service workflow", "understand process", "concierge"],
                            "discovery_patterns": ["complex workflow", "unclear solution", "need deep understanding"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "ideation": [
                    {
                        "id": "private_hackathon",
                        "name": "Private Hackathon",
                        "category": "Ideation",
                        "description": "Dedicated period where normal work stops and people pursue their own ideas.",
                        "when_to_use": "To unlock team creativity, explore new directions, boost morale",
                        "time_commitment": "1-3 days",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Full team participation", "leadership buy-in"],
                        "outcomes": [
                            "Innovative ideas surfaced",
                            "Team engagement increased",
                            "Unexpected solutions discovered",
                            "Improved morale"
                        ],
                        "matching_criteria": {
                            "keywords": ["innovation", "hackathon", "team ideas", "creativity", "exploration"],
                            "discovery_patterns": ["team wants to innovate", "stagnant ideas", "low morale"],
                            "phase_indicators": [1, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "customer_misbehavior",
                        "name": "Customer Misbehavior",
                        "category": "Ideation",
                        "description": "Intentionally enable product use in unintended ways. Many exceptional ideas come from this.",
                        "when_to_use": "When you want to discover unexpected use cases and opportunities",
                        "time_commitment": "Ongoing observation",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Data analysis", "Customer observation"],
                        "outcomes": [
                            "Unexpected use cases discovered",
                            "New product opportunities",
                            "Innovation from user creativity",
                            "Market expansion possibilities"
                        ],
                        "matching_criteria": {
                            "keywords": ["unexpected usage", "workarounds", "creative use", "unintended"],
                            "discovery_patterns": ["users hacking product", "creative workarounds", "off-label use"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "prototyping": [
                    {
                        "id": "user_prototype",
                        "name": "User Prototype",
                        "category": "Prototyping",
                        "description": "Simulation of user experience requiring no engineering. Quick iteration tool for designers and PMs.",
                        "when_to_use": "Rapid internal iteration and user testing before engineering investment",
                        "time_commitment": "Hours to days",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager"],
                        "outcomes": [
                            "Rapid iteration",
                            "User feedback before coding",
                            "Validated usability",
                            "Reduced engineering waste"
                        ],
                        "matching_criteria": {
                            "keywords": ["prototype", "mockup", "test design", "usability", "iterate"],
                            "discovery_patterns": ["need quick validation", "test with users", "before engineering"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "feasibility_prototype",
                        "name": "Feasibility Prototype",
                        "category": "Prototyping",
                        "description": "Created by/for engineers to tackle technical risks. Rarely resembles final product. Speed of learning over reuse.",
                        "when_to_use": "When facing technical unknowns or risks that need validation",
                        "time_commitment": "Days to weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Engineers"],
                        "outcomes": [
                            "Technical feasibility validated",
                            "Technical approach proven",
                            "Risk reduction",
                            "Implementation confidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["technical risk", "feasibility", "can we build", "engineering", "proof of concept"],
                            "discovery_patterns": ["technical unknowns", "new technology", "performance concerns"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "live_data_prototype",
                        "name": "Live-Data Prototype",
                        "category": "Prototyping",
                        "description": "Working functionality with live data for quick usage data collection. Not fully productized.",
                        "when_to_use": "When you need real usage data quickly with actual users and live data",
                        "time_commitment": "1-3 weeks",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Engineers", "Product Manager"],
                        "outcomes": [
                            "Real usage data",
                            "Quantitative validation",
                            "Live traffic testing",
                            "Fast iteration with real data"
                        ],
                        "matching_criteria": {
                            "keywords": ["live data", "real users", "a/b test", "quantitative", "production"],
                            "discovery_patterns": ["need real data", "test at scale", "quantitative validation"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "hybrid_prototype",
                        "name": "Hybrid Prototype",
                        "category": "Prototyping",
                        "description": "Blend any prototyping techniques based on particular risks and experiments.",
                        "when_to_use": "When facing multiple types of risks requiring different validation approaches",
                        "time_commitment": "Varies based on combination",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Designer", "Engineer", "Product Manager"],
                        "outcomes": [
                            "Multiple risks addressed",
                            "Flexible validation approach",
                            "Efficient testing",
                            "Comprehensive evidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["multiple risks", "combination", "complex validation", "hybrid"],
                            "discovery_patterns": ["value and feasibility risks", "multiple unknowns", "comprehensive testing"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "wizard_of_oz",
                        "name": "Wizard of Oz Testing",
                        "category": "Prototyping",
                        "description": "Manually simulate functionality behind the scenes while users interact with seemingly automated interface.",
                        "when_to_use": "Test concept without building technology. Validate value before engineering investment.",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager", "team to operate behind scenes"],
                        "outcomes": [
                            "Concept validated without code",
                            "Value proven before building",
                            "User behavior understood",
                            "Reduced engineering risk"
                        ],
                        "matching_criteria": {
                            "keywords": ["manual backend", "simulate", "fake automation", "test without building"],
                            "discovery_patterns": ["expensive to build", "uncertain value", "need quick validation"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Research + Masterclass mention"
                    }
                ],

                "usability_testing": [
                    {
                        "id": "usability_testing",
                        "name": "Usability Testing",
                        "category": "Usability Testing",
                        "description": "Observe users performing specific tasks. May be in-person/virtual, supervised/unsupervised.",
                        "when_to_use": "Test if users can figure out how to use the solution",
                        "time_commitment": "1-2 weeks (recruit + test)",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Designer", "Product Manager", "5-8 test users"],
                        "outcomes": [
                            "Usability issues identified",
                            "Task completion validated",
                            "User mental models understood",
                            "Design improvements identified"
                        ],
                        "matching_criteria": {
                            "keywords": ["usability", "can users use", "interface", "confusion", "user testing"],
                            "discovery_patterns": ["users struggling", "complex interface", "unclear navigation"],
                            "phase_indicators": [1, 2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "qualitative_value_testing",
                        "name": "User Testing (Qualitative Value)",
                        "category": "Value Testing",
                        "description": "Expansion of usability testing with deeper engagement on value topic. Reveals unexpected insights.",
                        "when_to_use": "When you need to understand not just if they can use it, but if they find it valuable",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "5-8 test users"],
                        "outcomes": [
                            "Value perception understood",
                            "Willingness to use validated",
                            "Pain points quantified",
                            "Unexpected insights discovered"
                        ],
                        "matching_criteria": {
                            "keywords": ["value", "will they use", "worth it", "pay for", "qualitative"],
                            "discovery_patterns": ["uncertain value", "will users care", "worth using"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "value_testing": [
                    {
                        "id": "fake_door_test",
                        "name": "Fake Door Test",
                        "category": "Value Testing",
                        "description": "Measure interaction with feature control for functionality not yet built.",
                        "when_to_use": "Test demand for feature before building it",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "basic implementation"],
                        "outcomes": [
                            "Demand validated",
                            "Click-through rate measured",
                            "Interest quantified",
                            "Build decision informed"
                        ],
                        "matching_criteria": {
                            "keywords": ["demand", "fake door", "feature interest", "would they use"],
                            "discovery_patterns": ["uncertain demand", "test interest", "before building"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "landing_page_test",
                        "name": "Landing Page Test",
                        "category": "Value Testing",
                        "description": "Drive traffic to pitch page for non-existent product, measure conversion on call-to-action.",
                        "when_to_use": "Validate market demand before building product",
                        "time_commitment": "1-3 weeks",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Marketing"],
                        "outcomes": [
                            "Market demand validated",
                            "Conversion rate measured",
                            "Value proposition tested",
                            "Customer acquisition cost estimated"
                        ],
                        "matching_criteria": {
                            "keywords": ["landing page", "demand", "market test", "conversion", "interest"],
                            "discovery_patterns": ["new product", "market validation", "will they pay"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "explainer_video",
                        "name": "Explainer Video",
                        "category": "Value Testing",
                        "description": "Create video of prototype and measure conversion on call-to-action.",
                        "when_to_use": "Communicate value proposition when product is complex or visual",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Video production"],
                        "outcomes": [
                            "Value communicated visually",
                            "Interest measured",
                            "Conversion tracked",
                            "Concept validation"
                        ],
                        "matching_criteria": {
                            "keywords": ["explainer", "video", "complex product", "visual", "demonstrate value"],
                            "discovery_patterns": ["hard to explain", "visual product", "need demonstration"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "value_assessment_framework",
                        "name": "Assessing Value (Time/Reputation/Cash/Behavior)",
                        "category": "Value Testing",
                        "description": "Framework: Time (trial), Reputation (NPS, referrals), Cash (pre-order, LOI), Behavior (active switch from incumbent)",
                        "when_to_use": "Systematically assess if customers truly value the solution",
                        "time_commitment": "Ongoing measurement",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Analytics"],
                        "outcomes": [
                            "Value signals measured",
                            "Customer commitment validated",
                            "Real intent vs stated intent",
                            "Investment justification"
                        ],
                        "matching_criteria": {
                            "keywords": ["value", "commitment", "will they pay", "switch", "intent"],
                            "discovery_patterns": ["uncertain commitment", "stated vs actual intent", "validate value"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "preorder_campaign",
                        "name": "Pre-order Campaign",
                        "category": "Value Testing",
                        "description": "Ask customers to commit money before product exists. Ultimate value validation.",
                        "when_to_use": "When you need strongest signal of value - actual payment commitment",
                        "time_commitment": "2-4 weeks",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Product Manager", "Marketing", "Sales", "Legal"],
                        "outcomes": [
                            "Payment commitment secured",
                            "Value definitively validated",
                            "Revenue de-risked",
                            "Early adopters identified"
                        ],
                        "matching_criteria": {
                            "keywords": ["pre-order", "payment", "commit money", "pay before", "advance purchase"],
                            "discovery_patterns": ["need revenue validation", "will they pay", "financial commitment"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Research"
                    }
                ],

                "quantitative_testing": [
                    {
                        "id": "ab_testing",
                        "name": "A/B Testing",
                        "category": "Quantitative Testing",
                        "description": "Use live traffic to compare quantitative outcomes for innovation/optimization vs baseline.",
                        "when_to_use": "When you need statistically significant proof that something works",
                        "time_commitment": "1-4 weeks depending on traffic",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Engineers", "Data Analyst", "Product Manager"],
                        "outcomes": [
                            "Statistical significance achieved",
                            "Quantitative impact measured",
                            "Baseline comparison",
                            "Data-driven decisions"
                        ],
                        "matching_criteria": {
                            "keywords": ["a/b test", "quantitative", "measure impact", "statistics", "data-driven"],
                            "discovery_patterns": ["need proof", "measure impact", "optimization", "compare options"],
                            "phase_indicators": [2, 3]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "feasibility_viability_testing": [
                    {
                        "id": "stakeholder_testing",
                        "name": "Stakeholder Testing",
                        "category": "Viability Testing",
                        "description": "Product walkthrough with key stakeholders to uncover constraints (legal, compliance, sales, etc.).",
                        "when_to_use": "Before significant investment, ensure solution works for all business functions",
                        "time_commitment": "1-2 weeks",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "time from stakeholders"],
                        "outcomes": [
                            "Business constraints identified",
                            "Stakeholder concerns addressed",
                            "Viability risks surfaced",
                            "Cross-functional alignment"
                        ],
                        "matching_criteria": {
                            "keywords": ["stakeholders", "constraints", "legal", "compliance", "sales", "viability"],
                            "discovery_patterns": ["need stakeholder buy-in", "business constraints", "compliance requirements"],
                            "phase_indicators": [3, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "premortem_gtm_testing",
                        "name": "Pre-mortem GTM Assumptions Testing",
                        "category": "Viability Testing",
                        "description": "Give extended product team opportunity to express all functional concerns early in discovery.",
                        "when_to_use": "Before committing to solution, surface all potential failures",
                        "time_commitment": "1-2 days",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Extended product team", "Product Manager"],
                        "outcomes": [
                            "Hidden risks surfaced",
                            "Functional concerns addressed",
                            "Failure modes identified",
                            "Risk mitigation planned"
                        ],
                        "matching_criteria": {
                            "keywords": ["pre-mortem", "gtm", "go to market", "risks", "what could fail"],
                            "discovery_patterns": ["need risk assessment", "complex launch", "many dependencies"],
                            "phase_indicators": [3, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "discovery_workflows": [
                    {
                        "id": "discovery_sprints",
                        "name": "Discovery Sprints",
                        "category": "Discovery Workflow",
                        "description": "Time-boxed intensive discovery: amorphous problem to user-tested solution in one week.",
                        "when_to_use": "Teams new to discovery, working on something big, or moving too slow",
                        "time_commitment": "1 week (5 days)",
                        "team_maturity": ["beginner", "intermediate", "advanced"],
                        "resources_needed": ["Full product team (PM, Designer, Engineers)"],
                        "outcomes": [
                            "Rapid progress on hard problems",
                            "Team learns discovery process",
                            "Tested solution in days not months",
                            "Momentum and confidence"
                        ],
                        "matching_criteria": {
                            "keywords": ["discovery sprint", "design sprint", "one week", "rapid", "learn discovery"],
                            "discovery_patterns": ["slow progress", "new to discovery", "big problem", "need structure"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "continuous_discovery",
                        "name": "Continuous Discovery (Weekly Cadence)",
                        "category": "Discovery Workflow",
                        "description": "Ongoing practice of weekly customer interaction and testing, not a phase.",
                        "when_to_use": "Establish sustainable discovery practice for empowered teams",
                        "time_commitment": "Ongoing - weekly rhythm",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product team commitment", "access to customers"],
                        "outcomes": [
                            "Continuous learning",
                            "Reduced feature failure rate",
                            "Faster iteration",
                            "Customer-informed decisions"
                        ],
                        "matching_criteria": {
                            "keywords": ["continuous", "weekly", "ongoing", "cadence", "habit"],
                            "discovery_patterns": ["want ongoing practice", "reduce failure rate", "build muscle"],
                            "phase_indicators": [1, 2, 4]
                        },
                        "svpg_source": "SVPG Masterclass 2025 + Research"
                    },
                    {
                        "id": "assumption_testing",
                        "name": "Assumption Testing",
                        "category": "Discovery Workflow",
                        "description": "Systematically identify assumptions and design experiments to validate/invalidate them.",
                        "when_to_use": "When you have many untested assumptions that could sink the product",
                        "time_commitment": "Ongoing throughout discovery",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Designer", "Engineer"],
                        "outcomes": [
                            "Assumptions surfaced",
                            "Risky assumptions tested first",
                            "Evidence-based decisions",
                            "Risk reduction"
                        ],
                        "matching_criteria": {
                            "keywords": ["assumptions", "hypotheses", "validate", "test", "unknowns"],
                            "discovery_patterns": ["many assumptions", "high risk", "untested beliefs"],
                            "phase_indicators": [1, 5]
                        },
                        "svpg_source": "SVPG Research"
                    }
                ],

                "metrics_and_analysis": [
                    {
                        "id": "heart_metrics",
                        "name": "HEART Metrics",
                        "category": "Metrics & Analysis",
                        "description": "Taxonomy of KPIs for measuring product experience quality: Happiness, Engagement, Adoption, Retention, Task Success",
                        "when_to_use": "Establish comprehensive product health measurement framework",
                        "time_commitment": "1-2 weeks to establish",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Product Manager", "Data Analyst", "Engineering for instrumentation"],
                        "outcomes": [
                            "Comprehensive metrics framework",
                            "Product health visibility",
                            "Leading indicators identified",
                            "Objective success measurement"
                        ],
                        "matching_criteria": {
                            "keywords": ["metrics", "kpis", "product health", "measurement", "happiness", "engagement"],
                            "discovery_patterns": ["no metrics", "unclear success", "need measurement framework"],
                            "phase_indicators": [2]
                        },
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ]
            },

            "coaching_techniques": {
                "assessment_and_planning": [
                    {
                        "id": "coach_assessment",
                        "name": "Coaching Assessment",
                        "category": "Coaching - Assessment",
                        "description": "Help employee become great, NOT performance evaluation. Combine with self-assessment and 360.",
                        "when_to_use": "Starting a coaching relationship, periodic check-ins",
                        "time_commitment": "2-4 hours",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach time", "Assessment frameworks"],
                        "outcomes": [
                            "Baseline understanding of capabilities",
                            "Development areas identified",
                            "Strengths recognized",
                            "Growth plan foundation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_plan",
                        "name": "Coaching Plan",
                        "category": "Coaching - Planning",
                        "description": "Gap analysis approach: develop weaknesses, leverage strengths, consider their goals.",
                        "when_to_use": "After assessment, create personalized development plan",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach time", "Clear development framework"],
                        "outcomes": [
                            "Personalized development plan",
                            "Clear growth objectives",
                            "Skill development priorities",
                            "Career progression path"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "coaching_techniques_applied": [
                    {
                        "id": "six_page_narrative",
                        "name": "6-Page Written Narrative",
                        "category": "Coaching - Thinking",
                        "description": "Tool for framing decisions and forcing deep thinking. Actual prose vs PowerPoint bullets. Includes conclusion, analysis, alternatives, objections.",
                        "when_to_use": "For major decisions, strategic thinking, developing communication skills",
                        "time_commitment": "1-2 weeks for individual to write",
                        "team_maturity": ["advanced"],
                        "resources_needed": ["Time for writing and iteration"],
                        "outcomes": [
                            "Deep strategic thinking",
                            "Clear communication developed",
                            "Thorough analysis",
                            "Confidence in decisions"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_time_management",
                        "name": "Coaching Time Management",
                        "category": "Coaching - Execution",
                        "description": "Help team make time for discovery. Leverage delivery manager and manager support.",
                        "when_to_use": "When team claims no time for discovery work",
                        "time_commitment": "1-2 sessions",
                        "team_maturity": ["all"],
                        "resources_needed": ["Calendar review", "Manager partnership"],
                        "outcomes": [
                            "Time found for discovery",
                            "Priorities clarified",
                            "Delegation identified",
                            "Discovery becomes practice"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_discovery",
                        "name": "Coaching Product Discovery",
                        "category": "Coaching - Discovery",
                        "description": "Guide through: clear problem understanding, outcome definition, risk evaluation, strategies for addressing risks, necessary collaboration.",
                        "when_to_use": "Teaching teams how to do discovery work",
                        "time_commitment": "Ongoing over months",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Coach time", "Discovery frameworks"],
                        "outcomes": [
                            "Team learns discovery practice",
                            "Risk-based approach adopted",
                            "Collaboration improved",
                            "Independence developed"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "coaching_decisions",
                        "name": "Coaching Decisions",
                        "category": "Coaching - Execution",
                        "description": "Coach on: understanding a decision, right-sizing, collaboration, handling disagreements.",
                        "when_to_use": "When team struggles with decision-making",
                        "time_commitment": "Per decision",
                        "team_maturity": ["all"],
                        "resources_needed": ["Coach guidance"],
                        "outcomes": [
                            "Better decisions made",
                            "Appropriate collaboration",
                            "Productive disagreement",
                            "Decision confidence"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "organizational_coaching": [
                    {
                        "id": "setting_team_topology",
                        "name": "Setting Team Topology",
                        "category": "Coaching - Organization",
                        "description": "Structure teams to optimize for empowerment",
                        "when_to_use": "Organizational design or redesign",
                        "time_commitment": "Weeks to months",
                        "team_maturity": ["all"],
                        "resources_needed": ["Leadership partnership", "Organizational authority"],
                        "outcomes": [
                            "Empowered team structure",
                            "Clear ownership boundaries",
                            "Reduced dependencies",
                            "Autonomous teams"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "pilot_teams",
                        "name": "Pilot Teams",
                        "category": "Coaching - Transformation",
                        "description": "Fully transform small number of teams rather than partially transform many.",
                        "when_to_use": "Starting transformation, proving new model works",
                        "time_commitment": "3-6 months per pilot",
                        "team_maturity": ["all"],
                        "resources_needed": ["Committed teams", "Leadership support", "Coach time"],
                        "outcomes": [
                            "Proof points established",
                            "Success stories created",
                            "Learning from early teams",
                            "Momentum for transformation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "outcome_based_roadmap",
                        "name": "Outcome-Based Roadmap",
                        "category": "Coaching - Transition",
                        "description": "Transitional solution: annotate roadmaps with desired business results, measure actual vs hoped-for outcomes.",
                        "when_to_use": "Transitioning from feature roadmaps to outcomes",
                        "time_commitment": "Quarterly updates",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Product Manager", "Leadership buy-in"],
                        "outcomes": [
                            "Outcome thinking introduced",
                            "Results measured",
                            "Conversation shifted",
                            "Bridge to full transformation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ],

                "team_objectives_coaching": [
                    {
                        "id": "team_objectives_empowerment",
                        "name": "Team Objectives - Empowerment",
                        "category": "Coaching - Objectives",
                        "description": "Coach teams to be assigned problems rather than features.",
                        "when_to_use": "Shifting from feature teams to empowered teams",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["beginner", "intermediate"],
                        "resources_needed": ["Coach support", "Leadership alignment"],
                        "outcomes": [
                            "Problem-focused teams",
                            "Empowerment established",
                            "Ownership of outcomes",
                            "Innovation enabled"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_ambition",
                        "name": "Team Objectives - Ambition",
                        "category": "Coaching - Objectives",
                        "description": "Coach on setting ambition level: 10% vs 10x, roofshot vs moonshot, 80% vs 20% confidence.",
                        "when_to_use": "Setting team objectives and key results",
                        "time_commitment": "Quarterly",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Coach guidance", "Leadership support"],
                        "outcomes": [
                            "Appropriate stretch established",
                            "Innovation encouraged",
                            "Realistic expectations",
                            "Team motivation"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_commitments",
                        "name": "Team Objectives - Commitments",
                        "category": "Coaching - Objectives",
                        "description": "Distinguish high-integrity commitments (major promises) from keep-the-lights-on work.",
                        "when_to_use": "Managing team commitments and expectations",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["intermediate", "advanced"],
                        "resources_needed": ["Trust between team and leadership"],
                        "outcomes": [
                            "Clear commitment framework",
                            "Appropriate promises",
                            "Trust established",
                            "Delivery predictability"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    },
                    {
                        "id": "team_objectives_management",
                        "name": "Team Objectives - Management",
                        "category": "Coaching - Objectives",
                        "description": "Coach on cadence (quarterly planning), progress tracking (weekly), early escalation, accountability.",
                        "when_to_use": "Establishing team objectives discipline",
                        "time_commitment": "Ongoing",
                        "team_maturity": ["all"],
                        "resources_needed": ["Management systems", "Coach support"],
                        "outcomes": [
                            "Rhythm established",
                            "Progress visible",
                            "Early problem surfacing",
                            "Accountability clear"
                        ],
                        "svpg_source": "SVPG Masterclass 2025"
                    }
                ]
            }
        };

        // Technique Recommender Class
        class TechniqueRecommender {
            constructor() {
                // No initialization needed
            }

            /**
             * Get all discovery techniques from the library
             */
            getAllDiscoveryTechniques() {
                const techniques = [];

                // Load all discovery techniques from all categories
                Object.values(svpgTechniqueLibrary.discovery_techniques).forEach(category => {
                    techniques.push(...category);
                });

                return techniques;
            }

            /**
             * Get all coaching techniques from the library
             */
            getAllCoachingTechniques() {
                const techniques = [];

                // Load all coaching techniques from all categories
                Object.values(svpgTechniqueLibrary.coaching_techniques).forEach(category => {
                    techniques.push(...category);
                });

                return techniques;
            }

            /**
             * Analyze discovery findings and recommend techniques
             * @param {Object} state - The current state with all questions
             * @param {String} type - 'discovery' or 'coaching' or 'all'
             * @returns {Object} - Discovery and Coaching recommendations
             */
            recommendTechniques(state, type = 'all') {
                // Extract all findings text
                const allFindings = this.extractAllFindings(state);

                if (!allFindings || allFindings.trim().length === 0) {
                    return { discovery: [], coaching: [] };
                }

                const result = {
                    discovery: [],
                    coaching: []
                };

                // Recommend discovery techniques
                if (type === 'all' || type === 'discovery') {
                    result.discovery = this.scoreAndRankTechniques(
                        this.getAllDiscoveryTechniques(),
                        allFindings,
                        state
                    ).slice(0, 10); // Top 10 discovery techniques
                }

                // Recommend coaching techniques
                if (type === 'all' || type === 'coaching') {
                    result.coaching = this.scoreAndRankTechniques(
                        this.getAllCoachingTechniques(),
                        allFindings,
                        state
                    ).slice(0, 5); // Top 5 coaching techniques
                }

                return result;
            }

            /**
             * Score and rank techniques based on findings
             */
            scoreAndRankTechniques(techniques, allFindings, state) {
                const scoredTechniques = techniques.map(technique => {
                    let score = 0;
                    const matchReasons = [];

                    // Match using the new matching_criteria
                    if (technique.matching_criteria) {
                        // Keyword matching
                        technique.matching_criteria.keywords.forEach(keyword => {
                            if (allFindings.toLowerCase().includes(keyword.toLowerCase())) {
                                score += 10;
                                matchReasons.push(`Detected: "${keyword}"`);
                            }
                        });

                        // Discovery pattern matching (higher weight)
                        technique.matching_criteria.discovery_patterns.forEach(pattern => {
                            if (allFindings.toLowerCase().includes(pattern.toLowerCase())) {
                                score += 15;
                                matchReasons.push(`Discovery findings align with: "${pattern}"`);
                            }
                        });

                        // Phase indicator matching
                        const phaseMatch = this.matchPhaseIndicators(state, technique.matching_criteria.phase_indicators);
                        score += phaseMatch.score;
                        if (phaseMatch.reason) {
                            matchReasons.push(phaseMatch.reason);
                        }
                    }

                    // When to use matching
                    const whenToUseMatch = this.matchWhenToUse(allFindings, technique.when_to_use);
                    score += whenToUseMatch.score;
                    if (whenToUseMatch.reason) {
                        matchReasons.push(whenToUseMatch.reason);
                    }

                    return {
                        technique,
                        score,
                        matchReasons: this.deduplicateReasons(matchReasons)
                    };
                });

                // Filter and sort
                return scoredTechniques
                    .filter(t => t.score > 0)
                    .sort((a, b) => b.score - a.score);
            }

            /**
             * Extract all findings text from answered questions
             */
            extractAllFindings(state) {
                const findings = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'answered' && q.findings.trim()) {
                        findings.push(q.findings);
                    }
                    if (q.notes && q.notes.trim()) {
                        findings.push(q.notes);
                    }
                });

                return findings.join(' ').toLowerCase();
            }

            /**
             * Match findings against technique situations
             */
            matchSituations(findings, situations) {
                let score = 0;
                const reasons = [];

                situations.forEach(situation => {
                    const situationLower = situation.toLowerCase();

                    // Check for exact phrase match (high value)
                    if (findings.includes(situationLower)) {
                        score += 15;
                        reasons.push(`Your discovery reveals: "${situation}"`);
                    } else {
                        // Check for partial word matches
                        const situationWords = situationLower.split(/\s+/).filter(w => w.length > 3);
                        const matchingWords = situationWords.filter(word => findings.includes(word));

                        if (matchingWords.length >= 3) {
                            score += 8;
                            reasons.push(`Discovery findings align with: "${situation}"`);
                        } else if (matchingWords.length >= 2) {
                            score += 4;
                        }
                    }
                });

                return { score, reasons };
            }

            /**
             * Match findings against when_to_use description
             */
            matchWhenToUse(findings, whenToUse) {
                const whenToUseLower = whenToUse.toLowerCase();
                let score = 0;
                let reason = null;

                // Check for significant overlap with when_to_use
                const whenToUseWords = whenToUseLower.split(/\s+/).filter(w => w.length > 4);
                const matchingWords = whenToUseWords.filter(word => findings.includes(word));

                if (matchingWords.length >= 5) {
                    score = 12;
                    reason = `Timing is right: ${whenToUse}`;
                } else if (matchingWords.length >= 3) {
                    score = 6;
                } else if (matchingWords.length >= 2) {
                    score = 3;
                }

                return { score, reason };
            }

            /**
             * Match technique against phase indicators
             * Checks if questions in indicated phases have issues/gaps
             */
            matchPhaseIndicators(state, phaseIndicators) {
                let score = 0;
                let reason = null;

                if (!phaseIndicators || phaseIndicators.length === 0) {
                    return { score: 0, reason: null };
                }

                // Check which phases have gaps or issues
                const phaseGaps = [];
                phaseIndicators.forEach(phaseNum => {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phaseNum);
                    const unanswered = phaseQuestions.filter(q => q.status === 'open').length;

                    if (unanswered > 0) {
                        score += 5;
                        phaseGaps.push(`Phase ${phaseNum}`);
                    }
                });

                if (phaseGaps.length > 0) {
                    reason = `Addresses gaps in: ${phaseGaps.join(', ')}`;
                }

                return { score, reason };
            }

            /**
             * DEPRECATED - kept for backwards compatibility
             * Score technique based on keyword matches
             */
            scoreByKeywords(findings, technique) {
                let score = 0;

                // Define impactful keywords for different categories
                const keywordMappings = {
                    discovery: ['customer', 'users', 'research', 'insights', 'understand', 'problem', 'validate'],
                    strategy: ['direction', 'vision', 'alignment', 'priorities', 'goals', 'objectives'],
                    validation: ['test', 'validate', 'experiment', 'prototype', 'verify', 'proof'],
                    collaboration: ['stakeholder', 'alignment', 'communication', 'trust', 'partnership'],
                    process: ['workflow', 'process', 'agile', 'sprint', 'delivery'],
                    team: ['autonomy', 'ownership', 'empowered', 'decision']
                };

                const categoryKeywords = keywordMappings[technique.category.toLowerCase()] || [];

                categoryKeywords.forEach(keyword => {
                    if (findings.includes(keyword)) {
                        score += 2;
                    }
                });

                return score;
            }

            /**
             * Remove duplicate or very similar reasons
             */
            deduplicateReasons(reasons) {
                const unique = [];

                reasons.forEach(reason => {
                    const isDuplicate = unique.some(existing =>
                        existing.toLowerCase() === reason.toLowerCase() ||
                        existing.includes(reason) ||
                        reason.includes(existing)
                    );

                    if (!isDuplicate) {
                        unique.push(reason);
                    }
                });

                return unique.slice(0, 3); // Limit to top 3 reasons
            }
        }

        // Summary Generator Class
        class SummaryGenerator {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.techniqueRecommender = new TechniqueRecommender();
                this.setupEventListeners();
            }

            setupEventListeners() {
                const btn = document.getElementById('generateSummary');
                if (btn) {
                    btn.addEventListener('click', () => {
                        this.generateSummary();
                    });
                }
            }

            generateSummary() {
                const btn = document.getElementById('generateSummary');
                const originalText = btn.textContent;

                // Show loading state with progress ring
                btn.disabled = true;
                btn.innerHTML = '<span class="progress-ring"></span> Generating...';
                btn.style.cursor = 'wait';
                btn.style.opacity = '0.7';

                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    const state = this.stateManager.getState();
                    const coverage = this.stateManager.calculateCoverage();

                    // Get recommendations (returns {discovery: [], coaching: []})
                    const recommendations = this.techniqueRecommender.recommendTechniques(state, 'all');

                    const summary = {
                        coverage: coverage,
                        keyFindings: this.extractKeyFindings(state),
                        gaps: this.identifyGaps(state),
                        methodsUsed: this.analyzeMethodsUsed(state),
                        phaseInsights: this.generatePhaseInsights(state),
                        discoveryTechniques: recommendations.discovery,
                        coachingTechniques: recommendations.coaching
                    };

                    this.renderSummary(summary);

                    // Restore button state
                    btn.disabled = false;
                    btn.textContent = originalText;
                    btn.style.cursor = 'pointer';
                    btn.style.opacity = '1';
                }, 100);
            }

            extractKeyFindings(state) {
                const findings = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'answered' && q.findings.trim()) {
                        findings.push({
                            phase: q.phase,
                            questionId: q.questionId,
                            questionText: q.text,
                            text: q.findings
                        });
                    }
                });

                return findings;
            }

            identifyGaps(state) {
                const gaps = [];

                Object.values(state.questions).forEach(q => {
                    if (q.status === 'open' || !q.findings.trim()) {
                        gaps.push({
                            questionId: q.questionId,
                            text: q.text,
                            phase: q.phase
                        });
                    }
                });

                return gaps;
            }

            analyzeMethodsUsed(state) {
                const methodCounts = {};

                discoveryMethods.forEach(m => {
                    methodCounts[m.id] = {
                        label: m.label,
                        icon: m.icon,
                        count: 0
                    };
                });

                Object.values(state.questions).forEach(q => {
                    q.discoveryMethods.forEach(method => {
                        if (methodCounts[method]) {
                            methodCounts[method].count++;
                        }
                    });
                });

                return methodCounts;
            }

            generatePhaseInsights(state) {
                const insights = {};

                for (let phase = 1; phase <= 5; phase++) {
                    const phaseQuestions = Object.values(state.questions).filter(q => q.phase === phase);
                    const answered = phaseQuestions.filter(q => q.status === 'answered');

                    insights[phase] = {
                        name: discoveryQuestions[`phase${phase}`].name,
                        total: phaseQuestions.length,
                        answered: answered.length,
                        percentage: phaseQuestions.length > 0 ? (answered.length / phaseQuestions.length) * 100 : 0
                    };
                }

                return insights;
            }

            renderSummary(summary) {
                const summaryContainer = document.getElementById('summaryContent');

                const html = `
                    <div class="summary-section">
                        <h3>Overall Coverage: ${summary.coverage.overall.toFixed(1)}%</h3>
                        <p>${summary.coverage.answeredCount} of ${summary.coverage.totalCount} questions answered</p>
                    </div>

                    <div class="summary-section">
                        <h4>Key Findings</h4>
                        ${summary.keyFindings.length > 0 ? `
                            <ul>
                                ${summary.keyFindings.map(f => `
                                    <li>
                                        <strong>${f.questionText}</strong><br>
                                        ${f.text.substring(0, 300)}${f.text.length > 300 ? '...' : ''}
                                    </li>
                                `).join('')}
                            </ul>
                        ` : '<p>No findings recorded yet.</p>'}
                    </div>

                    <div class="summary-section">
                        <h4>Discovery Gaps</h4>
                        ${summary.gaps.length > 0 ? `
                            <ul class="gaps-list">
                                ${summary.gaps.map(g => `
                                    <li>Phase ${g.phase}: ${g.text}</li>
                                `).join('')}
                            </ul>
                        ` : '<p style="color: #4caf50; font-weight: 600;">All questions answered! âœ“</p>'}
                    </div>

                    <div class="summary-section">
                        <h4>Discovery Methods Used</h4>
                        <div class="methods-chart">
                            ${Object.entries(summary.methodsUsed).map(([key, method]) => `
                                <div class="method-stat ${method.count > 0 ? 'used' : ''}">
                                    <span class="method-icon">${method.icon}</span>
                                    <span class="method-label">${method.label}</span>
                                    <span class="method-count">${method.count}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="summary-section">
                        <h4>Phase-by-Phase Coverage</h4>
                        ${Object.entries(summary.phaseInsights).map(([phase, data]) => `
                            <div class="phase-insight">
                                <h5>Phase ${phase}: ${data.name}</h5>
                                <div class="phase-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${data.percentage}%"></div>
                                    </div>
                                    <span>${data.answered}/${data.total} (${data.percentage.toFixed(0)}%)</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div class="summary-section">
                        <h3>ðŸ“‹ Recommended Discovery Techniques (Top 10)</h3>
                        <p style="color: #666; margin-bottom: 15px;">Based on your discovery findings, here are specific techniques the TEAM should use:</p>
                        ${summary.discoveryTechniques && summary.discoveryTechniques.length > 0 ? `
                            <div class="technique-filters">
                                <div class="filter-group">
                                    <label class="filter-label">Time:</label>
                                    <button class="filter-btn active" data-filter-type="time" data-filter-value="all">All</button>
                                    <button class="filter-btn" data-filter-type="time" data-filter-value="hours">Hours</button>
                                    <button class="filter-btn" data-filter-type="time" data-filter-value="days">Days</button>
                                    <button class="filter-btn" data-filter-type="time" data-filter-value="weeks">Weeks+</button>
                                </div>
                                <div class="filter-group">
                                    <label class="filter-label">Maturity:</label>
                                    <button class="filter-btn active" data-filter-type="maturity" data-filter-value="all">All</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="beginner">Beginner</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="intermediate">Intermediate</button>
                                    <button class="filter-btn" data-filter-type="maturity" data-filter-value="advanced">Advanced</button>
                                </div>
                            </div>
                            <div class="techniques-recommendations">
                                ${summary.discoveryTechniques.map((rec, index) => {
                                    const technique = rec.technique;
                                    const categorySlug = technique.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');

                                    // Determine time category
                                    const timeCategory = technique.time_commitment.toLowerCase().includes('hour') ? 'hours' :
                                                        technique.time_commitment.toLowerCase().includes('day') ? 'days' : 'weeks';

                                    // Determine maturity level
                                    const maturityLevel = technique.team_maturity.some(m => m.toLowerCase().includes('beginner')) ? 'beginner' :
                                                         technique.team_maturity.some(m => m.toLowerCase().includes('advanced')) ? 'advanced' : 'intermediate';

                                    return `
                                        <div class="technique-card" data-collapsed="false" data-time="${timeCategory}" data-maturity="${maturityLevel}">
                                            <div class="technique-header">
                                                <div class="header-left">
                                                    <h4>${index + 1}. ${technique.name}</h4>
                                                    <span class="technique-badge ${categorySlug}">${technique.category}</span>
                                                    <span class="score-badge">Score: ${rec.score}</span>
                                                </div>
                                                <button class="collapse-btn" aria-label="Toggle details">
                                                    <span class="collapse-icon">â–¼</span>
                                                </button>
                                            </div>
                                            <div class="technique-collapsible-content">
                                                <p class="technique-description">${technique.description}</p>

                                            ${rec.matchReasons.length > 0 ? `
                                                <div class="technique-match-reasons">
                                                    <strong>Why this technique fits:</strong>
                                                    <ul>
                                                        ${rec.matchReasons.map(reason => `<li>${reason}</li>`).join('')}
                                                    </ul>
                                                </div>
                                            ` : ''}

                                            <div class="technique-meta">
                                                <div class="meta-item">
                                                    <span class="meta-label">When to use:</span>
                                                    <span class="meta-value">${technique.when_to_use}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Time commitment:</span>
                                                    <span class="meta-value">${technique.time_commitment}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Resources needed:</span>
                                                    <span class="meta-value">${technique.resources_needed.join(', ')}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Team maturity:</span>
                                                    <span class="meta-value">${technique.team_maturity.join(', ')}</span>
                                                </div>
                                            </div>

                                            <div class="technique-outcomes">
                                                <strong>Expected outcomes:</strong>
                                                <ul>
                                                    ${technique.outcomes.map(o => `<li>${o}</li>`).join('')}
                                                </ul>
                                            </div>

                                            ${formatFullExecution(technique.id)}

                                            <div class="technique-source">
                                                <small>Source: ${technique.svpg_source}</small>
                                            </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p>Answer more discovery questions to get personalized technique recommendations.</p>'}
                    </div>

                    ${summary.discoveryTechniques && summary.discoveryTechniques.length > 0 ? `
                        <div class="summary-section phase2-section">
                            <h3>ðŸŽ¯ RECOMMENDED TECHNIQUES</h3>
                            <p style="color: #666; margin-bottom: 20px;">Based on your discovery findings, here are the recommended techniques ranked from best to lowest fit:</p>

                            ${(() => {
                                const ranker = new TechniqueRanker(this.stateManager.getState());
                                const topApproaches = summary.discoveryTechniques.slice(0, 3); // Top 3 approaches

                                return topApproaches.map((rec, approachIndex) => {
                                    const approachKey = rec.technique.id;
                                    const techniqueIds = approachToTechniqueMappings[approachKey];

                                    if (!techniqueIds || techniqueIds.length === 0) return '';

                                    const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);

                                    return `
                                        <div class="phase2-approach-section" style="margin-bottom: 40px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #FF6B35;">
                                            <h4 style="margin: 0 0 15px 0; font-size: 18px; color: #333;">
                                                ${approachIndex + 1}ï¸âƒ£ ${rec.technique.name.toUpperCase()} (Score: ${rec.score}/100)
                                            </h4>
                                            <p style="color: #666; margin-bottom: 20px;">Why recommended: ${rec.matchReasons.slice(0, 2).join('; ')}</p>

                                            <div class="ranked-techniques">
                                                ${rankedTechniques.map((tech, techIndex) => {
                                                    const icon = getRankIcon(techIndex, tech.score);
                                                    const label = getRankLabel(techIndex, tech.score);

                                                    return `
                                                        <div class="ranked-technique-card" style="background: white; padding: 20px; margin-bottom: 15px; border-radius: 6px; border-left: 3px solid ${techIndex === 0 ? '#FFD700' : techIndex < 2 ? '#4CAF50' : '#999'};">
                                                            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                                                <span style="font-size: 24px; margin-right: 10px;">${icon}</span>
                                                                <h5 style="margin: 0; flex: 1; font-size: 16px; color: #333;">
                                                                    #${techIndex + 1} ${tech.name}
                                                                    <span style="color: ${techIndex === 0 ? '#FFD700' : techIndex < 2 ? '#4CAF50' : '#999'}; font-weight: bold; margin-left: 10px;">${label}</span>
                                                                    <span style="background: #e3f2fd; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-left: 10px; font-weight: normal;">Score: ${tech.score}/100</span>
                                                                </h5>
                                                            </div>

                                                            <p style="color: #666; margin: 10px 0; font-style: italic;">
                                                                Why: ${tech.matchReasons.slice(0, 2).join('; ') || tech.when_to_use}
                                                            </p>

                                                            ${tech.pros.length > 0 ? `
                                                                <div style="margin: 15px 0;">
                                                                    <strong style="color: #4CAF50;">âœ… Pros:</strong>
                                                                    <ul style="margin: 5px 0 0 20px; padding: 0; list-style: disc;">
                                                                        ${tech.pros.map(pro => `<li style="color: #555; margin: 3px 0;">${pro}</li>`).join('')}
                                                                    </ul>
                                                                </div>
                                                            ` : ''}

                                                            ${tech.cons.length > 0 ? `
                                                                <div style="margin: 15px 0;">
                                                                    <strong style="color: #f44336;">âŒ Cons:</strong>
                                                                    <ul style="margin: 5px 0 0 20px; padding: 0; list-style: disc;">
                                                                        ${tech.cons.map(con => `<li style="color: #555; margin: 3px 0;">${con}</li>`).join('')}
                                                                    </ul>
                                                                </div>
                                                            ` : ''}

                                                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                                                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 13px;">
                                                                    <div>
                                                                        <strong>When to use:</strong><br>
                                                                        <span style="color: #666;">${tech.when_to_use}</span>
                                                                    </div>
                                                                    <div>
                                                                        <strong>ðŸ‘¥ Team maturity:</strong><br>
                                                                        <span style="color: #666;">${tech.team_maturity.join(', ')}</span>
                                                                    </div>
                                                                    <div>
                                                                        <strong>ðŸ”§ Resources:</strong><br>
                                                                        <span style="color: #666;">${tech.resources_needed.join(', ')}</span>
                                                                    </div>
                                                                </div>
                                                                ${tech.quick_start ? `
                                                                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 4px;">
                                                                        <strong>ðŸ’¡ Quick start:</strong> ${tech.quick_start}
                                                                    </div>
                                                                ` : ''}
                                                            </div>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        </div>
                                    `;
                                }).join('');
                            })()}
                        </div>
                    ` : ''}

                    ${summary.discoveryTechniques && summary.discoveryTechniques.length > 0 ? `
                        <div class="summary-section phase3-section" style="margin-top: 40px; padding: 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; color: white;">
                            <h3 style="color: white; margin-bottom: 15px;">ðŸ“Š COMPARISON MATRIX</h3>
                            <p style="color: #f0f0f0; margin-bottom: 20px;">Compare techniques side-by-side to make the best decision for your situation</p>

                            ${(() => {
                                const ranker = new TechniqueRanker(this.stateManager.getState());
                                const topApproaches = summary.discoveryTechniques.slice(0, 3);

                                return topApproaches.map((rec, approachIndex) => {
                                    const approachKey = rec.technique.id;
                                    const techniqueIds = approachToTechniqueMappings[approachKey];

                                    if (!techniqueIds || techniqueIds.length === 0) return '';

                                    const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);
                                    const matrixBuilder = new ComparisonMatrixBuilder(rankedTechniques);
                                    const sortBy = 'relevance'; // Default sort
                                    const matrix = matrixBuilder.sortMatrix(sortBy);
                                    const explanation = matrixBuilder.getSortExplanation(sortBy);

                                    return `
                                        <div class="comparison-matrix-container" data-approach="${approachKey}" style="background: white; padding: 25px; border-radius: 8px; margin-bottom: 30px; color: #333;">
                                            <h4 style="margin: 0 0 10px 0; color: #333;">For "${rec.technique.name}"</h4>
                                            <p style="color: #666; margin-bottom: 15px; font-style: italic;">${explanation}</p>

                                            <div class="sort-controls" style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                                                <label style="font-weight: 600;">Sort by:</label>
                                                <select class="sort-dropdown" data-approach="${approachKey}" style="padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd;">
                                                    <option value="relevance" selected>Relevance (Best Fit)</option>
                                                    <option value="speed">Speed (Fastest First)</option>
                                                    <option value="cost">Cost (Lowest First)</option>
                                                    <option value="effort">Effort (Easiest First)</option>
                                                </select>
                                                <button class="btn-download-csv" data-approach="${approachKey}" style="padding: 5px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">ðŸ“¥ Download CSV</button>
                                                <button class="btn-print-matrix" data-approach="${approachKey}" style="padding: 5px 15px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">ðŸ–¨ï¸ Print</button>
                                            </div>

                                            <div class="matrix-table-wrapper" style="overflow-x: auto;">
                                                <table class="comparison-table" style="width: 100%; border-collapse: collapse; min-width: 600px;">
                                                    <thead>
                                                        <tr style="background: #f5f5f5;">
                                                            <th style="padding: 12px; text-align: left; border: 1px solid #ddd; font-weight: 600;">Criteria</th>
                                                            ${matrix.map((tech, index) => `
                                                                <th style="padding: 12px; text-align: left; border: 1px solid #ddd; background: ${getScoreColor(tech.score)}20;">
                                                                    ${index === 0 && tech.score >= 85 ? 'â­ ' : ''}${tech.name}
                                                                </th>
                                                            `).join('')}
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Relevance Score</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd; background: ${getScoreColor(tech.score)}20; font-weight: bold;">
                                                                    ${tech.score}/100
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Time Commitment</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd;">
                                                                    ${tech.timeCommitment}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Team Maturity</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd;">
                                                                    ${formatMaturity(tech.teamMaturity)}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Resource Cost</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd; background: ${getCostColor(tech.resourceCost)}20;">
                                                                    <span style="font-weight: 600; text-transform: uppercase; color: ${getCostColor(tech.resourceCost)};">${tech.resourceCost}</span>
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Key Strength</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd;">
                                                                    ${tech.keyStrength}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Best When</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd; font-size: 13px;">
                                                                    ${tech.bestWhen}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr>
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Resources Needed</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd;">
                                                                    ${tech.resourcesNeeded.join(', ')}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                        <tr style="background: #fffbf0;">
                                                            <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">ðŸ’¡ Quick Start</td>
                                                            ${matrix.map(tech => `
                                                                <td style="padding: 10px; border: 1px solid #ddd; font-style: italic;">
                                                                    ${tech.quickStart}
                                                                </td>
                                                            `).join('')}
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>

                                            <div style="margin-top: 15px; padding: 15px; background: #e8f5e9; border-radius: 6px; border-left: 4px solid #4CAF50;">
                                                <strong>âœ“ RECOMMENDED:</strong> ${matrix[0].name} (highest relevance for your situation)<br>
                                                ${matrix.length > 1 ? `<span style="color: #666;">Next best alternatives: ${matrix.slice(1, 3).map(t => t.name).join(', ')}</span>` : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('');
                            })()}
                        </div>
                    ` : ''}

                    <div class="summary-section coaching-section">
                        <h3>ðŸ‘¨â€ðŸ« Coaching Techniques for You (Top 5)</h3>
                        <p style="color: #666; margin-bottom: 20px;">As a coach, here are techniques to guide this team's development:</p>
                        ${summary.coachingTechniques && summary.coachingTechniques.length > 0 ? `
                            <div class="techniques-recommendations">
                                ${summary.coachingTechniques.map((rec, index) => {
                                    const technique = rec.technique;
                                    const categorySlug = technique.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');

                                    return `
                                        <div class="technique-card coaching-card">
                                            <div class="technique-header">
                                                <h4>${index + 1}. ${technique.name}</h4>
                                                <span class="technique-badge coaching">${technique.category}</span>
                                                <span class="score-badge coaching">Score: ${rec.score}</span>
                                            </div>
                                            <p class="technique-description">${technique.description}</p>

                                            ${rec.matchReasons.length > 0 ? `
                                                <div class="technique-match-reasons">
                                                    <strong>Why this technique fits:</strong>
                                                    <ul>
                                                        ${rec.matchReasons.map(reason => `<li>${reason}</li>`).join('')}
                                                    </ul>
                                                </div>
                                            ` : ''}

                                            <div class="technique-meta">
                                                <div class="meta-item">
                                                    <span class="meta-label">When to use:</span>
                                                    <span class="meta-value">${technique.when_to_use}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Time commitment:</span>
                                                    <span class="meta-value">${technique.time_commitment}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Resources needed:</span>
                                                    <span class="meta-value">${technique.resources_needed.join(', ')}</span>
                                                </div>
                                                <div class="meta-item">
                                                    <span class="meta-label">Team maturity:</span>
                                                    <span class="meta-value">${technique.team_maturity.join(', ')}</span>
                                                </div>
                                            </div>

                                            <div class="technique-outcomes">
                                                <strong>Expected outcomes:</strong>
                                                <ul>
                                                    ${technique.outcomes.map(o => `<li>${o}</li>`).join('')}
                                                </ul>
                                            </div>

                                            ${formatFullExecution(technique.id)}

                                            <div class="technique-source">
                                                <small>Source: ${technique.svpg_source}</small>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p>Answer more discovery questions to get personalized coaching technique recommendations.</p>'}
                    </div>
                `;

                summaryContainer.innerHTML = html;

                // Set up Phase 3 comparison matrix interactive features
                this.setupComparisonMatrixListeners();
            }

            setupComparisonMatrixListeners() {
                // Sort dropdown change handlers
                document.querySelectorAll('.sort-dropdown').forEach(dropdown => {
                    dropdown.addEventListener('change', (e) => {
                        const approachKey = e.target.dataset.approach;
                        const sortBy = e.target.value;
                        this.resortComparisonMatrix(approachKey, sortBy);
                    });
                });

                // Download CSV button handlers
                document.querySelectorAll('.btn-download-csv').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const approachKey = e.target.dataset.approach;
                        this.downloadComparisonCSV(approachKey);
                    });
                });

                // Print button handlers
                document.querySelectorAll('.btn-print-matrix').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const approachKey = e.target.dataset.approach;
                        this.printComparisonMatrix(approachKey);
                    });
                });
            }

            resortComparisonMatrix(approachKey, sortBy) {
                // Find the container
                const container = document.querySelector(`.comparison-matrix-container[data-approach="${approachKey}"]`);
                if (!container) return;

                // Get current state and regenerate matrix with new sort
                const state = this.stateManager.getState();
                const recommendations = this.techniqueRecommender.recommendTechniques(state, 'all');
                const approach = recommendations.discovery.find(rec => rec.technique.id === approachKey);

                if (!approach) return;

                const techniqueIds = approachToTechniqueMappings[approachKey];
                if (!techniqueIds) return;

                const ranker = new TechniqueRanker(state);
                const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);
                const matrixBuilder = new ComparisonMatrixBuilder(rankedTechniques);
                const matrix = matrixBuilder.sortMatrix(sortBy);
                const explanation = matrixBuilder.getSortExplanation(sortBy);

                // Update explanation text
                const explanationEl = container.querySelector('p[style*="font-style: italic"]');
                if (explanationEl) {
                    explanationEl.textContent = explanation;
                }

                // Rebuild table
                const tableWrapper = container.querySelector('.matrix-table-wrapper');
                if (tableWrapper) {
                    tableWrapper.innerHTML = `
                        <table class="comparison-table" style="width: 100%; border-collapse: collapse; min-width: 600px;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 12px; text-align: left; border: 1px solid #ddd; font-weight: 600;">Criteria</th>
                                    ${matrix.map((tech, index) => `
                                        <th style="padding: 12px; text-align: left; border: 1px solid #ddd; background: ${getScoreColor(tech.score)}20;">
                                            ${index === 0 && tech.score >= 85 ? 'â­ ' : ''}${tech.name}
                                        </th>
                                    `).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Relevance Score</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd; background: ${getScoreColor(tech.score)}20; font-weight: bold;">
                                            ${tech.score}/100
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Time Commitment</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd;">
                                            ${tech.timeCommitment}
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Team Maturity</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd;">
                                            ${formatMaturity(tech.teamMaturity)}
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Resource Cost</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd; background: ${getCostColor(tech.resourceCost)}20;">
                                            <span style="font-weight: 600; text-transform: uppercase; color: ${getCostColor(tech.resourceCost)};">${tech.resourceCost}</span>
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Key Strength</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd;">
                                            ${tech.keyStrength}
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Best When</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd; font-size: 13px;">
                                            ${tech.bestWhen}
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">Resources Needed</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd;">
                                            ${tech.resourcesNeeded.join(', ')}
                                        </td>
                                    `).join('')}
                                </tr>
                                <tr style="background: #fffbf0;">
                                    <td style="padding: 10px; border: 1px solid #ddd; font-weight: 600;">ðŸ’¡ Quick Start</td>
                                    ${matrix.map(tech => `
                                        <td style="padding: 10px; border: 1px solid #ddd; font-style: italic;">
                                            ${tech.quickStart}
                                        </td>
                                    `).join('')}
                                </tr>
                            </tbody>
                        </table>
                    `;
                }

                // Update recommendation box
                const recommendBox = container.querySelector('div[style*="background: #e8f5e9"]');
                if (recommendBox) {
                    recommendBox.innerHTML = `
                        <strong>âœ“ RECOMMENDED:</strong> ${matrix[0].name} (${sortBy === 'relevance' ? 'highest relevance' : sortBy === 'speed' ? 'fastest' : sortBy === 'cost' ? 'lowest cost' : 'easiest'} for your situation)<br>
                        ${matrix.length > 1 ? `<span style="color: #666;">Next best alternatives: ${matrix.slice(1, 3).map(t => t.name).join(', ')}</span>` : ''}
                    `;
                }
            }

            downloadComparisonCSV(approachKey) {
                const state = this.stateManager.getState();
                const recommendations = this.techniqueRecommender.recommendTechniques(state, 'all');
                const approach = recommendations.discovery.find(rec => rec.technique.id === approachKey);

                if (!approach) return;

                const techniqueIds = approachToTechniqueMappings[approachKey];
                if (!techniqueIds) return;

                const ranker = new TechniqueRanker(state);
                const rankedTechniques = ranker.rankTechniquesForApproach(approachKey, techniqueIds);
                const matrixBuilder = new ComparisonMatrixBuilder(rankedTechniques);

                // Get current sort from dropdown
                const dropdown = document.querySelector(`.sort-dropdown[data-approach="${approachKey}"]`);
                const sortBy = dropdown ? dropdown.value : 'relevance';
                const matrix = matrixBuilder.sortMatrix(sortBy);

                const csv = matrixBuilder.exportToCSV(matrix);
                const filename = `${approach.technique.name.replace(/\s+/g, '-')}-Comparison-${new Date().toISOString().split('T')[0]}.csv`;

                downloadCSV(csv, filename);
            }

            printComparisonMatrix(approachKey) {
                const container = document.querySelector(`.comparison-matrix-container[data-approach="${approachKey}"]`);
                if (!container) return;

                // Create print window
                const printWindow = window.open('', '', 'height=600,width=800');
                printWindow.document.write('<html><head><title>Technique Comparison Matrix</title>');
                printWindow.document.write('<style>');
                printWindow.document.write('body { font-family: Arial, sans-serif; padding: 20px; }');
                printWindow.document.write('table { width: 100%; border-collapse: collapse; margin: 20px 0; }');
                printWindow.document.write('th, td { padding: 10px; border: 1px solid #ddd; text-align: left; }');
                printWindow.document.write('th { background: #f5f5f5; font-weight: 600; }');
                printWindow.document.write('h1 { color: #333; }');
                printWindow.document.write('</style>');
                printWindow.document.write('</head><body>');
                printWindow.document.write('<h1>ðŸ“Š Technique Comparison Matrix</h1>');
                printWindow.document.write(container.innerHTML);
                printWindow.document.write('</body></html>');
                printWindow.document.close();
                printWindow.print();
            }
        }

        // View Mode Manager Class
        class ViewModeManager {
            constructor() {
                this.isViewMode = false;
                this.setupEventListeners();
                this.updateModeUI();
            }

            setupEventListeners() {
                const toggleBtn = document.getElementById('toggleModeBtn');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        this.toggleMode();
                    });
                }
            }

            toggleMode() {
                this.isViewMode = !this.isViewMode;
                this.updateModeUI();
                this.applyMode();

                // Show notification
                const message = this.isViewMode
                    ? 'Switched to View Mode - All inputs are now read-only'
                    : 'Switched to Edit Mode - You can now modify findings';
                const type = this.isViewMode ? 'info' : 'success';

                if (window.dataManager) {
                    window.dataManager.showNotification(message, type);
                }
            }

            setMode(isViewMode) {
                this.isViewMode = isViewMode;
                this.updateModeUI();
                this.applyMode();
            }

            updateModeUI() {
                const toggleBtn = document.getElementById('toggleModeBtn');

                if (this.isViewMode) {
                    toggleBtn.textContent = 'Edit Mode';
                    toggleBtn.className = 'btn-secondary';
                } else {
                    toggleBtn.textContent = 'View Mode';
                    toggleBtn.className = 'btn-secondary';
                }
            }

            applyMode() {
                // Disable/enable metadata inputs
                document.getElementById('clientName').disabled = this.isViewMode;
                document.getElementById('engagementDate').disabled = this.isViewMode;
                document.getElementById('coachName').disabled = this.isViewMode;

                // Disable/enable all question inputs
                document.querySelectorAll('.findings-input, .notes-input').forEach(input => {
                    input.disabled = this.isViewMode;
                });

                // Disable/enable all method tags
                document.querySelectorAll('.method-tag').forEach(tag => {
                    tag.disabled = this.isViewMode;
                });

                // Disable/enable all mark complete buttons
                document.querySelectorAll('.btn-mark-complete').forEach(btn => {
                    btn.disabled = this.isViewMode;
                });

                // Disable/enable new engagement button (don't want to accidentally clear in view mode)
                const newEngagementBtn = document.getElementById('newEngagement');
                if (newEngagementBtn) {
                    newEngagementBtn.disabled = this.isViewMode;
                    newEngagementBtn.style.opacity = this.isViewMode ? '0.5' : '1';
                }
            }

            getMode() {
                return this.isViewMode ? 'view' : 'edit';
            }
        }

        // ============================================
        // SESSION HEALTH MANAGER
        // ============================================
        class SessionHealthManager {
            constructor() {
                this.storageKey = 'lea_session_count';
                this.count = this.loadCount();
                this.setupEventListeners();
                this.updateDisplay();
                console.log(`[SessionHealth] Initialized with count: ${this.count}`);
            }

            loadCount() {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? parseInt(stored, 10) : 0;
            }

            saveCount() {
                localStorage.setItem(this.storageKey, this.count.toString());
                console.log(`[SessionHealth] Saved count: ${this.count}`);
            }

            increment() {
                this.count++;
                this.saveCount();
                this.updateDisplay();
                console.log(`[SessionHealth] Incremented to: ${this.count}`);
            }

            reset() {
                this.count = 0;
                this.saveCount();
                this.updateDisplay();
                console.log(`[SessionHealth] Reset to 0`);

                // Show confirmation notification
                if (window.dataManager) {
                    window.dataManager.showNotification('Session reset - optimal analysis quality restored', 'success');
                }
            }

            getHealthStatus() {
                if (this.count <= 1) {
                    return {
                        class: 'health-good',
                        message: ''
                    };
                } else if (this.count === 2) {
                    return {
                        class: 'health-warning',
                        message: 'Session health: Good - Consider fresh session after next analysis'
                    };
                } else {
                    return {
                        class: 'health-degrading',
                        message: 'Session health: Degrading - Fresh session recommended for optimal quality'
                    };
                }
            }

            updateDisplay() {
                const tracker = document.getElementById('sessionHealthTracker');
                const countEl = tracker.querySelector('.session-health-count');
                const messageEl = tracker.querySelector('.session-health-message');

                if (!tracker || !countEl || !messageEl) {
                    console.error('[SessionHealth] Could not find tracker elements');
                    return;
                }

                const status = this.getHealthStatus();

                // Update count text
                const analysisWord = this.count === 1 ? 'analysis' : 'analyses';
                countEl.textContent = `Session: ${this.count} ${analysisWord}`;

                // Update message
                messageEl.textContent = status.message;

                // Update class
                tracker.classList.remove('health-good', 'health-warning', 'health-degrading');
                tracker.classList.add(status.class);
            }

            setupEventListeners() {
                const freshSessionBtn = document.getElementById('freshSessionBtn');
                if (freshSessionBtn) {
                    freshSessionBtn.addEventListener('click', () => {
                        this.reset();
                    });
                }
            }

            getCount() {
                return this.count;
            }
        }

        // ============================================
        // TEST FRAMEWORK
        // ============================================
        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async runAll() {
                this.results = [];
                console.log('ðŸ§ª Starting LEA Regression Test Suite...\n');

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.results.push({ name: test.name, passed: true, error: null });
                        console.log(`âœ… PASS: ${test.name}`);
                    } catch (error) {
                        this.results.push({ name: test.name, passed: false, error: error.message });
                        console.error(`âŒ FAIL: ${test.name}`, error.message);
                    }
                }

                this.displayResults();
                return this.results;
            }

            displayResults() {
                const passed = this.results.filter(r => r.passed).length;
                const failed = this.results.filter(r => !r.passed).length;
                const total = this.results.length;

                console.log('\n' + '='.repeat(60));
                console.log(`ðŸ“Š Test Results: ${passed}/${total} passed, ${failed} failed`);
                console.log('='.repeat(60));

                this.showResultsModal(passed, failed, total);
            }

            showResultsModal(passed, failed, total) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: white; padding: 30px; border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000;
                    max-width: 600px; max-height: 80vh; overflow-y: auto;
                `;

                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5); z-index: 9999;
                `;

                const resultsHtml = `
                    <h2 style="margin-bottom: 20px;">ðŸ§ª LEA Regression Tests</h2>
                    <div style="margin-bottom: 20px;">
                        <strong>Total:</strong> ${total} tests<br>
                        <strong style="color: #4CAF50;">Passed:</strong> ${passed}<br>
                        <strong style="color: #f44336;">Failed:</strong> ${failed}
                    </div>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${this.results.map(r => `
                            <div style="padding: 8px; margin: 5px 0; background: ${r.passed ? '#e8f5e9' : '#ffebee'}; border-radius: 4px;">
                                ${r.passed ? 'âœ…' : 'âŒ'} ${r.name}
                                ${r.error ? `<br><small style="color: #d32f2f;">${r.error}</small>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <button id="closeTestResults" style="margin-top: 20px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                `;

                modal.innerHTML = resultsHtml;
                document.body.appendChild(overlay);
                document.body.appendChild(modal);

                document.getElementById('closeTestResults').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });

                overlay.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });
            }

            assert(condition, message) {
                if (!condition) throw new Error(message || 'Assertion failed');
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) throw new Error(message || `Expected ${expected}, got ${actual}`);
            }

            assertNotNull(value, message) {
                if (value === null || value === undefined) throw new Error(message || 'Value is null or undefined');
            }
        }

        // Initialize test framework
        const testFramework = new TestFramework();

        // Core functionality tests
        testFramework.test('All Manager Classes Initialize', () => {
            testFramework.assertNotNull(stateManager, 'StateManager should be initialized');
            testFramework.assertNotNull(tabNavigator, 'TabNavigator should be initialized');
            testFramework.assertNotNull(dataManager, 'DataManager should be initialized');
            testFramework.assertNotNull(summaryGenerator, 'SummaryGenerator should be initialized');
            testFramework.assertNotNull(viewModeManager, 'ViewModeManager should be initialized');
            testFramework.assertNotNull(sessionHealthManager, 'SessionHealthManager should be initialized');
        });

        testFramework.test('Technique Library Loads (50 techniques)', () => {
            testFramework.assertNotNull(svpgTechniqueLibrary, 'Library should exist');
            testFramework.assertNotNull(svpgTechniqueLibrary.discovery_techniques, 'Discovery techniques exist');
            testFramework.assertNotNull(svpgTechniqueLibrary.coaching_techniques, 'Coaching techniques exist');
            testFramework.assertEqual(svpgTechniqueLibrary.total_techniques, 50, 'Should have 50 techniques');
        });

        testFramework.test('Discovery Questions Defined', () => {
            testFramework.assertNotNull(discoveryQuestions, 'Questions should be defined');
            testFramework.assertNotNull(discoveryQuestions.phase1, 'Phase 1 exists');
            testFramework.assertNotNull(discoveryQuestions.phase2, 'Phase 2 exists');
            testFramework.assertNotNull(discoveryQuestions.phase3, 'Phase 3 exists');
            testFramework.assertNotNull(discoveryQuestions.phase4, 'Phase 4 exists');
            testFramework.assertNotNull(discoveryQuestions.phase5, 'Phase 5 exists');
        });

        testFramework.test('TechniqueRecommender Class Works', () => {
            const recommender = new TechniqueRecommender();
            testFramework.assertNotNull(recommender, 'TechniqueRecommender should instantiate');

            const mockState = {
                questions: {
                    q1: { questionId: 'q1', phase: 1, status: 'answered', findings: 'no customer contact', discoveryMethods: [] }
                }
            };

            const recommendations = recommender.recommendTechniques(mockState);
            testFramework.assertNotNull(recommendations, 'Should return recommendations');
            testFramework.assertNotNull(recommendations.discovery, 'Should have discovery array');
            testFramework.assertNotNull(recommendations.coaching, 'Should have coaching array');
            testFramework.assert(Array.isArray(recommendations.discovery), 'Discovery should be array');
            testFramework.assert(Array.isArray(recommendations.coaching), 'Coaching should be array');
        });

        testFramework.test('State Manager Initializes Questions', () => {
            const state = stateManager.getState();
            testFramework.assertNotNull(state.questions, 'Questions object exists');
            const questionCount = Object.keys(state.questions).length;
            testFramework.assertEqual(questionCount, 36, 'Should have 36 questions');
        });

        testFramework.test('Export Functionality Available', () => {
            testFramework.assertNotNull(dataManager.exportToJSON, 'Export method exists');
            testFramework.assert(typeof dataManager.exportToJSON === 'function', 'Export is a function');
        });

        testFramework.test('Import Functionality Available', () => {
            testFramework.assertNotNull(dataManager.importFromJSON, 'Import method exists');
            testFramework.assert(typeof dataManager.importFromJSON === 'function', 'Import is a function');
        });

        testFramework.test('Tab Navigation Works', () => {
            testFramework.assertNotNull(tabNavigator.switchTab, 'SwitchTab method exists');
            testFramework.assertEqual(tabNavigator.activeTab, "1", 'Default tab should be 1');
        });

        testFramework.test('Summary Generator Works', () => {
            testFramework.assertNotNull(summaryGenerator.generateSummary, 'Generate method exists');
            testFramework.assert(typeof summaryGenerator.generateSummary === 'function', 'Generate is a function');
            testFramework.assertNotNull(summaryGenerator.extractKeyFindings, 'Extract findings method exists');
            testFramework.assertNotNull(summaryGenerator.identifyGaps, 'Identify gaps method exists');
        });

        testFramework.test('View Mode Manager Works', () => {
            testFramework.assertNotNull(viewModeManager.setMode, 'SetMode method exists');
            testFramework.assertNotNull(viewModeManager.getMode, 'GetMode method exists');
            testFramework.assertEqual(viewModeManager.getMode(), 'edit', 'Default should be edit mode');
        });

        testFramework.test('Session Health Manager Works', () => {
            testFramework.assertNotNull(sessionHealthManager, 'SessionHealthManager should be initialized');
            testFramework.assertNotNull(sessionHealthManager.increment, 'Increment method exists');
            testFramework.assertNotNull(sessionHealthManager.reset, 'Reset method exists');
            testFramework.assertNotNull(sessionHealthManager.getCount, 'GetCount method exists');
            testFramework.assert(typeof sessionHealthManager.getCount() === 'number', 'Count should be a number');
        });

        // Global manager variables
        let stateManager, tabNavigator, dataManager, summaryGenerator, viewModeManager, sessionHealthManager;

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            stateManager = new QuestionStateManager();
            tabNavigator = new TabNavigator();
            dataManager = new DataManager(stateManager);
            summaryGenerator = new SummaryGenerator(stateManager);
            viewModeManager = new ViewModeManager();
            sessionHealthManager = new SessionHealthManager();

            // Make managers globally accessible
            window.viewModeManager = viewModeManager;
            window.dataManager = dataManager;
            window.sessionHealthManager = sessionHealthManager;

            // Set default engagement date
            document.getElementById('engagementDate').value = new Date().toISOString().split('T')[0];

            // Wire up test button
            document.getElementById('runTestsBtn').addEventListener('click', () => {
                console.clear();
                testFramework.runAll();
            });
        });
    </script>
</body>
</html>
